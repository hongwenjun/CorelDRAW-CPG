// Created by Microsoft (R) C/C++ Compiler Version 14.40.33808.0 (cc163f71).
//
// R:\lycpg64\obj\Release\vgcoreauto.tli
//
// Wrapper implementations for type library vgcoreauto.tlb
// compiler-generated file - DO NOT EDIT!


//
// interface ICorelImportFilter wrapper method implementations
//

#pragma implementation_key(1)
inline HRESULT VGCore::ICorelImportFilter::Reset ( ) {
    HRESULT _hr = raw_Reset();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(2)
inline HRESULT VGCore::ICorelImportFilter::Finish ( ) {
    HRESULT _hr = raw_Finish();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(3)
inline VARIANT_BOOL VGCore::ICorelImportFilter::GetHasDialog ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_HasDialog(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4)
inline VARIANT_BOOL VGCore::ICorelImportFilter::ShowDialog ( long hWnd ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_ShowDialog(hWnd, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface ICorelExportFilter wrapper method implementations
//

#pragma implementation_key(5)
inline HRESULT VGCore::ICorelExportFilter::Reset ( ) {
    HRESULT _hr = raw_Reset();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(6)
inline HRESULT VGCore::ICorelExportFilter::Finish ( ) {
    HRESULT _hr = raw_Finish();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(7)
inline VARIANT_BOOL VGCore::ICorelExportFilter::GetHasDialog ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_HasDialog(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(8)
inline VARIANT_BOOL VGCore::ICorelExportFilter::ShowDialog ( long hWnd ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_ShowDialog(hWnd, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface ICUIControlData wrapper method implementations
//

#pragma implementation_key(9)
inline _variant_t VGCore::ICUIControlData::GetValue ( _bstr_t PropertyName ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = raw_GetValue(PropertyName, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

//
// interface ICUIAutomation wrapper method implementations
//

#pragma implementation_key(10)
inline long VGCore::ICUIAutomation::GetNumItemsOnBar ( _bstr_t GuidBar ) {
    long _result = 0;
    HRESULT _hr = raw_GetNumItemsOnBar(GuidBar, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(11)
inline _bstr_t VGCore::ICUIAutomation::GetItem ( _bstr_t GuidBar, long Index, VARIANT_BOOL * HasSubBar ) {
    BSTR _result = 0;
    HRESULT _hr = raw_GetItem(GuidBar, Index, HasSubBar, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(12)
inline long VGCore::ICUIAutomation::GetItemInstanceHwnd ( _bstr_t GuidParent, _bstr_t GuidItem ) {
    long _result = 0;
    HRESULT _hr = raw_GetItemInstanceHwnd(GuidParent, GuidItem, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(13)
inline VARIANT_BOOL VGCore::ICUIAutomation::GetSubBar ( _bstr_t GuidBar, BSTR * GuidSubBar ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_GetSubBar(GuidBar, GuidSubBar, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(14)
inline VARIANT_BOOL VGCore::ICUIAutomation::ShowBar ( _bstr_t GuidBar, VARIANT_BOOL Show ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_ShowBar(GuidBar, Show, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(15)
inline _bstr_t VGCore::ICUIAutomation::GetCaptionText ( _bstr_t GuidItem ) {
    BSTR _result = 0;
    HRESULT _hr = raw_GetCaptionText(GuidItem, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(16)
inline HRESULT VGCore::ICUIAutomation::Invoke ( _bstr_t GuidItem ) {
    HRESULT _hr = raw_Invoke(GuidItem);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(17)
inline VARIANT_BOOL VGCore::ICUIAutomation::IsEnabled ( _bstr_t GuidItem ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_IsEnabled(GuidItem, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(18)
inline VARIANT_BOOL VGCore::ICUIAutomation::GetItemScreenRect ( _bstr_t GuidParent, _bstr_t GuidItem, long * TopLeftX, long * TopLeftY, long * Width, long * Height ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_GetItemScreenRect(GuidParent, GuidItem, TopLeftX, TopLeftY, Width, Height, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(19)
inline HRESULT VGCore::ICUIAutomation::InvokeItem ( _bstr_t GuidItem ) {
    HRESULT _hr = raw_InvokeItem(GuidItem);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(20)
inline HRESULT VGCore::ICUIAutomation::InvokeDialogItem ( _bstr_t GuidDialog, _bstr_t GuidItem ) {
    HRESULT _hr = raw_InvokeDialogItem(GuidDialog, GuidItem);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(21)
inline VGCore::ICUIControlDataPtr VGCore::ICUIAutomation::GetControlData ( _bstr_t Guid ) {
    struct ICUIControlData * _result = 0;
    HRESULT _hr = raw_GetControlData(Guid, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return ICUIControlDataPtr(_result, false);
}

#pragma implementation_key(22)
inline VGCore::ICUIControlDataPtr VGCore::ICUIAutomation::GetControlDataEx ( _bstr_t GuidParent, _bstr_t Guid ) {
    struct ICUIControlData * _result = 0;
    HRESULT _hr = raw_GetControlDataEx(GuidParent, Guid, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return ICUIControlDataPtr(_result, false);
}

#pragma implementation_key(23)
inline VARIANT_BOOL VGCore::ICUIAutomation::GetActiveMenuItemScreenRect ( int itemIndex, long * TopLeftX, long * TopLeftY, long * Width, long * Height ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_GetActiveMenuItemScreenRect(itemIndex, TopLeftX, TopLeftY, Width, Height, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(24)
inline _bstr_t VGCore::ICUIAutomation::GetActiveMenuItemGuid ( int itemIndex ) {
    BSTR _result = 0;
    HRESULT _hr = raw_GetActiveMenuItemGuid(itemIndex, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

//
// interface ICUIControl wrapper method implementations
//

#pragma implementation_key(25)
inline _bstr_t VGCore::ICUIControl::GetCaption ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Caption(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(26)
inline void VGCore::ICUIControl::PutCaption ( _bstr_t pVal ) {
    HRESULT _hr = put_Caption(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(27)
inline _bstr_t VGCore::ICUIControl::GetDescriptionText ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_DescriptionText(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(28)
inline void VGCore::ICUIControl::PutDescriptionText ( _bstr_t pVal ) {
    HRESULT _hr = put_DescriptionText(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(29)
inline long VGCore::ICUIControl::GetHeight ( ) {
    long _result = 0;
    HRESULT _hr = get_Height(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(30)
inline void VGCore::ICUIControl::PutHeight ( long pVal ) {
    HRESULT _hr = put_Height(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(31)
inline long VGCore::ICUIControl::GetWidth ( ) {
    long _result = 0;
    HRESULT _hr = get_Width(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(32)
inline void VGCore::ICUIControl::PutWidth ( long pVal ) {
    HRESULT _hr = put_Width(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(33)
inline _bstr_t VGCore::ICUIControl::GetID ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_ID(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(34)
inline _variant_t VGCore::ICUIControl::GetParameter ( ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = get_Parameter(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

#pragma implementation_key(35)
inline void VGCore::ICUIControl::PutParameter ( const _variant_t & pVal ) {
    HRESULT _hr = put_Parameter(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(36)
inline _bstr_t VGCore::ICUIControl::GetTag ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Tag(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(37)
inline void VGCore::ICUIControl::PutTag ( _bstr_t pVal ) {
    HRESULT _hr = put_Tag(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(38)
inline _bstr_t VGCore::ICUIControl::GetToolTipText ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_ToolTipText(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(39)
inline void VGCore::ICUIControl::PutToolTipText ( _bstr_t pVal ) {
    HRESULT _hr = put_ToolTipText(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(40)
inline VARIANT_BOOL VGCore::ICUIControl::GetVisible ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_Visible(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(41)
inline void VGCore::ICUIControl::PutVisible ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_Visible(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(42)
inline HRESULT VGCore::ICUIControl::SetIcon ( long RowIndex, long ColumnIndex ) {
    HRESULT _hr = raw_SetIcon(RowIndex, ColumnIndex);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(43)
inline HRESULT VGCore::ICUIControl::SetCustomIcon ( _bstr_t ImageFile ) {
    HRESULT _hr = raw_SetCustomIcon(ImageFile);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(44)
inline HRESULT VGCore::ICUIControl::SetIcon2 ( _bstr_t Icon ) {
    HRESULT _hr = raw_SetIcon2(Icon);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface ICUIControls wrapper method implementations
//

#pragma implementation_key(45)
inline long VGCore::ICUIControls::GetCount ( ) {
    long _result = 0;
    HRESULT _hr = get_Count(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(46)
inline VGCore::ICUIControlPtr VGCore::ICUIControls::GetItem ( long Index ) {
    struct ICUIControl * _result = 0;
    HRESULT _hr = get_Item(Index, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return ICUIControlPtr(_result, false);
}

#pragma implementation_key(47)
inline IUnknownPtr VGCore::ICUIControls::Get_NewEnum ( ) {
    IUnknown * _result = 0;
    HRESULT _hr = get__NewEnum(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IUnknownPtr(_result, false);
}

#pragma implementation_key(48)
inline VGCore::ICUIControlPtr VGCore::ICUIControls::Add ( _bstr_t ControlID, long Index, VARIANT_BOOL Temporary ) {
    struct ICUIControl * _result = 0;
    HRESULT _hr = raw_Add(ControlID, Index, Temporary, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return ICUIControlPtr(_result, false);
}

#pragma implementation_key(49)
inline VGCore::ICUIControlPtr VGCore::ICUIControls::AddCustomButton ( _bstr_t CategoryID, _bstr_t Command, long Index, VARIANT_BOOL Temporary ) {
    struct ICUIControl * _result = 0;
    HRESULT _hr = raw_AddCustomButton(CategoryID, Command, Index, Temporary, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return ICUIControlPtr(_result, false);
}

#pragma implementation_key(50)
inline VGCore::ICUIControlPtr VGCore::ICUIControls::AddCustomControl ( _bstr_t ClassName, _bstr_t AssemblyPath, long Index, VARIANT_BOOL Temporary ) {
    struct ICUIControl * _result = 0;
    HRESULT _hr = raw_AddCustomControl(ClassName, AssemblyPath, Index, Temporary, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return ICUIControlPtr(_result, false);
}

#pragma implementation_key(51)
inline VGCore::ICUIControlPtr VGCore::ICUIControls::AddToggleButton ( _bstr_t Guid, long Index, VARIANT_BOOL Temporary ) {
    struct ICUIControl * _result = 0;
    HRESULT _hr = raw_AddToggleButton(Guid, Index, Temporary, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return ICUIControlPtr(_result, false);
}

#pragma implementation_key(52)
inline HRESULT VGCore::ICUIControls::Remove ( long Index ) {
    HRESULT _hr = raw_Remove(Index);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface ICUICommandBarMode wrapper method implementations
//

#pragma implementation_key(53)
inline _bstr_t VGCore::ICUICommandBarMode::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(54)
inline _bstr_t VGCore::ICUICommandBarMode::GetNameLocal ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_NameLocal(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(55)
inline VGCore::ICUIControlsPtr VGCore::ICUICommandBarMode::GetControls ( ) {
    struct ICUIControls * _result = 0;
    HRESULT _hr = get_Controls(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return ICUIControlsPtr(_result, false);
}

//
// interface ICUICommandBarModes wrapper method implementations
//

#pragma implementation_key(56)
inline VGCore::ICUICommandBarModePtr VGCore::ICUICommandBarModes::GetItem ( const _variant_t & IndexOrName ) {
    struct ICUICommandBarMode * _result = 0;
    HRESULT _hr = get_Item(IndexOrName, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return ICUICommandBarModePtr(_result, false);
}

#pragma implementation_key(57)
inline long VGCore::ICUICommandBarModes::GetCount ( ) {
    long _result = 0;
    HRESULT _hr = get_Count(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(58)
inline IUnknownPtr VGCore::ICUICommandBarModes::Get_NewEnum ( ) {
    IUnknown * _result = 0;
    HRESULT _hr = get__NewEnum(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IUnknownPtr(_result, false);
}

//
// interface ICUICommandBar wrapper method implementations
//

#pragma implementation_key(59)
inline enum VGCore::cuiBarType VGCore::ICUICommandBar::GetType ( ) {
    enum cuiBarType _result;
    HRESULT _hr = get_Type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(60)
inline VARIANT_BOOL VGCore::ICUICommandBar::GetVisible ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_Visible(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(61)
inline void VGCore::ICUICommandBar::PutVisible ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_Visible(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(62)
inline VGCore::ICUIControlsPtr VGCore::ICUICommandBar::GetControls ( ) {
    struct ICUIControls * _result = 0;
    HRESULT _hr = get_Controls(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return ICUIControlsPtr(_result, false);
}

#pragma implementation_key(63)
inline VGCore::ICUICommandBarModesPtr VGCore::ICUICommandBar::GetModes ( ) {
    struct ICUICommandBarModes * _result = 0;
    HRESULT _hr = get_Modes(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return ICUICommandBarModesPtr(_result, false);
}

#pragma implementation_key(64)
inline VARIANT_BOOL VGCore::ICUICommandBar::GetBuiltIn ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_BuiltIn(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(65)
inline VARIANT_BOOL VGCore::ICUICommandBar::GetEnabled ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_Enabled(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(66)
inline void VGCore::ICUICommandBar::PutEnabled ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_Enabled(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(67)
inline long VGCore::ICUICommandBar::GetLeft ( ) {
    long _result = 0;
    HRESULT _hr = get_Left(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(68)
inline void VGCore::ICUICommandBar::PutLeft ( long pVal ) {
    HRESULT _hr = put_Left(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(69)
inline long VGCore::ICUICommandBar::GetTop ( ) {
    long _result = 0;
    HRESULT _hr = get_Top(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(70)
inline void VGCore::ICUICommandBar::PutTop ( long pVal ) {
    HRESULT _hr = put_Top(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(71)
inline long VGCore::ICUICommandBar::GetHeight ( ) {
    long _result = 0;
    HRESULT _hr = get_Height(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(72)
inline long VGCore::ICUICommandBar::GetWidth ( ) {
    long _result = 0;
    HRESULT _hr = get_Width(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(73)
inline long VGCore::ICUICommandBar::GetIndex ( ) {
    long _result = 0;
    HRESULT _hr = get_Index(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(74)
inline _bstr_t VGCore::ICUICommandBar::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(75)
inline void VGCore::ICUICommandBar::PutName ( _bstr_t pVal ) {
    HRESULT _hr = put_Name(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(76)
inline _bstr_t VGCore::ICUICommandBar::GetNameLocal ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_NameLocal(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(77)
inline void VGCore::ICUICommandBar::PutNameLocal ( _bstr_t pVal ) {
    HRESULT _hr = put_NameLocal(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(78)
inline enum VGCore::cuiBarPosition VGCore::ICUICommandBar::GetPosition ( ) {
    enum cuiBarPosition _result;
    HRESULT _hr = get_Position(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(79)
inline void VGCore::ICUICommandBar::PutPosition ( enum cuiBarPosition pVal ) {
    HRESULT _hr = put_Position(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(80)
inline enum VGCore::cuiBarProtection VGCore::ICUICommandBar::GetProtection ( ) {
    enum cuiBarProtection _result;
    HRESULT _hr = get_Protection(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(81)
inline void VGCore::ICUICommandBar::PutProtection ( enum cuiBarProtection pVal ) {
    HRESULT _hr = put_Protection(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(82)
inline HRESULT VGCore::ICUICommandBar::Delete ( ) {
    HRESULT _hr = raw_Delete();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(83)
inline HRESULT VGCore::ICUICommandBar::Reset ( ) {
    HRESULT _hr = raw_Reset();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(84)
inline HRESULT VGCore::ICUICommandBar::ShowPopup ( const _variant_t & x, const _variant_t & y ) {
    HRESULT _hr = raw_ShowPopup(x, y);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(85)
inline HRESULT VGCore::ICUICommandBar::SetWidth ( long Width ) {
    HRESULT _hr = raw_SetWidth(Width);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface ICUICommandBars wrapper method implementations
//

#pragma implementation_key(86)
inline VGCore::ICUICommandBarPtr VGCore::ICUICommandBars::GetItem ( const _variant_t & IndexOrName ) {
    struct ICUICommandBar * _result = 0;
    HRESULT _hr = get_Item(IndexOrName, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return ICUICommandBarPtr(_result, false);
}

#pragma implementation_key(87)
inline long VGCore::ICUICommandBars::GetCount ( ) {
    long _result = 0;
    HRESULT _hr = get_Count(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(88)
inline IUnknownPtr VGCore::ICUICommandBars::Get_NewEnum ( ) {
    IUnknown * _result = 0;
    HRESULT _hr = get__NewEnum(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IUnknownPtr(_result, false);
}

#pragma implementation_key(89)
inline VGCore::ICUICommandBarPtr VGCore::ICUICommandBars::Add ( _bstr_t Name, enum cuiBarPosition Position, VARIANT_BOOL Temporary ) {
    struct ICUICommandBar * _result = 0;
    HRESULT _hr = raw_Add(Name, Position, Temporary, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return ICUICommandBarPtr(_result, false);
}

//
// interface ICUIScreenRect wrapper method implementations
//

#pragma implementation_key(90)
inline long VGCore::ICUIScreenRect::GetLeft ( ) {
    long _result = 0;
    HRESULT _hr = get_Left(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(91)
inline void VGCore::ICUIScreenRect::PutLeft ( long pVal ) {
    HRESULT _hr = put_Left(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(92)
inline long VGCore::ICUIScreenRect::GetRight ( ) {
    long _result = 0;
    HRESULT _hr = get_Right(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(93)
inline void VGCore::ICUIScreenRect::PutRight ( long pVal ) {
    HRESULT _hr = put_Right(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(94)
inline long VGCore::ICUIScreenRect::GetTop ( ) {
    long _result = 0;
    HRESULT _hr = get_Top(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(95)
inline void VGCore::ICUIScreenRect::PutTop ( long pVal ) {
    HRESULT _hr = put_Top(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(96)
inline long VGCore::ICUIScreenRect::GetBottom ( ) {
    long _result = 0;
    HRESULT _hr = get_Bottom(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(97)
inline void VGCore::ICUIScreenRect::PutBottom ( long pVal ) {
    HRESULT _hr = put_Bottom(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(98)
inline long VGCore::ICUIScreenRect::GetWidth ( ) {
    long _result = 0;
    HRESULT _hr = get_Width(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(99)
inline void VGCore::ICUIScreenRect::PutWidth ( long pVal ) {
    HRESULT _hr = put_Width(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(100)
inline long VGCore::ICUIScreenRect::GetHeight ( ) {
    long _result = 0;
    HRESULT _hr = get_Height(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(101)
inline void VGCore::ICUIScreenRect::PutHeight ( long pVal ) {
    HRESULT _hr = put_Height(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(102)
inline long VGCore::ICUIScreenRect::GetCenterX ( ) {
    long _result = 0;
    HRESULT _hr = get_CenterX(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(103)
inline void VGCore::ICUIScreenRect::PutCenterX ( long pVal ) {
    HRESULT _hr = put_CenterX(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(104)
inline long VGCore::ICUIScreenRect::GetCenterY ( ) {
    long _result = 0;
    HRESULT _hr = get_CenterY(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(105)
inline void VGCore::ICUIScreenRect::PutCenterY ( long pVal ) {
    HRESULT _hr = put_CenterY(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(106)
inline HRESULT VGCore::ICUIScreenRect::SetPosition ( long Left, long Top, long Width, long Height ) {
    HRESULT _hr = raw_SetPosition(Left, Top, Width, Height);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(107)
inline HRESULT VGCore::ICUIScreenRect::Resize ( long Width, long Height ) {
    HRESULT _hr = raw_Resize(Width, Height);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(108)
inline HRESULT VGCore::ICUIScreenRect::Move ( long Left, long Top ) {
    HRESULT _hr = raw_Move(Left, Top);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(109)
inline VARIANT_BOOL VGCore::ICUIScreenRect::GetReadOnly ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_ReadOnly(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(110)
inline VGCore::ICUIScreenRectPtr VGCore::ICUIScreenRect::GetCopy ( ) {
    struct ICUIScreenRect * _result = 0;
    HRESULT _hr = raw_GetCopy(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return ICUIScreenRectPtr(_result, false);
}

#pragma implementation_key(111)
inline HRESULT VGCore::ICUIScreenRect::CopyAssign ( struct ICUIScreenRect * Source ) {
    HRESULT _hr = raw_CopyAssign(Source);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(112)
inline HRESULT VGCore::ICUIScreenRect::Offset ( long OffsetX, long OffsetY ) {
    HRESULT _hr = raw_Offset(OffsetX, OffsetY);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(113)
inline HRESULT VGCore::ICUIScreenRect::Inflate ( long Left, long Top, long Right, long Bottom ) {
    HRESULT _hr = raw_Inflate(Left, Top, Right, Bottom);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(114)
inline VARIANT_BOOL VGCore::ICUIScreenRect::IsPointInside ( long x, long y ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_IsPointInside(x, y, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(115)
inline VGCore::ICUIScreenRectPtr VGCore::ICUIScreenRect::Union ( struct ICUIScreenRect * Source ) {
    struct ICUIScreenRect * _result = 0;
    HRESULT _hr = raw_Union(Source, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return ICUIScreenRectPtr(_result, false);
}

#pragma implementation_key(116)
inline VGCore::ICUIScreenRectPtr VGCore::ICUIScreenRect::Intersect ( struct ICUIScreenRect * Source ) {
    struct ICUIScreenRect * _result = 0;
    HRESULT _hr = raw_Intersect(Source, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return ICUIScreenRectPtr(_result, false);
}

#pragma implementation_key(117)
inline VARIANT_BOOL VGCore::ICUIScreenRect::IsEmpty ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_IsEmpty(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface ICUIBitmapImage wrapper method implementations
//

#pragma implementation_key(118)
inline VARIANT_BOOL VGCore::ICUIBitmapImage::GetValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_Valid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(119)
inline long VGCore::ICUIBitmapImage::GetWidth ( ) {
    long _result = 0;
    HRESULT _hr = get_Width(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(120)
inline long VGCore::ICUIBitmapImage::GetHeight ( ) {
    long _result = 0;
    HRESULT _hr = get_Height(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface ICUIImageList wrapper method implementations
//

#pragma implementation_key(121)
inline long VGCore::ICUIImageList::GetImageCount ( ) {
    long _result = 0;
    HRESULT _hr = get_ImageCount(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(122)
inline VARIANT_BOOL VGCore::ICUIImageList::ImageExists ( _bstr_t Key ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_ImageExists(Key, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(123)
inline HRESULT VGCore::ICUIImageList::RemoveAll ( ) {
    HRESULT _hr = raw_RemoveAll();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(124)
inline VARIANT_BOOL VGCore::ICUIImageList::AddImage ( _bstr_t Key, const _variant_t & ImageData, long MaxSize ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_AddImage(Key, ImageData, MaxSize, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(125)
inline SAFEARRAY * VGCore::ICUIImageList::GetImageKeys ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = get_ImageKeys(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(126)
inline VARIANT_BOOL VGCore::ICUIImageList::RemoveImage ( _bstr_t Key ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_RemoveImage(Key, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(127)
inline HRESULT VGCore::ICUIImageList::AddBitmap ( _bstr_t Key, struct ICUIBitmapImage * Bitmap ) {
    HRESULT _hr = raw_AddBitmap(Key, Bitmap);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface ICUIStatusText wrapper method implementations
//

#pragma implementation_key(128)
inline HRESULT VGCore::ICUIStatusText::SetCaptionText ( _bstr_t Text ) {
    HRESULT _hr = raw_SetCaptionText(Text);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(129)
inline HRESULT VGCore::ICUIStatusText::SetBitmap ( struct ICUIBitmapImage * Bitmap ) {
    HRESULT _hr = raw_SetBitmap(Bitmap);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface ICUIWarning wrapper method implementations
//

#pragma implementation_key(130)
inline VARIANT_BOOL VGCore::ICUIWarning::GetEnabled ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_Enabled(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(131)
inline void VGCore::ICUIWarning::PutEnabled ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_Enabled(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(132)
inline _bstr_t VGCore::ICUIWarning::GetID ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_ID(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(133)
inline _bstr_t VGCore::ICUIWarning::GetDescription ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Description(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(134)
inline _bstr_t VGCore::ICUIWarning::GetText ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Text(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(135)
inline _bstr_t VGCore::ICUIWarning::GetTitle ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Title(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(136)
inline long VGCore::ICUIWarning::DoWarningDialog ( long unFlags, _bstr_t Text ) {
    long _result = 0;
    HRESULT _hr = raw_DoWarningDialog(unFlags, Text, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface ICUITask wrapper method implementations
//

#pragma implementation_key(137)
inline HRESULT VGCore::ICUITask::RunTask ( ) {
    HRESULT _hr = raw_RunTask();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface ICUIBackgroundTask wrapper method implementations
//

#pragma implementation_key(138)
inline HRESULT VGCore::ICUIBackgroundTask::FinalizeTask ( ) {
    HRESULT _hr = raw_FinalizeTask();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(139)
inline HRESULT VGCore::ICUIBackgroundTask::FreeTask ( ) {
    HRESULT _hr = raw_FreeTask();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(140)
inline HRESULT VGCore::ICUIBackgroundTask::QuitTask ( ) {
    HRESULT _hr = raw_QuitTask();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(141)
inline _bstr_t VGCore::ICUIBackgroundTask::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

//
// interface ICUIRunningTask wrapper method implementations
//

#pragma implementation_key(142)
inline HRESULT VGCore::ICUIRunningTask::TryAbort ( ) {
    HRESULT _hr = raw_TryAbort();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface ICUIRunningBackgroundTask wrapper method implementations
//

#pragma implementation_key(143)
inline HRESULT VGCore::ICUIRunningBackgroundTask::WaitUntilDone ( ) {
    HRESULT _hr = raw_WaitUntilDone();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(144)
inline HRESULT VGCore::ICUIRunningBackgroundTask::Reprioritize ( enum cuiTaskPriority __MIDL__ICUIRunningBackgroundTask0000 ) {
    HRESULT _hr = raw_Reprioritize(__MIDL__ICUIRunningBackgroundTask0000);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(145)
inline VARIANT_BOOL VGCore::ICUIRunningBackgroundTask::FinalizeIfDone ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_FinalizeIfDone(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface ICUITaskManager wrapper method implementations
//

#pragma implementation_key(146)
inline HRESULT VGCore::ICUITaskManager::RunOnUIThread ( struct ICUITask * pTask ) {
    HRESULT _hr = raw_RunOnUIThread(pTask);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(147)
inline VGCore::ICUIRunningBackgroundTaskPtr VGCore::ICUITaskManager::RunInBackground ( enum cuiTaskPriority priority, struct ICUIBackgroundTask * pTask ) {
    struct ICUIRunningBackgroundTask * _result = 0;
    HRESULT _hr = raw_RunInBackground(priority, pTask, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return ICUIRunningBackgroundTaskPtr(_result, false);
}

//
// interface IPrnVBAPrintLayout wrapper method implementations
//

#pragma implementation_key(148)
inline VARIANT_BOOL VGCore::IPrnVBAPrintLayout::GetUseBleedLimit ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_UseBleedLimit(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(149)
inline void VGCore::IPrnVBAPrintLayout::PutUseBleedLimit ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_UseBleedLimit(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(150)
inline double VGCore::IPrnVBAPrintLayout::GetBleedLimit ( ) {
    double _result = 0;
    HRESULT _hr = get_BleedLimit(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(151)
inline void VGCore::IPrnVBAPrintLayout::PutBleedLimit ( double pVal ) {
    HRESULT _hr = put_BleedLimit(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(152)
inline VARIANT_BOOL VGCore::IPrnVBAPrintLayout::GetPrintTiledPages ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_PrintTiledPages(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(153)
inline void VGCore::IPrnVBAPrintLayout::PutPrintTiledPages ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_PrintTiledPages(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(154)
inline VARIANT_BOOL VGCore::IPrnVBAPrintLayout::GetPrintTilingMarks ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_PrintTilingMarks(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(155)
inline void VGCore::IPrnVBAPrintLayout::PutPrintTilingMarks ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_PrintTilingMarks(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(156)
inline double VGCore::IPrnVBAPrintLayout::GetTileOverlap ( ) {
    double _result = 0;
    HRESULT _hr = get_TileOverlap(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(157)
inline void VGCore::IPrnVBAPrintLayout::PutTileOverlap ( double pVal ) {
    HRESULT _hr = put_TileOverlap(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(158)
inline enum VGCore::PrnPlaceType VGCore::IPrnVBAPrintLayout::GetPlacement ( ) {
    enum PrnPlaceType _result;
    HRESULT _hr = get_Placement(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(159)
inline void VGCore::IPrnVBAPrintLayout::PutPlacement ( enum PrnPlaceType pVal ) {
    HRESULT _hr = put_Placement(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IPrnVBAPrinter wrapper method implementations
//

#pragma implementation_key(160)
inline _bstr_t VGCore::IPrnVBAPrinter::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(161)
inline _bstr_t VGCore::IPrnVBAPrinter::GetType ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(162)
inline VARIANT_BOOL VGCore::IPrnVBAPrinter::GetDefault ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_Default(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(163)
inline VARIANT_BOOL VGCore::IPrnVBAPrinter::GetReady ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_Ready(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(164)
inline _bstr_t VGCore::IPrnVBAPrinter::GetPort ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Port(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(165)
inline _bstr_t VGCore::IPrnVBAPrinter::GetDescription ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Description(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(166)
inline VARIANT_BOOL VGCore::IPrnVBAPrinter::GetPostScriptEnabled ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_PostScriptEnabled(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(167)
inline VARIANT_BOOL VGCore::IPrnVBAPrinter::GetColorEnabled ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_ColorEnabled(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(168)
inline HRESULT VGCore::IPrnVBAPrinter::ShowDialog ( ) {
    HRESULT _hr = raw_ShowDialog();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(169)
inline VARIANT_BOOL VGCore::IPrnVBAPrinter::GetPageSizeMatchingSupported ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_PageSizeMatchingSupported(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(170)
inline void VGCore::IPrnVBAPrinter::PutPageSizeMatchingSupported ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_PageSizeMatchingSupported(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IPrnVBAPrinters wrapper method implementations
//

#pragma implementation_key(171)
inline VGCore::IPrnVBAPrinterPtr VGCore::IPrnVBAPrinters::GetItem ( long nIndex ) {
    struct IPrnVBAPrinter * _result = 0;
    HRESULT _hr = get_Item(nIndex, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IPrnVBAPrinterPtr(_result, false);
}

#pragma implementation_key(172)
inline long VGCore::IPrnVBAPrinters::GetCount ( ) {
    long _result = 0;
    HRESULT _hr = get_Count(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(173)
inline VGCore::IPrnVBAPrinterPtr VGCore::IPrnVBAPrinters::GetDefault ( ) {
    struct IPrnVBAPrinter * _result = 0;
    HRESULT _hr = get_Default(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IPrnVBAPrinterPtr(_result, false);
}

//
// interface IPrnVBASeparationPlate wrapper method implementations
//

#pragma implementation_key(174)
inline VARIANT_BOOL VGCore::IPrnVBASeparationPlate::GetEnabled ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_Enabled(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(175)
inline void VGCore::IPrnVBASeparationPlate::PutEnabled ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_Enabled(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(176)
inline enum VGCore::PrnPlateType VGCore::IPrnVBASeparationPlate::GetType ( ) {
    enum PrnPlateType _result;
    HRESULT _hr = get_Type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(177)
inline _bstr_t VGCore::IPrnVBASeparationPlate::GetColor ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Color(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(178)
inline double VGCore::IPrnVBASeparationPlate::GetFrequency ( ) {
    double _result = 0;
    HRESULT _hr = get_Frequency(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(179)
inline void VGCore::IPrnVBASeparationPlate::PutFrequency ( double pVal ) {
    HRESULT _hr = put_Frequency(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(180)
inline double VGCore::IPrnVBASeparationPlate::GetAngle ( ) {
    double _result = 0;
    HRESULT _hr = get_Angle(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(181)
inline void VGCore::IPrnVBASeparationPlate::PutAngle ( double pVal ) {
    HRESULT _hr = put_Angle(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(182)
inline VARIANT_BOOL VGCore::IPrnVBASeparationPlate::GetOverprintText ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_OverprintText(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(183)
inline void VGCore::IPrnVBASeparationPlate::PutOverprintText ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_OverprintText(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(184)
inline VARIANT_BOOL VGCore::IPrnVBASeparationPlate::GetOverprintGraphic ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_OverprintGraphic(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(185)
inline void VGCore::IPrnVBASeparationPlate::PutOverprintGraphic ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_OverprintGraphic(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IPrnVBASeparationPlates wrapper method implementations
//

#pragma implementation_key(186)
inline VGCore::IPrnVBASeparationPlatePtr VGCore::IPrnVBASeparationPlates::GetItem ( long Index ) {
    struct IPrnVBASeparationPlate * _result = 0;
    HRESULT _hr = get_Item(Index, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IPrnVBASeparationPlatePtr(_result, false);
}

#pragma implementation_key(187)
inline long VGCore::IPrnVBASeparationPlates::GetCount ( ) {
    long _result = 0;
    HRESULT _hr = get_Count(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface IPrnVBAPrintSeparations wrapper method implementations
//

#pragma implementation_key(188)
inline VARIANT_BOOL VGCore::IPrnVBAPrintSeparations::GetEnabled ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_Enabled(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(189)
inline void VGCore::IPrnVBAPrintSeparations::PutEnabled ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_Enabled(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(190)
inline VARIANT_BOOL VGCore::IPrnVBAPrintSeparations::GetInColor ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_InColor(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(191)
inline void VGCore::IPrnVBAPrintSeparations::PutInColor ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_InColor(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(192)
inline VARIANT_BOOL VGCore::IPrnVBAPrintSeparations::GetHexachrome ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_Hexachrome(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(193)
inline void VGCore::IPrnVBAPrintSeparations::PutHexachrome ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_Hexachrome(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(194)
inline VARIANT_BOOL VGCore::IPrnVBAPrintSeparations::GetSpotToCMYK ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_SpotToCMYK(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(195)
inline void VGCore::IPrnVBAPrintSeparations::PutSpotToCMYK ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_SpotToCMYK(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(196)
inline VARIANT_BOOL VGCore::IPrnVBAPrintSeparations::GetEmptyPlates ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_EmptyPlates(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(197)
inline void VGCore::IPrnVBAPrintSeparations::PutEmptyPlates ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_EmptyPlates(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(198)
inline VARIANT_BOOL VGCore::IPrnVBAPrintSeparations::GetPreserveOverprints ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_PreserveOverprints(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(199)
inline void VGCore::IPrnVBAPrintSeparations::PutPreserveOverprints ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_PreserveOverprints(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(200)
inline VARIANT_BOOL VGCore::IPrnVBAPrintSeparations::GetAlwaysOverprintBlack ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_AlwaysOverprintBlack(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(201)
inline void VGCore::IPrnVBAPrintSeparations::PutAlwaysOverprintBlack ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_AlwaysOverprintBlack(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(202)
inline VARIANT_BOOL VGCore::IPrnVBAPrintSeparations::GetAutoSpreading ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_AutoSpreading(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(203)
inline void VGCore::IPrnVBAPrintSeparations::PutAutoSpreading ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_AutoSpreading(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(204)
inline double VGCore::IPrnVBAPrintSeparations::GetAutoSpreadAmount ( ) {
    double _result = 0;
    HRESULT _hr = get_AutoSpreadAmount(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(205)
inline void VGCore::IPrnVBAPrintSeparations::PutAutoSpreadAmount ( double pVal ) {
    HRESULT _hr = put_AutoSpreadAmount(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(206)
inline VARIANT_BOOL VGCore::IPrnVBAPrintSeparations::GetAutoSpreadFixed ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_AutoSpreadFixed(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(207)
inline void VGCore::IPrnVBAPrintSeparations::PutAutoSpreadFixed ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_AutoSpreadFixed(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(208)
inline double VGCore::IPrnVBAPrintSeparations::GetAutoSpreadTextAbove ( ) {
    double _result = 0;
    HRESULT _hr = get_AutoSpreadTextAbove(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(209)
inline void VGCore::IPrnVBAPrintSeparations::PutAutoSpreadTextAbove ( double pVal ) {
    HRESULT _hr = put_AutoSpreadTextAbove(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(210)
inline VARIANT_BOOL VGCore::IPrnVBAPrintSeparations::GetAdvancedSettings ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_AdvancedSettings(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(211)
inline void VGCore::IPrnVBAPrintSeparations::PutAdvancedSettings ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_AdvancedSettings(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(212)
inline VGCore::IPrnVBASeparationPlatesPtr VGCore::IPrnVBAPrintSeparations::GetPlates ( ) {
    struct IPrnVBASeparationPlates * _result = 0;
    HRESULT _hr = get_Plates(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IPrnVBASeparationPlatesPtr(_result, false);
}

#pragma implementation_key(213)
inline long VGCore::IPrnVBAPrintSeparations::GetResolution ( ) {
    long _result = 0;
    HRESULT _hr = get_Resolution(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(214)
inline void VGCore::IPrnVBAPrintSeparations::PutResolution ( long pVal ) {
    HRESULT _hr = put_Resolution(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(215)
inline _bstr_t VGCore::IPrnVBAPrintSeparations::GetBasicScreen ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_BasicScreen(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(216)
inline void VGCore::IPrnVBAPrintSeparations::PutBasicScreen ( _bstr_t pVal ) {
    HRESULT _hr = put_BasicScreen(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(217)
inline _bstr_t VGCore::IPrnVBAPrintSeparations::GetHalftoneType ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_HalftoneType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(218)
inline void VGCore::IPrnVBAPrintSeparations::PutHalftoneType ( _bstr_t pVal ) {
    HRESULT _hr = put_HalftoneType(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(219)
inline _bstr_t VGCore::IPrnVBAPrintSeparations::GetScreenTechnology ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_ScreenTechnology(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(220)
inline void VGCore::IPrnVBAPrintSeparations::PutScreenTechnology ( _bstr_t pVal ) {
    HRESULT _hr = put_ScreenTechnology(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IPrnVBAPrintPrepress wrapper method implementations
//

#pragma implementation_key(221)
inline VARIANT_BOOL VGCore::IPrnVBAPrintPrepress::GetInvert ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_Invert(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(222)
inline void VGCore::IPrnVBAPrintPrepress::PutInvert ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_Invert(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(223)
inline VARIANT_BOOL VGCore::IPrnVBAPrintPrepress::GetMirror ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_Mirror(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(224)
inline void VGCore::IPrnVBAPrintPrepress::PutMirror ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_Mirror(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(225)
inline VARIANT_BOOL VGCore::IPrnVBAPrintPrepress::GetFileInfo ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_FileInfo(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(226)
inline void VGCore::IPrnVBAPrintPrepress::PutFileInfo ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_FileInfo(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(227)
inline _bstr_t VGCore::IPrnVBAPrintPrepress::GetJobName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_JobName(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(228)
inline void VGCore::IPrnVBAPrintPrepress::PutJobName ( _bstr_t pVal ) {
    HRESULT _hr = put_JobName(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(229)
inline VARIANT_BOOL VGCore::IPrnVBAPrintPrepress::GetPageNumbers ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_PageNumbers(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(230)
inline void VGCore::IPrnVBAPrintPrepress::PutPageNumbers ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_PageNumbers(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(231)
inline VARIANT_BOOL VGCore::IPrnVBAPrintPrepress::GetInfoWithinPage ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_InfoWithinPage(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(232)
inline void VGCore::IPrnVBAPrintPrepress::PutInfoWithinPage ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_InfoWithinPage(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(233)
inline VARIANT_BOOL VGCore::IPrnVBAPrintPrepress::GetCropMarks ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_CropMarks(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(234)
inline void VGCore::IPrnVBAPrintPrepress::PutCropMarks ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_CropMarks(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(235)
inline VARIANT_BOOL VGCore::IPrnVBAPrintPrepress::GetExteriorCropMarks ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_ExteriorCropMarks(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(236)
inline void VGCore::IPrnVBAPrintPrepress::PutExteriorCropMarks ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_ExteriorCropMarks(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(237)
inline VARIANT_BOOL VGCore::IPrnVBAPrintPrepress::GetRegistrationMarks ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_RegistrationMarks(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(238)
inline void VGCore::IPrnVBAPrintPrepress::PutRegistrationMarks ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_RegistrationMarks(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(239)
inline enum VGCore::PrnRegistrationStyle VGCore::IPrnVBAPrintPrepress::GetRegistrationStyle ( ) {
    enum PrnRegistrationStyle _result;
    HRESULT _hr = get_RegistrationStyle(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(240)
inline void VGCore::IPrnVBAPrintPrepress::PutRegistrationStyle ( enum PrnRegistrationStyle pVal ) {
    HRESULT _hr = put_RegistrationStyle(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(241)
inline VARIANT_BOOL VGCore::IPrnVBAPrintPrepress::GetColorCalibrationBar ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_ColorCalibrationBar(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(242)
inline void VGCore::IPrnVBAPrintPrepress::PutColorCalibrationBar ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_ColorCalibrationBar(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(243)
inline VARIANT_BOOL VGCore::IPrnVBAPrintPrepress::GetDensitometerScale ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_DensitometerScale(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(244)
inline void VGCore::IPrnVBAPrintPrepress::PutDensitometerScale ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_DensitometerScale(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(245)
inline long VGCore::IPrnVBAPrintPrepress::GetDensities ( long Index ) {
    long _result = 0;
    HRESULT _hr = get_Densities(Index, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(246)
inline void VGCore::IPrnVBAPrintPrepress::PutDensities ( long Index, long pVal ) {
    HRESULT _hr = put_Densities(Index, pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(247)
inline VARIANT_BOOL VGCore::IPrnVBAPrintPrepress::GetMarksToObjects ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_MarksToObjects(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(248)
inline void VGCore::IPrnVBAPrintPrepress::PutMarksToObjects ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_MarksToObjects(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IPrnVBAPrintPostScript wrapper method implementations
//

#pragma implementation_key(249)
inline enum VGCore::PrnPostScriptLevel VGCore::IPrnVBAPrintPostScript::GetLevel ( ) {
    enum PrnPostScriptLevel _result;
    HRESULT _hr = get_Level(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(250)
inline void VGCore::IPrnVBAPrintPostScript::PutLevel ( enum PrnPostScriptLevel pVal ) {
    HRESULT _hr = put_Level(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(251)
inline VARIANT_BOOL VGCore::IPrnVBAPrintPostScript::GetConformToDSC ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_ConformToDSC(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(252)
inline void VGCore::IPrnVBAPrintPostScript::PutConformToDSC ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_ConformToDSC(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(253)
inline VARIANT_BOOL VGCore::IPrnVBAPrintPostScript::GetJPEGCompression ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_JPEGCompression(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(254)
inline void VGCore::IPrnVBAPrintPostScript::PutJPEGCompression ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_JPEGCompression(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(255)
inline long VGCore::IPrnVBAPrintPostScript::GetJPEGQuality ( ) {
    long _result = 0;
    HRESULT _hr = get_JPEGQuality(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(256)
inline void VGCore::IPrnVBAPrintPostScript::PutJPEGQuality ( long pVal ) {
    HRESULT _hr = put_JPEGQuality(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(257)
inline VARIANT_BOOL VGCore::IPrnVBAPrintPostScript::GetMaintainOPILinks ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_MaintainOPILinks(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(258)
inline void VGCore::IPrnVBAPrintPostScript::PutMaintainOPILinks ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_MaintainOPILinks(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(259)
inline VARIANT_BOOL VGCore::IPrnVBAPrintPostScript::GetResolveDCSLinks ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_ResolveDCSLinks(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(260)
inline void VGCore::IPrnVBAPrintPostScript::PutResolveDCSLinks ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_ResolveDCSLinks(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(261)
inline VARIANT_BOOL VGCore::IPrnVBAPrintPostScript::GetDownloadType1 ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_DownloadType1(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(262)
inline void VGCore::IPrnVBAPrintPostScript::PutDownloadType1 ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_DownloadType1(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(263)
inline VARIANT_BOOL VGCore::IPrnVBAPrintPostScript::GetTrueTypeToType1 ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_TrueTypeToType1(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(264)
inline void VGCore::IPrnVBAPrintPostScript::PutTrueTypeToType1 ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_TrueTypeToType1(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(265)
inline enum VGCore::PrnPDFStartup VGCore::IPrnVBAPrintPostScript::GetPDFStartup ( ) {
    enum PrnPDFStartup _result;
    HRESULT _hr = get_PDFStartup(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(266)
inline void VGCore::IPrnVBAPrintPostScript::PutPDFStartup ( enum PrnPDFStartup pVal ) {
    HRESULT _hr = put_PDFStartup(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(267)
inline VARIANT_BOOL VGCore::IPrnVBAPrintPostScript::GetPDFHyperlinks ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_PDFHyperlinks(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(268)
inline void VGCore::IPrnVBAPrintPostScript::PutPDFHyperlinks ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_PDFHyperlinks(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(269)
inline VARIANT_BOOL VGCore::IPrnVBAPrintPostScript::GetpdfBookmarks ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_pdfBookmarks(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(270)
inline void VGCore::IPrnVBAPrintPostScript::PutpdfBookmarks ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_pdfBookmarks(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(271)
inline long VGCore::IPrnVBAPrintPostScript::GetMaxPointsPerCurve ( ) {
    long _result = 0;
    HRESULT _hr = get_MaxPointsPerCurve(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(272)
inline void VGCore::IPrnVBAPrintPostScript::PutMaxPointsPerCurve ( long pVal ) {
    HRESULT _hr = put_MaxPointsPerCurve(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(273)
inline long VGCore::IPrnVBAPrintPostScript::GetFlatness ( ) {
    long _result = 0;
    HRESULT _hr = get_Flatness(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(274)
inline void VGCore::IPrnVBAPrintPostScript::PutFlatness ( long pVal ) {
    HRESULT _hr = put_Flatness(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(275)
inline VARIANT_BOOL VGCore::IPrnVBAPrintPostScript::GetAutoIncreaseFlatness ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_AutoIncreaseFlatness(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(276)
inline void VGCore::IPrnVBAPrintPostScript::PutAutoIncreaseFlatness ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_AutoIncreaseFlatness(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(277)
inline VARIANT_BOOL VGCore::IPrnVBAPrintPostScript::GetAutoIncreaseFountainSteps ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_AutoIncreaseFountainSteps(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(278)
inline void VGCore::IPrnVBAPrintPostScript::PutAutoIncreaseFountainSteps ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_AutoIncreaseFountainSteps(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(279)
inline VARIANT_BOOL VGCore::IPrnVBAPrintPostScript::GetOptimizeFountainFills ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_OptimizeFountainFills(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(280)
inline void VGCore::IPrnVBAPrintPostScript::PutOptimizeFountainFills ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_OptimizeFountainFills(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(281)
inline long VGCore::IPrnVBAPrintPostScript::GetScreenFrequency ( ) {
    long _result = 0;
    HRESULT _hr = get_ScreenFrequency(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(282)
inline void VGCore::IPrnVBAPrintPostScript::PutScreenFrequency ( long pVal ) {
    HRESULT _hr = put_ScreenFrequency(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IPrnVBATrapLayer wrapper method implementations
//

#pragma implementation_key(283)
inline enum VGCore::PrnPlateType VGCore::IPrnVBATrapLayer::GetType ( ) {
    enum PrnPlateType _result;
    HRESULT _hr = get_Type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(284)
inline _bstr_t VGCore::IPrnVBATrapLayer::GetColor ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Color(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(285)
inline double VGCore::IPrnVBATrapLayer::GetDensity ( ) {
    double _result = 0;
    HRESULT _hr = get_Density(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(286)
inline void VGCore::IPrnVBATrapLayer::PutDensity ( double pVal ) {
    HRESULT _hr = put_Density(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(287)
inline enum VGCore::PrnTrapType VGCore::IPrnVBATrapLayer::GetTrapType ( ) {
    enum PrnTrapType _result;
    HRESULT _hr = get_TrapType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(288)
inline void VGCore::IPrnVBATrapLayer::PutTrapType ( enum PrnTrapType pVal ) {
    HRESULT _hr = put_TrapType(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(289)
inline long VGCore::IPrnVBATrapLayer::GetOrder ( ) {
    long _result = 0;
    HRESULT _hr = get_Order(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(290)
inline void VGCore::IPrnVBATrapLayer::PutOrder ( long pVal ) {
    HRESULT _hr = put_Order(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IPrnVBATrapLayers wrapper method implementations
//

#pragma implementation_key(291)
inline long VGCore::IPrnVBATrapLayers::GetCount ( ) {
    long _result = 0;
    HRESULT _hr = get_Count(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(292)
inline VGCore::IPrnVBATrapLayerPtr VGCore::IPrnVBATrapLayers::GetItem ( long Index ) {
    struct IPrnVBATrapLayer * _result = 0;
    HRESULT _hr = get_Item(Index, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IPrnVBATrapLayerPtr(_result, false);
}

//
// interface IPrnVBAPrintTrapping wrapper method implementations
//

#pragma implementation_key(293)
inline VARIANT_BOOL VGCore::IPrnVBAPrintTrapping::GetEnabled ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_Enabled(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(294)
inline void VGCore::IPrnVBAPrintTrapping::PutEnabled ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_Enabled(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(295)
inline VGCore::IPrnVBATrapLayersPtr VGCore::IPrnVBAPrintTrapping::GetLayers ( ) {
    struct IPrnVBATrapLayers * _result = 0;
    HRESULT _hr = get_Layers(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IPrnVBATrapLayersPtr(_result, false);
}

#pragma implementation_key(296)
inline double VGCore::IPrnVBAPrintTrapping::GetWidth ( ) {
    double _result = 0;
    HRESULT _hr = get_Width(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(297)
inline void VGCore::IPrnVBAPrintTrapping::PutWidth ( double pVal ) {
    HRESULT _hr = put_Width(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(298)
inline double VGCore::IPrnVBAPrintTrapping::GetBlackWidth ( ) {
    double _result = 0;
    HRESULT _hr = get_BlackWidth(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(299)
inline void VGCore::IPrnVBAPrintTrapping::PutBlackWidth ( double pVal ) {
    HRESULT _hr = put_BlackWidth(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(300)
inline long VGCore::IPrnVBAPrintTrapping::GetColorScaling ( ) {
    long _result = 0;
    HRESULT _hr = get_ColorScaling(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(301)
inline void VGCore::IPrnVBAPrintTrapping::PutColorScaling ( long pVal ) {
    HRESULT _hr = put_ColorScaling(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(302)
inline long VGCore::IPrnVBAPrintTrapping::GetStepLimit ( ) {
    long _result = 0;
    HRESULT _hr = get_StepLimit(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(303)
inline void VGCore::IPrnVBAPrintTrapping::PutStepLimit ( long pVal ) {
    HRESULT _hr = put_StepLimit(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(304)
inline long VGCore::IPrnVBAPrintTrapping::GetBlackColorLimit ( ) {
    long _result = 0;
    HRESULT _hr = get_BlackColorLimit(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(305)
inline void VGCore::IPrnVBAPrintTrapping::PutBlackColorLimit ( long pVal ) {
    HRESULT _hr = put_BlackColorLimit(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(306)
inline double VGCore::IPrnVBAPrintTrapping::GetBlackDensityLimit ( ) {
    double _result = 0;
    HRESULT _hr = get_BlackDensityLimit(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(307)
inline void VGCore::IPrnVBAPrintTrapping::PutBlackDensityLimit ( double pVal ) {
    HRESULT _hr = put_BlackDensityLimit(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(308)
inline long VGCore::IPrnVBAPrintTrapping::GetSlidingTrapLimit ( ) {
    long _result = 0;
    HRESULT _hr = get_SlidingTrapLimit(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(309)
inline void VGCore::IPrnVBAPrintTrapping::PutSlidingTrapLimit ( long pVal ) {
    HRESULT _hr = put_SlidingTrapLimit(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(310)
inline enum VGCore::PrnImageTrap VGCore::IPrnVBAPrintTrapping::GetImageTrap ( ) {
    enum PrnImageTrap _result;
    HRESULT _hr = get_ImageTrap(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(311)
inline void VGCore::IPrnVBAPrintTrapping::PutImageTrap ( enum PrnImageTrap pVal ) {
    HRESULT _hr = put_ImageTrap(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(312)
inline VARIANT_BOOL VGCore::IPrnVBAPrintTrapping::GetObjectsToImage ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_ObjectsToImage(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(313)
inline void VGCore::IPrnVBAPrintTrapping::PutObjectsToImage ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_ObjectsToImage(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(314)
inline VARIANT_BOOL VGCore::IPrnVBAPrintTrapping::GetInternalImageTrapping ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_InternalImageTrapping(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(315)
inline void VGCore::IPrnVBAPrintTrapping::PutInternalImageTrapping ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_InternalImageTrapping(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(316)
inline VARIANT_BOOL VGCore::IPrnVBAPrintTrapping::GetTrapMonoBitmaps ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_TrapMonoBitmaps(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(317)
inline void VGCore::IPrnVBAPrintTrapping::PutTrapMonoBitmaps ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_TrapMonoBitmaps(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IPrnVBAPrintOptions wrapper method implementations
//

#pragma implementation_key(318)
inline VARIANT_BOOL VGCore::IPrnVBAPrintOptions::GetUseColorProfile ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_UseColorProfile(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(319)
inline void VGCore::IPrnVBAPrintOptions::PutUseColorProfile ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_UseColorProfile(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(320)
inline VARIANT_BOOL VGCore::IPrnVBAPrintOptions::GetPrintVectors ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_PrintVectors(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(321)
inline void VGCore::IPrnVBAPrintOptions::PutPrintVectors ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_PrintVectors(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(322)
inline VARIANT_BOOL VGCore::IPrnVBAPrintOptions::GetPrintBitmaps ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_PrintBitmaps(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(323)
inline void VGCore::IPrnVBAPrintOptions::PutPrintBitmaps ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_PrintBitmaps(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(324)
inline VARIANT_BOOL VGCore::IPrnVBAPrintOptions::GetPrintText ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_PrintText(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(325)
inline void VGCore::IPrnVBAPrintOptions::PutPrintText ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_PrintText(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(326)
inline VARIANT_BOOL VGCore::IPrnVBAPrintOptions::GetTextInBlack ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_TextInBlack(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(327)
inline void VGCore::IPrnVBAPrintOptions::PutTextInBlack ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_TextInBlack(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(328)
inline enum VGCore::PrnColorMode VGCore::IPrnVBAPrintOptions::GetColorMode ( ) {
    enum PrnColorMode _result;
    HRESULT _hr = get_ColorMode(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(329)
inline void VGCore::IPrnVBAPrintOptions::PutColorMode ( enum PrnColorMode pVal ) {
    HRESULT _hr = put_ColorMode(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(330)
inline VARIANT_BOOL VGCore::IPrnVBAPrintOptions::GetMarksToPage ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_MarksToPage(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(331)
inline void VGCore::IPrnVBAPrintOptions::PutMarksToPage ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_MarksToPage(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(332)
inline enum VGCore::PrnBitmapColorMode VGCore::IPrnVBAPrintOptions::GetBitmapColorMode ( ) {
    enum PrnBitmapColorMode _result;
    HRESULT _hr = get_BitmapColorMode(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(333)
inline void VGCore::IPrnVBAPrintOptions::PutBitmapColorMode ( enum PrnBitmapColorMode pVal ) {
    HRESULT _hr = put_BitmapColorMode(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(334)
inline long VGCore::IPrnVBAPrintOptions::GetFountainSteps ( ) {
    long _result = 0;
    HRESULT _hr = get_FountainSteps(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(335)
inline void VGCore::IPrnVBAPrintOptions::PutFountainSteps ( long pVal ) {
    HRESULT _hr = put_FountainSteps(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(336)
inline VARIANT_BOOL VGCore::IPrnVBAPrintOptions::GetRasterizePage ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_RasterizePage(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(337)
inline void VGCore::IPrnVBAPrintOptions::PutRasterizePage ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_RasterizePage(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(338)
inline long VGCore::IPrnVBAPrintOptions::GetRasterizeResolution ( ) {
    long _result = 0;
    HRESULT _hr = get_RasterizeResolution(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(339)
inline void VGCore::IPrnVBAPrintOptions::PutRasterizeResolution ( long pVal ) {
    HRESULT _hr = put_RasterizeResolution(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(340)
inline VARIANT_BOOL VGCore::IPrnVBAPrintOptions::GetDownsampleColor ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_DownsampleColor(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(341)
inline void VGCore::IPrnVBAPrintOptions::PutDownsampleColor ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_DownsampleColor(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(342)
inline VARIANT_BOOL VGCore::IPrnVBAPrintOptions::GetDownsampleGray ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_DownsampleGray(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(343)
inline void VGCore::IPrnVBAPrintOptions::PutDownsampleGray ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_DownsampleGray(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(344)
inline VARIANT_BOOL VGCore::IPrnVBAPrintOptions::GetDownsampleMono ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_DownsampleMono(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(345)
inline void VGCore::IPrnVBAPrintOptions::PutDownsampleMono ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_DownsampleMono(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(346)
inline long VGCore::IPrnVBAPrintOptions::GetColorResolution ( ) {
    long _result = 0;
    HRESULT _hr = get_ColorResolution(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(347)
inline void VGCore::IPrnVBAPrintOptions::PutColorResolution ( long pVal ) {
    HRESULT _hr = put_ColorResolution(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(348)
inline long VGCore::IPrnVBAPrintOptions::GetGrayResolution ( ) {
    long _result = 0;
    HRESULT _hr = get_GrayResolution(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(349)
inline void VGCore::IPrnVBAPrintOptions::PutGrayResolution ( long pVal ) {
    HRESULT _hr = put_GrayResolution(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(350)
inline long VGCore::IPrnVBAPrintOptions::GetMonoResolution ( ) {
    long _result = 0;
    HRESULT _hr = get_MonoResolution(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(351)
inline void VGCore::IPrnVBAPrintOptions::PutMonoResolution ( long pVal ) {
    HRESULT _hr = put_MonoResolution(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(352)
inline VARIANT_BOOL VGCore::IPrnVBAPrintOptions::GetJobInformation ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_JobInformation(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(353)
inline void VGCore::IPrnVBAPrintOptions::PutJobInformation ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_JobInformation(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(354)
inline VARIANT_BOOL VGCore::IPrnVBAPrintOptions::GetAppInfo ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_AppInfo(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(355)
inline void VGCore::IPrnVBAPrintOptions::PutAppInfo ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_AppInfo(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(356)
inline VARIANT_BOOL VGCore::IPrnVBAPrintOptions::GetDriverInfo ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_DriverInfo(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(357)
inline void VGCore::IPrnVBAPrintOptions::PutDriverInfo ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_DriverInfo(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(358)
inline VARIANT_BOOL VGCore::IPrnVBAPrintOptions::GetPrintJobInfo ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_PrintJobInfo(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(359)
inline void VGCore::IPrnVBAPrintOptions::PutPrintJobInfo ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_PrintJobInfo(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(360)
inline VARIANT_BOOL VGCore::IPrnVBAPrintOptions::GetSepsInfo ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_SepsInfo(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(361)
inline void VGCore::IPrnVBAPrintOptions::PutSepsInfo ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_SepsInfo(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(362)
inline VARIANT_BOOL VGCore::IPrnVBAPrintOptions::GetFontInfo ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_FontInfo(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(363)
inline void VGCore::IPrnVBAPrintOptions::PutFontInfo ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_FontInfo(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(364)
inline VARIANT_BOOL VGCore::IPrnVBAPrintOptions::GetLinkInfo ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_LinkInfo(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(365)
inline void VGCore::IPrnVBAPrintOptions::PutLinkInfo ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_LinkInfo(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(366)
inline VARIANT_BOOL VGCore::IPrnVBAPrintOptions::GetInRIPTrapInfo ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_InRIPTrapInfo(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(367)
inline void VGCore::IPrnVBAPrintOptions::PutInRIPTrapInfo ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_InRIPTrapInfo(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(368)
inline enum VGCore::PrnObjectsColorMode VGCore::IPrnVBAPrintOptions::GetObjectsColorMode ( ) {
    enum PrnObjectsColorMode _result;
    HRESULT _hr = get_ObjectsColorMode(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(369)
inline void VGCore::IPrnVBAPrintOptions::PutObjectsColorMode ( enum PrnObjectsColorMode pVal ) {
    HRESULT _hr = put_ObjectsColorMode(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(370)
inline VARIANT_BOOL VGCore::IPrnVBAPrintOptions::GetPreservePureBlack ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_PreservePureBlack(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(371)
inline void VGCore::IPrnVBAPrintOptions::PutPreservePureBlack ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_PreservePureBlack(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IPrnVBAPrintSettings wrapper method implementations
//

#pragma implementation_key(372)
inline VGCore::IPrnVBAPrinterPtr VGCore::IPrnVBAPrintSettings::GetPrinter ( ) {
    struct IPrnVBAPrinter * _result = 0;
    HRESULT _hr = get_Printer(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IPrnVBAPrinterPtr(_result, false);
}

#pragma implementation_key(373)
inline void VGCore::IPrnVBAPrintSettings::PutRefPrinter ( struct IPrnVBAPrinter * pVal ) {
    HRESULT _hr = putref_Printer(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(374)
inline VARIANT_BOOL VGCore::IPrnVBAPrintSettings::GetUsePPD ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_UsePPD(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(375)
inline void VGCore::IPrnVBAPrintSettings::PutUsePPD ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_UsePPD(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(376)
inline _bstr_t VGCore::IPrnVBAPrintSettings::GetPPDFile ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_PPDFile(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(377)
inline void VGCore::IPrnVBAPrintSettings::PutPPDFile ( _bstr_t pVal ) {
    HRESULT _hr = put_PPDFile(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(378)
inline VARIANT_BOOL VGCore::IPrnVBAPrintSettings::GetPrintToFile ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_PrintToFile(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(379)
inline void VGCore::IPrnVBAPrintSettings::PutPrintToFile ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_PrintToFile(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(380)
inline _bstr_t VGCore::IPrnVBAPrintSettings::GetFileName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_FileName(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(381)
inline void VGCore::IPrnVBAPrintSettings::PutFileName ( _bstr_t pVal ) {
    HRESULT _hr = put_FileName(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(382)
inline VARIANT_BOOL VGCore::IPrnVBAPrintSettings::GetForMac ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_ForMac(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(383)
inline void VGCore::IPrnVBAPrintSettings::PutForMac ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_ForMac(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(384)
inline enum VGCore::PrnFileMode VGCore::IPrnVBAPrintSettings::GetFileMode ( ) {
    enum PrnFileMode _result;
    HRESULT _hr = get_FileMode(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(385)
inline void VGCore::IPrnVBAPrintSettings::PutFileMode ( enum PrnFileMode pVal ) {
    HRESULT _hr = put_FileMode(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(386)
inline enum VGCore::PrnPrintRange VGCore::IPrnVBAPrintSettings::GetPrintRange ( ) {
    enum PrnPrintRange _result;
    HRESULT _hr = get_PrintRange(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(387)
inline void VGCore::IPrnVBAPrintSettings::PutPrintRange ( enum PrnPrintRange pVal ) {
    HRESULT _hr = put_PrintRange(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(388)
inline _bstr_t VGCore::IPrnVBAPrintSettings::GetPageRange ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_PageRange(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(389)
inline void VGCore::IPrnVBAPrintSettings::PutPageRange ( _bstr_t pVal ) {
    HRESULT _hr = put_PageRange(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(390)
inline long VGCore::IPrnVBAPrintSettings::GetCopies ( ) {
    long _result = 0;
    HRESULT _hr = get_Copies(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(391)
inline void VGCore::IPrnVBAPrintSettings::PutCopies ( long pVal ) {
    HRESULT _hr = put_Copies(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(392)
inline VARIANT_BOOL VGCore::IPrnVBAPrintSettings::GetCollate ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_Collate(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(393)
inline void VGCore::IPrnVBAPrintSettings::PutCollate ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_Collate(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(394)
inline VGCore::IPrnVBAPrintSeparationsPtr VGCore::IPrnVBAPrintSettings::GetSeparations ( ) {
    struct IPrnVBAPrintSeparations * _result = 0;
    HRESULT _hr = get_Separations(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IPrnVBAPrintSeparationsPtr(_result, false);
}

#pragma implementation_key(395)
inline VGCore::IPrnVBAPrintPrepressPtr VGCore::IPrnVBAPrintSettings::GetPrepress ( ) {
    struct IPrnVBAPrintPrepress * _result = 0;
    HRESULT _hr = get_Prepress(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IPrnVBAPrintPrepressPtr(_result, false);
}

#pragma implementation_key(396)
inline VGCore::IPrnVBAPrintPostScriptPtr VGCore::IPrnVBAPrintSettings::GetPostScript ( ) {
    struct IPrnVBAPrintPostScript * _result = 0;
    HRESULT _hr = get_PostScript(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IPrnVBAPrintPostScriptPtr(_result, false);
}

#pragma implementation_key(397)
inline VGCore::IPrnVBAPrintTrappingPtr VGCore::IPrnVBAPrintSettings::GetTrapping ( ) {
    struct IPrnVBAPrintTrapping * _result = 0;
    HRESULT _hr = get_Trapping(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IPrnVBAPrintTrappingPtr(_result, false);
}

#pragma implementation_key(398)
inline VGCore::IPrnVBAPrintOptionsPtr VGCore::IPrnVBAPrintSettings::GetOptions ( ) {
    struct IPrnVBAPrintOptions * _result = 0;
    HRESULT _hr = get_Options(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IPrnVBAPrintOptionsPtr(_result, false);
}

#pragma implementation_key(399)
inline HRESULT VGCore::IPrnVBAPrintSettings::Reset ( ) {
    HRESULT _hr = raw_Reset();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(400)
inline VARIANT_BOOL VGCore::IPrnVBAPrintSettings::Load ( _bstr_t FileName ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_Load(FileName, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(401)
inline VARIANT_BOOL VGCore::IPrnVBAPrintSettings::Save ( _bstr_t FileName ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_Save(FileName, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(402)
inline VARIANT_BOOL VGCore::IPrnVBAPrintSettings::ShowDialog ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_ShowDialog(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(403)
inline HRESULT VGCore::IPrnVBAPrintSettings::SelectPrinter ( _bstr_t Name ) {
    HRESULT _hr = raw_SelectPrinter(Name);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(404)
inline enum VGCore::PrnPageSet VGCore::IPrnVBAPrintSettings::GetPageSet ( ) {
    enum PrnPageSet _result;
    HRESULT _hr = get_PageSet(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(405)
inline void VGCore::IPrnVBAPrintSettings::PutPageSet ( enum PrnPageSet pVal ) {
    HRESULT _hr = put_PageSet(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(406)
inline enum VGCore::PrnPaperOrientation VGCore::IPrnVBAPrintSettings::GetPaperOrientation ( ) {
    enum PrnPaperOrientation _result;
    HRESULT _hr = get_PaperOrientation(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(407)
inline void VGCore::IPrnVBAPrintSettings::PutPaperOrientation ( enum PrnPaperOrientation pVal ) {
    HRESULT _hr = put_PaperOrientation(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(408)
inline enum VGCore::PrnPaperSize VGCore::IPrnVBAPrintSettings::GetPaperSize ( ) {
    enum PrnPaperSize _result;
    HRESULT _hr = get_PaperSize(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(409)
inline void VGCore::IPrnVBAPrintSettings::PutPaperSize ( enum PrnPaperSize pVal ) {
    HRESULT _hr = put_PaperSize(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(410)
inline HRESULT VGCore::IPrnVBAPrintSettings::SetPaperSize ( enum PrnPaperSize PaperSize, enum PrnPaperOrientation Orientation ) {
    HRESULT _hr = raw_SetPaperSize(PaperSize, Orientation);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(411)
inline double VGCore::IPrnVBAPrintSettings::GetPaperWidth ( ) {
    double _result = 0;
    HRESULT _hr = get_PaperWidth(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(412)
inline double VGCore::IPrnVBAPrintSettings::GetPaperHeight ( ) {
    double _result = 0;
    HRESULT _hr = get_PaperHeight(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(413)
inline HRESULT VGCore::IPrnVBAPrintSettings::SetCustomPaperSize ( double Width, double Height, enum PrnPaperOrientation Orientation ) {
    HRESULT _hr = raw_SetCustomPaperSize(Width, Height, Orientation);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(414)
inline VGCore::IPrnVBAPrintLayoutPtr VGCore::IPrnVBAPrintSettings::GetLayout ( ) {
    struct IPrnVBAPrintLayout * _result = 0;
    HRESULT _hr = get_Layout(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IPrnVBAPrintLayoutPtr(_result, false);
}

#pragma implementation_key(415)
inline HRESULT VGCore::IPrnVBAPrintSettings::PrintOut ( ) {
    HRESULT _hr = raw_PrintOut();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(416)
inline HRESULT VGCore::IPrnVBAPrintSettings::PrintColorProof ( IDispatch * ProofSettings ) {
    HRESULT _hr = raw_PrintColorProof(ProofSettings);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(417)
inline enum VGCore::PrnPageMatchingMode VGCore::IPrnVBAPrintSettings::GetPageMatchingMode ( ) {
    enum PrnPageMatchingMode _result;
    HRESULT _hr = get_PageMatchingMode(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(418)
inline void VGCore::IPrnVBAPrintSettings::PutPageMatchingMode ( enum PrnPageMatchingMode pVal ) {
    HRESULT _hr = put_PageMatchingMode(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IPrnVBAPrintDocument wrapper method implementations
//

#pragma implementation_key(419)
inline HRESULT VGCore::IPrnVBAPrintDocument::_GetPrintDocument ( INT_PTR * pDoc ) {
    HRESULT _hr = raw__GetPrintDocument(pDoc);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface IPrnVBAPrintDocuments wrapper method implementations
//

#pragma implementation_key(420)
inline VGCore::IPrnVBAPrintDocumentPtr VGCore::IPrnVBAPrintDocuments::GetItem ( long Index ) {
    struct IPrnVBAPrintDocument * _result = 0;
    HRESULT _hr = get_Item(Index, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IPrnVBAPrintDocumentPtr(_result, false);
}

#pragma implementation_key(421)
inline long VGCore::IPrnVBAPrintDocuments::GetCount ( ) {
    long _result = 0;
    HRESULT _hr = get_Count(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface IPrnVBAPrintPage wrapper method implementations
//

#pragma implementation_key(422)
inline HRESULT VGCore::IPrnVBAPrintPage::_GetPrintDocument ( INT_PTR * pDoc ) {
    HRESULT _hr = raw__GetPrintDocument(pDoc);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(423)
inline HRESULT VGCore::IPrnVBAPrintPage::_GetPrintPage ( long * pPage ) {
    HRESULT _hr = raw__GetPrintPage(pPage);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface IPrnVBAPrintPages wrapper method implementations
//

#pragma implementation_key(424)
inline VGCore::IPrnVBAPrintPagePtr VGCore::IPrnVBAPrintPages::GetItem ( long Index ) {
    struct IPrnVBAPrintPage * _result = 0;
    HRESULT _hr = get_Item(Index, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IPrnVBAPrintPagePtr(_result, false);
}

#pragma implementation_key(425)
inline long VGCore::IPrnVBAPrintPages::GetCount ( ) {
    long _result = 0;
    HRESULT _hr = get_Count(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface IPrnVBAPrintJob wrapper method implementations
//

#pragma implementation_key(426)
inline VGCore::IPrnVBAPrintSettingsPtr VGCore::IPrnVBAPrintJob::GetSettings ( ) {
    struct IPrnVBAPrintSettings * _result = 0;
    HRESULT _hr = get_Settings(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IPrnVBAPrintSettingsPtr(_result, false);
}

#pragma implementation_key(427)
inline VGCore::IPrnVBAPrintDocumentsPtr VGCore::IPrnVBAPrintJob::GetDocuments ( ) {
    struct IPrnVBAPrintDocuments * _result = 0;
    HRESULT _hr = get_Documents(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IPrnVBAPrintDocumentsPtr(_result, false);
}

#pragma implementation_key(428)
inline VGCore::IPrnVBAPrintPagesPtr VGCore::IPrnVBAPrintJob::GetPages ( ) {
    struct IPrnVBAPrintPages * _result = 0;
    HRESULT _hr = get_Pages(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IPrnVBAPrintPagesPtr(_result, false);
}

#pragma implementation_key(429)
inline HRESULT VGCore::IPrnVBAPrintJob::Clear ( ) {
    HRESULT _hr = raw_Clear();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(430)
inline HRESULT VGCore::IPrnVBAPrintJob::PrintOut ( ) {
    HRESULT _hr = raw_PrintOut();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(431)
inline HRESULT VGCore::IPrnVBAPrintJob::AddDocument ( struct IPrnVBAPrintDocument * Document, _bstr_t PageRange ) {
    HRESULT _hr = raw_AddDocument(Document, PageRange);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(432)
inline HRESULT VGCore::IPrnVBAPrintJob::AddPage ( struct IPrnVBAPrintPage * Page ) {
    HRESULT _hr = raw_AddPage(Page);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface IPDFVBASettings wrapper method implementations
//

#pragma implementation_key(433)
inline HRESULT VGCore::IPDFVBASettings::Reset ( ) {
    HRESULT _hr = raw_Reset();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(434)
inline VARIANT_BOOL VGCore::IPDFVBASettings::Load ( _bstr_t SettingName ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_Load(SettingName, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(435)
inline VARIANT_BOOL VGCore::IPDFVBASettings::Save ( _bstr_t SettingName ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_Save(SettingName, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(436)
inline VARIANT_BOOL VGCore::IPDFVBASettings::ShowDialog ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_ShowDialog(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(437)
inline HRESULT VGCore::IPDFVBASettings::PublishToPDF ( _bstr_t FileName ) {
    HRESULT _hr = raw_PublishToPDF(FileName);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(438)
inline void VGCore::IPDFVBASettings::PutPublishRange ( enum pdfExportRange pExportRange ) {
    HRESULT _hr = put_PublishRange(pExportRange);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(439)
inline enum VGCore::pdfExportRange VGCore::IPDFVBASettings::GetPublishRange ( ) {
    enum pdfExportRange _result;
    HRESULT _hr = get_PublishRange(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(440)
inline void VGCore::IPDFVBASettings::PutPageRange ( _bstr_t pszExportPagesRange ) {
    HRESULT _hr = put_PageRange(pszExportPagesRange);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(441)
inline _bstr_t VGCore::IPDFVBASettings::GetPageRange ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_PageRange(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(442)
inline void VGCore::IPDFVBASettings::PutAuthor ( _bstr_t pszAuthor ) {
    HRESULT _hr = put_Author(pszAuthor);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(443)
inline _bstr_t VGCore::IPDFVBASettings::GetAuthor ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Author(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(444)
inline void VGCore::IPDFVBASettings::PutSubject ( _bstr_t pszSubject ) {
    HRESULT _hr = put_Subject(pszSubject);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(445)
inline _bstr_t VGCore::IPDFVBASettings::GetSubject ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Subject(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(446)
inline void VGCore::IPDFVBASettings::PutKeywords ( _bstr_t pszKeywords ) {
    HRESULT _hr = put_Keywords(pszKeywords);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(447)
inline _bstr_t VGCore::IPDFVBASettings::GetKeywords ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Keywords(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(448)
inline void VGCore::IPDFVBASettings::PutBitmapCompression ( enum pdfBitmapCompressionType pBitmapCompressionType ) {
    HRESULT _hr = put_BitmapCompression(pBitmapCompressionType);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(449)
inline enum VGCore::pdfBitmapCompressionType VGCore::IPDFVBASettings::GetBitmapCompression ( ) {
    enum pdfBitmapCompressionType _result;
    HRESULT _hr = get_BitmapCompression(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(450)
inline void VGCore::IPDFVBASettings::PutJPEGQualityFactor ( int pnQuality ) {
    HRESULT _hr = put_JPEGQualityFactor(pnQuality);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(451)
inline int VGCore::IPDFVBASettings::GetJPEGQualityFactor ( ) {
    int _result = 0;
    HRESULT _hr = get_JPEGQualityFactor(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(452)
inline void VGCore::IPDFVBASettings::PutTextAsCurves ( VARIANT_BOOL pbTextAsCurves ) {
    HRESULT _hr = put_TextAsCurves(pbTextAsCurves);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(453)
inline VARIANT_BOOL VGCore::IPDFVBASettings::GetTextAsCurves ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_TextAsCurves(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(454)
inline void VGCore::IPDFVBASettings::PutEmbedFonts ( VARIANT_BOOL pbEmbedFonts ) {
    HRESULT _hr = put_EmbedFonts(pbEmbedFonts);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(455)
inline VARIANT_BOOL VGCore::IPDFVBASettings::GetEmbedFonts ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_EmbedFonts(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(456)
inline void VGCore::IPDFVBASettings::PutEmbedBaseFonts ( VARIANT_BOOL pbEmbedBaseFonts ) {
    HRESULT _hr = put_EmbedBaseFonts(pbEmbedBaseFonts);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(457)
inline VARIANT_BOOL VGCore::IPDFVBASettings::GetEmbedBaseFonts ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_EmbedBaseFonts(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(458)
inline void VGCore::IPDFVBASettings::PutTrueTypeToType1 ( VARIANT_BOOL pbTrueTypeToType1 ) {
    HRESULT _hr = put_TrueTypeToType1(pbTrueTypeToType1);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(459)
inline VARIANT_BOOL VGCore::IPDFVBASettings::GetTrueTypeToType1 ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_TrueTypeToType1(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(460)
inline void VGCore::IPDFVBASettings::PutSubsetFonts ( VARIANT_BOOL pbSubsetType1Fonts ) {
    HRESULT _hr = put_SubsetFonts(pbSubsetType1Fonts);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(461)
inline VARIANT_BOOL VGCore::IPDFVBASettings::GetSubsetFonts ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_SubsetFonts(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(462)
inline void VGCore::IPDFVBASettings::PutSubsetPct ( long pnLevel ) {
    HRESULT _hr = put_SubsetPct(pnLevel);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(463)
inline long VGCore::IPDFVBASettings::GetSubsetPct ( ) {
    long _result = 0;
    HRESULT _hr = get_SubsetPct(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(464)
inline void VGCore::IPDFVBASettings::PutCompressText ( VARIANT_BOOL pbCompressText ) {
    HRESULT _hr = put_CompressText(pbCompressText);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(465)
inline VARIANT_BOOL VGCore::IPDFVBASettings::GetCompressText ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_CompressText(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(466)
inline void VGCore::IPDFVBASettings::PutEncoding ( enum pdfEncodingType pEncoding ) {
    HRESULT _hr = put_Encoding(pEncoding);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(467)
inline enum VGCore::pdfEncodingType VGCore::IPDFVBASettings::GetEncoding ( ) {
    enum pdfEncodingType _result;
    HRESULT _hr = get_Encoding(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(468)
inline void VGCore::IPDFVBASettings::PutDownsampleColor ( VARIANT_BOOL pbDownsample ) {
    HRESULT _hr = put_DownsampleColor(pbDownsample);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(469)
inline VARIANT_BOOL VGCore::IPDFVBASettings::GetDownsampleColor ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_DownsampleColor(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(470)
inline void VGCore::IPDFVBASettings::PutDownsampleGray ( VARIANT_BOOL pbDownsample ) {
    HRESULT _hr = put_DownsampleGray(pbDownsample);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(471)
inline VARIANT_BOOL VGCore::IPDFVBASettings::GetDownsampleGray ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_DownsampleGray(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(472)
inline void VGCore::IPDFVBASettings::PutDownsampleMono ( VARIANT_BOOL pbDownsample ) {
    HRESULT _hr = put_DownsampleMono(pbDownsample);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(473)
inline VARIANT_BOOL VGCore::IPDFVBASettings::GetDownsampleMono ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_DownsampleMono(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(474)
inline void VGCore::IPDFVBASettings::PutColorResolution ( long pnDownsampleResolution ) {
    HRESULT _hr = put_ColorResolution(pnDownsampleResolution);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(475)
inline long VGCore::IPDFVBASettings::GetColorResolution ( ) {
    long _result = 0;
    HRESULT _hr = get_ColorResolution(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(476)
inline void VGCore::IPDFVBASettings::PutMonoResolution ( long pnDownsampleResolution ) {
    HRESULT _hr = put_MonoResolution(pnDownsampleResolution);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(477)
inline long VGCore::IPDFVBASettings::GetMonoResolution ( ) {
    long _result = 0;
    HRESULT _hr = get_MonoResolution(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(478)
inline void VGCore::IPDFVBASettings::PutGrayResolution ( long pnDownsampleResolution ) {
    HRESULT _hr = put_GrayResolution(pnDownsampleResolution);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(479)
inline long VGCore::IPDFVBASettings::GetGrayResolution ( ) {
    long _result = 0;
    HRESULT _hr = get_GrayResolution(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(480)
inline void VGCore::IPDFVBASettings::PutHyperlinks ( VARIANT_BOOL pbIncludeHyperlinks ) {
    HRESULT _hr = put_Hyperlinks(pbIncludeHyperlinks);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(481)
inline VARIANT_BOOL VGCore::IPDFVBASettings::GetHyperlinks ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_Hyperlinks(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(482)
inline void VGCore::IPDFVBASettings::PutBookmarks ( VARIANT_BOOL pbGenerateBookmarks ) {
    HRESULT _hr = put_Bookmarks(pbGenerateBookmarks);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(483)
inline VARIANT_BOOL VGCore::IPDFVBASettings::GetBookmarks ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_Bookmarks(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(484)
inline void VGCore::IPDFVBASettings::PutThumbnails ( VARIANT_BOOL pbGenerateThumbnails ) {
    HRESULT _hr = put_Thumbnails(pbGenerateThumbnails);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(485)
inline VARIANT_BOOL VGCore::IPDFVBASettings::GetThumbnails ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_Thumbnails(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(486)
inline void VGCore::IPDFVBASettings::PutStartup ( enum pdfDisplayOnStart pDisplayOnStart ) {
    HRESULT _hr = put_Startup(pDisplayOnStart);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(487)
inline enum VGCore::pdfDisplayOnStart VGCore::IPDFVBASettings::GetStartup ( ) {
    enum pdfDisplayOnStart _result;
    HRESULT _hr = get_Startup(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(488)
inline void VGCore::IPDFVBASettings::PutComplexFillsAsBitmaps ( VARIANT_BOOL pbComplexFillsAsBitmaps ) {
    HRESULT _hr = put_ComplexFillsAsBitmaps(pbComplexFillsAsBitmaps);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(489)
inline VARIANT_BOOL VGCore::IPDFVBASettings::GetComplexFillsAsBitmaps ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_ComplexFillsAsBitmaps(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(490)
inline void VGCore::IPDFVBASettings::PutOverprints ( VARIANT_BOOL pbPreserveOverprints ) {
    HRESULT _hr = put_Overprints(pbPreserveOverprints);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(491)
inline VARIANT_BOOL VGCore::IPDFVBASettings::GetOverprints ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_Overprints(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(492)
inline void VGCore::IPDFVBASettings::PutHalftones ( VARIANT_BOOL pbPreserveHalftones ) {
    HRESULT _hr = put_Halftones(pbPreserveHalftones);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(493)
inline VARIANT_BOOL VGCore::IPDFVBASettings::GetHalftones ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_Halftones(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(494)
inline void VGCore::IPDFVBASettings::PutSpotColors ( VARIANT_BOOL pbPreserveSpotColors ) {
    HRESULT _hr = put_SpotColors(pbPreserveSpotColors);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(495)
inline VARIANT_BOOL VGCore::IPDFVBASettings::GetSpotColors ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_SpotColors(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(496)
inline void VGCore::IPDFVBASettings::PutMaintainOPILinks ( VARIANT_BOOL pbMaintainOPILinks ) {
    HRESULT _hr = put_MaintainOPILinks(pbMaintainOPILinks);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(497)
inline VARIANT_BOOL VGCore::IPDFVBASettings::GetMaintainOPILinks ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_MaintainOPILinks(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(498)
inline void VGCore::IPDFVBASettings::PutFountainSteps ( long pnFountainSteps ) {
    HRESULT _hr = put_FountainSteps(pnFountainSteps);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(499)
inline long VGCore::IPDFVBASettings::GetFountainSteps ( ) {
    long _result = 0;
    HRESULT _hr = get_FountainSteps(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(500)
inline void VGCore::IPDFVBASettings::PutEPSAs ( enum pdfEPSAs peEPSAs ) {
    HRESULT _hr = put_EPSAs(peEPSAs);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(501)
inline enum VGCore::pdfEPSAs VGCore::IPDFVBASettings::GetEPSAs ( ) {
    enum pdfEPSAs _result;
    HRESULT _hr = get_EPSAs(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(502)
inline void VGCore::IPDFVBASettings::PutpdfVersion ( enum pdfVersion pePDFVersion ) {
    HRESULT _hr = put_pdfVersion(pePDFVersion);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(503)
inline enum VGCore::pdfVersion VGCore::IPDFVBASettings::GetpdfVersion ( ) {
    enum pdfVersion _result;
    HRESULT _hr = get_pdfVersion(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(504)
inline void VGCore::IPDFVBASettings::PutIncludeBleed ( VARIANT_BOOL pbIncludeBleed ) {
    HRESULT _hr = put_IncludeBleed(pbIncludeBleed);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(505)
inline VARIANT_BOOL VGCore::IPDFVBASettings::GetIncludeBleed ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IncludeBleed(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(506)
inline void VGCore::IPDFVBASettings::PutBleed ( int pnBleed ) {
    HRESULT _hr = put_Bleed(pnBleed);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(507)
inline int VGCore::IPDFVBASettings::GetBleed ( ) {
    int _result = 0;
    HRESULT _hr = get_Bleed(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(508)
inline void VGCore::IPDFVBASettings::PutLinearize ( VARIANT_BOOL pbLinearize ) {
    HRESULT _hr = put_Linearize(pbLinearize);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(509)
inline VARIANT_BOOL VGCore::IPDFVBASettings::GetLinearize ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_Linearize(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(510)
inline void VGCore::IPDFVBASettings::PutCropMarks ( VARIANT_BOOL pbCropMarks ) {
    HRESULT _hr = put_CropMarks(pbCropMarks);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(511)
inline VARIANT_BOOL VGCore::IPDFVBASettings::GetCropMarks ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_CropMarks(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(512)
inline void VGCore::IPDFVBASettings::PutRegistrationMarks ( VARIANT_BOOL pbRegistrationMarks ) {
    HRESULT _hr = put_RegistrationMarks(pbRegistrationMarks);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(513)
inline VARIANT_BOOL VGCore::IPDFVBASettings::GetRegistrationMarks ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_RegistrationMarks(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(514)
inline void VGCore::IPDFVBASettings::PutDensitometerScales ( VARIANT_BOOL pbDensitometerScales ) {
    HRESULT _hr = put_DensitometerScales(pbDensitometerScales);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(515)
inline VARIANT_BOOL VGCore::IPDFVBASettings::GetDensitometerScales ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_DensitometerScales(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(516)
inline void VGCore::IPDFVBASettings::PutFileInformation ( VARIANT_BOOL pbFileInformation ) {
    HRESULT _hr = put_FileInformation(pbFileInformation);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(517)
inline VARIANT_BOOL VGCore::IPDFVBASettings::GetFileInformation ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_FileInformation(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(518)
inline void VGCore::IPDFVBASettings::PutColorMode ( enum pdfColorMode peColorSet ) {
    HRESULT _hr = put_ColorMode(peColorSet);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(519)
inline enum VGCore::pdfColorMode VGCore::IPDFVBASettings::GetColorMode ( ) {
    enum pdfColorMode _result;
    HRESULT _hr = get_ColorMode(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(520)
inline void VGCore::IPDFVBASettings::PutUseColorProfile ( VARIANT_BOOL pbUseColorProfile ) {
    HRESULT _hr = put_UseColorProfile(pbUseColorProfile);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(521)
inline VARIANT_BOOL VGCore::IPDFVBASettings::GetUseColorProfile ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_UseColorProfile(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(522)
inline void VGCore::IPDFVBASettings::PutColorProfile ( enum pdfColorProfile peColorProfile ) {
    HRESULT _hr = put_ColorProfile(peColorProfile);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(523)
inline enum VGCore::pdfColorProfile VGCore::IPDFVBASettings::GetColorProfile ( ) {
    enum pdfColorProfile _result;
    HRESULT _hr = get_ColorProfile(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(524)
inline void VGCore::IPDFVBASettings::PutEmbedFilename ( _bstr_t pszEmbedFilename ) {
    HRESULT _hr = put_EmbedFilename(pszEmbedFilename);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(525)
inline _bstr_t VGCore::IPDFVBASettings::GetEmbedFilename ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_EmbedFilename(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(526)
inline void VGCore::IPDFVBASettings::PutEmbedFile ( VARIANT_BOOL pbEmbedFile ) {
    HRESULT _hr = put_EmbedFile(pbEmbedFile);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(527)
inline VARIANT_BOOL VGCore::IPDFVBASettings::GetEmbedFile ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_EmbedFile(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(528)
inline void VGCore::IPDFVBASettings::PutJP2QualityFactor ( int pnQuality ) {
    HRESULT _hr = put_JP2QualityFactor(pnQuality);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(529)
inline int VGCore::IPDFVBASettings::GetJP2QualityFactor ( ) {
    int _result = 0;
    HRESULT _hr = get_JP2QualityFactor(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(530)
inline void VGCore::IPDFVBASettings::PutTextExportMode ( enum pdfTextExportMode pExportMode ) {
    HRESULT _hr = put_TextExportMode(pExportMode);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(531)
inline enum VGCore::pdfTextExportMode VGCore::IPDFVBASettings::GetTextExportMode ( ) {
    enum pdfTextExportMode _result;
    HRESULT _hr = get_TextExportMode(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(532)
inline void VGCore::IPDFVBASettings::PutPrintPermissions ( enum pdfPrintPermissions pPrintPermission ) {
    HRESULT _hr = put_PrintPermissions(pPrintPermission);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(533)
inline enum VGCore::pdfPrintPermissions VGCore::IPDFVBASettings::GetPrintPermissions ( ) {
    enum pdfPrintPermissions _result;
    HRESULT _hr = get_PrintPermissions(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(534)
inline void VGCore::IPDFVBASettings::PutEditPermissions ( enum pdfEditPermissions pEditPermission ) {
    HRESULT _hr = put_EditPermissions(pEditPermission);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(535)
inline enum VGCore::pdfEditPermissions VGCore::IPDFVBASettings::GetEditPermissions ( ) {
    enum pdfEditPermissions _result;
    HRESULT _hr = get_EditPermissions(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(536)
inline void VGCore::IPDFVBASettings::PutContentCopyingAllowed ( VARIANT_BOOL pbEnable ) {
    HRESULT _hr = put_ContentCopyingAllowed(pbEnable);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(537)
inline VARIANT_BOOL VGCore::IPDFVBASettings::GetContentCopyingAllowed ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_ContentCopyingAllowed(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(538)
inline void VGCore::IPDFVBASettings::PutOpenPassword ( _bstr_t pszOpenPassword ) {
    HRESULT _hr = put_OpenPassword(pszOpenPassword);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(539)
inline _bstr_t VGCore::IPDFVBASettings::GetOpenPassword ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_OpenPassword(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(540)
inline void VGCore::IPDFVBASettings::PutPermissionPassword ( _bstr_t pszPermissionPassword ) {
    HRESULT _hr = put_PermissionPassword(pszPermissionPassword);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(541)
inline _bstr_t VGCore::IPDFVBASettings::GetPermissionPassword ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_PermissionPassword(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(542)
inline void VGCore::IPDFVBASettings::PutConvertSpotColors ( VARIANT_BOOL pbConvertSpotColors ) {
    HRESULT _hr = put_ConvertSpotColors(pbConvertSpotColors);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(543)
inline VARIANT_BOOL VGCore::IPDFVBASettings::GetConvertSpotColors ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_ConvertSpotColors(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(544)
inline void VGCore::IPDFVBASettings::PutEncryptType ( enum pdfEncryptionType peEncryptType ) {
    HRESULT _hr = put_EncryptType(peEncryptType);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(545)
inline enum VGCore::pdfEncryptionType VGCore::IPDFVBASettings::GetEncryptType ( ) {
    enum pdfEncryptionType _result;
    HRESULT _hr = get_EncryptType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(546)
inline void VGCore::IPDFVBASettings::PutOutputSpotColorsAs ( enum pdfSpotType pnConvertSpotColorsTo ) {
    HRESULT _hr = put_OutputSpotColorsAs(pnConvertSpotColorsTo);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(547)
inline enum VGCore::pdfSpotType VGCore::IPDFVBASettings::GetOutputSpotColorsAs ( ) {
    enum pdfSpotType _result;
    HRESULT _hr = get_OutputSpotColorsAs(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(548)
inline void VGCore::IPDFVBASettings::PutOverprintBlackLimit ( int pnOverprintBlackLimit ) {
    HRESULT _hr = put_OverprintBlackLimit(pnOverprintBlackLimit);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(549)
inline int VGCore::IPDFVBASettings::GetOverprintBlackLimit ( ) {
    int _result = 0;
    HRESULT _hr = get_OverprintBlackLimit(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(550)
inline void VGCore::IPDFVBASettings::PutProtectedTextAsCurves ( VARIANT_BOOL pbProtectedTextAsCurves ) {
    HRESULT _hr = put_ProtectedTextAsCurves(pbProtectedTextAsCurves);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(551)
inline VARIANT_BOOL VGCore::IPDFVBASettings::GetProtectedTextAsCurves ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_ProtectedTextAsCurves(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface IVGRectangle wrapper method implementations
//

#pragma implementation_key(552)
inline long VGCore::IVGRectangle::GetCornerUpperLeft ( ) {
    long _result = 0;
    HRESULT _hr = get_CornerUpperLeft(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(553)
inline void VGCore::IVGRectangle::PutCornerUpperLeft ( long pVal ) {
    HRESULT _hr = put_CornerUpperLeft(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(554)
inline long VGCore::IVGRectangle::GetCornerUpperRight ( ) {
    long _result = 0;
    HRESULT _hr = get_CornerUpperRight(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(555)
inline void VGCore::IVGRectangle::PutCornerUpperRight ( long pVal ) {
    HRESULT _hr = put_CornerUpperRight(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(556)
inline long VGCore::IVGRectangle::GetCornerLowerLeft ( ) {
    long _result = 0;
    HRESULT _hr = get_CornerLowerLeft(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(557)
inline void VGCore::IVGRectangle::PutCornerLowerLeft ( long pVal ) {
    HRESULT _hr = put_CornerLowerLeft(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(558)
inline long VGCore::IVGRectangle::GetCornerLowerRight ( ) {
    long _result = 0;
    HRESULT _hr = get_CornerLowerRight(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(559)
inline void VGCore::IVGRectangle::PutCornerLowerRight ( long pVal ) {
    HRESULT _hr = put_CornerLowerRight(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(560)
inline VARIANT_BOOL VGCore::IVGRectangle::GetEqualCorners ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_EqualCorners(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(561)
inline double VGCore::IVGRectangle::GetMaxRadius ( ) {
    double _result = 0;
    HRESULT _hr = get_MaxRadius(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(562)
inline HRESULT VGCore::IVGRectangle::SetRoundness ( long Roundness ) {
    HRESULT _hr = raw_SetRoundness(Roundness);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(563)
inline HRESULT VGCore::IVGRectangle::SetRadius ( double Radius ) {
    HRESULT _hr = raw_SetRadius(Radius);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(564)
inline double VGCore::IVGRectangle::GetRadiusUpperLeft ( ) {
    double _result = 0;
    HRESULT _hr = get_RadiusUpperLeft(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(565)
inline void VGCore::IVGRectangle::PutRadiusUpperLeft ( double pVal ) {
    HRESULT _hr = put_RadiusUpperLeft(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(566)
inline double VGCore::IVGRectangle::GetRadiusUpperRight ( ) {
    double _result = 0;
    HRESULT _hr = get_RadiusUpperRight(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(567)
inline void VGCore::IVGRectangle::PutRadiusUpperRight ( double pVal ) {
    HRESULT _hr = put_RadiusUpperRight(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(568)
inline double VGCore::IVGRectangle::GetRadiusLowerLeft ( ) {
    double _result = 0;
    HRESULT _hr = get_RadiusLowerLeft(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(569)
inline void VGCore::IVGRectangle::PutRadiusLowerLeft ( double pVal ) {
    HRESULT _hr = put_RadiusLowerLeft(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(570)
inline double VGCore::IVGRectangle::GetRadiusLowerRight ( ) {
    double _result = 0;
    HRESULT _hr = get_RadiusLowerRight(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(571)
inline void VGCore::IVGRectangle::PutRadiusLowerRight ( double pVal ) {
    HRESULT _hr = put_RadiusLowerRight(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(572)
inline enum VGCore::cdrCornerType VGCore::IVGRectangle::GetCornerType ( ) {
    enum cdrCornerType _result;
    HRESULT _hr = get_CornerType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(573)
inline void VGCore::IVGRectangle::PutCornerType ( enum cdrCornerType pVal ) {
    HRESULT _hr = put_CornerType(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(574)
inline VARIANT_BOOL VGCore::IVGRectangle::GetRelativeCornerScaling ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_RelativeCornerScaling(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(575)
inline void VGCore::IVGRectangle::PutRelativeCornerScaling ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_RelativeCornerScaling(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IVGEllipse wrapper method implementations
//

#pragma implementation_key(576)
inline enum VGCore::cdrEllipseType VGCore::IVGEllipse::GetType ( ) {
    enum cdrEllipseType _result;
    HRESULT _hr = get_Type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(577)
inline void VGCore::IVGEllipse::PutType ( enum cdrEllipseType pVal ) {
    HRESULT _hr = put_Type(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(578)
inline double VGCore::IVGEllipse::GetStartAngle ( ) {
    double _result = 0;
    HRESULT _hr = get_StartAngle(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(579)
inline void VGCore::IVGEllipse::PutStartAngle ( double pVal ) {
    HRESULT _hr = put_StartAngle(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(580)
inline double VGCore::IVGEllipse::GetEndAngle ( ) {
    double _result = 0;
    HRESULT _hr = get_EndAngle(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(581)
inline void VGCore::IVGEllipse::PutEndAngle ( double pVal ) {
    HRESULT _hr = put_EndAngle(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(582)
inline VARIANT_BOOL VGCore::IVGEllipse::GetClockwise ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_Clockwise(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(583)
inline void VGCore::IVGEllipse::PutClockwise ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_Clockwise(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(584)
inline double VGCore::IVGEllipse::GetCenterX ( ) {
    double _result = 0;
    HRESULT _hr = get_CenterX(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(585)
inline void VGCore::IVGEllipse::PutCenterX ( double pVal ) {
    HRESULT _hr = put_CenterX(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(586)
inline double VGCore::IVGEllipse::GetCenterY ( ) {
    double _result = 0;
    HRESULT _hr = get_CenterY(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(587)
inline void VGCore::IVGEllipse::PutCenterY ( double pVal ) {
    HRESULT _hr = put_CenterY(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(588)
inline double VGCore::IVGEllipse::GetHRadius ( ) {
    double _result = 0;
    HRESULT _hr = get_HRadius(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(589)
inline void VGCore::IVGEllipse::PutHRadius ( double pVal ) {
    HRESULT _hr = put_HRadius(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(590)
inline double VGCore::IVGEllipse::GetVRadius ( ) {
    double _result = 0;
    HRESULT _hr = get_VRadius(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(591)
inline void VGCore::IVGEllipse::PutVRadius ( double pVal ) {
    HRESULT _hr = put_VRadius(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(592)
inline HRESULT VGCore::IVGEllipse::SetCenterPosition ( double PositionX, double PositionY ) {
    HRESULT _hr = raw_SetCenterPosition(PositionX, PositionY);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(593)
inline HRESULT VGCore::IVGEllipse::GetCenterPosition ( double * PositionX, double * PositionY ) {
    HRESULT _hr = raw_GetCenterPosition(PositionX, PositionY);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(594)
inline HRESULT VGCore::IVGEllipse::SetRadius ( double HRadius, double VRadius ) {
    HRESULT _hr = raw_SetRadius(HRadius, VRadius);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(595)
inline HRESULT VGCore::IVGEllipse::GetRadius ( double * HRadius, double * VRadius ) {
    HRESULT _hr = raw_GetRadius(HRadius, VRadius);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface IVGPolygon wrapper method implementations
//

#pragma implementation_key(596)
inline enum VGCore::cdrPolygonType VGCore::IVGPolygon::GetType ( ) {
    enum cdrPolygonType _result;
    HRESULT _hr = get_Type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(597)
inline void VGCore::IVGPolygon::PutType ( enum cdrPolygonType pVal ) {
    HRESULT _hr = put_Type(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(598)
inline long VGCore::IVGPolygon::GetSides ( ) {
    long _result = 0;
    HRESULT _hr = get_Sides(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(599)
inline void VGCore::IVGPolygon::PutSides ( long pVal ) {
    HRESULT _hr = put_Sides(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(600)
inline long VGCore::IVGPolygon::GetSharpness ( ) {
    long _result = 0;
    HRESULT _hr = get_Sharpness(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(601)
inline void VGCore::IVGPolygon::PutSharpness ( long pVal ) {
    HRESULT _hr = put_Sharpness(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IVGCrossPoint wrapper method implementations
//

#pragma implementation_key(602)
inline double VGCore::IVGCrossPoint::GetPositionX ( ) {
    double _result = 0;
    HRESULT _hr = get_PositionX(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(603)
inline double VGCore::IVGCrossPoint::GetPositionY ( ) {
    double _result = 0;
    HRESULT _hr = get_PositionY(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(604)
inline double VGCore::IVGCrossPoint::GetOffset ( ) {
    double _result = 0;
    HRESULT _hr = get_Offset(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(605)
inline double VGCore::IVGCrossPoint::GetOffset2 ( ) {
    double _result = 0;
    HRESULT _hr = get_Offset2(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface IVGCrossPoints wrapper method implementations
//

#pragma implementation_key(606)
inline VGCore::IVGCrossPointPtr VGCore::IVGCrossPoints::GetItem ( long Index ) {
    struct IVGCrossPoint * _result = 0;
    HRESULT _hr = get_Item(Index, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGCrossPointPtr(_result, false);
}

#pragma implementation_key(607)
inline IUnknownPtr VGCore::IVGCrossPoints::Get_NewEnum ( ) {
    IUnknown * _result = 0;
    HRESULT _hr = get__NewEnum(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IUnknownPtr(_result, false);
}

#pragma implementation_key(608)
inline long VGCore::IVGCrossPoints::GetCount ( ) {
    long _result = 0;
    HRESULT _hr = get_Count(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface IVGStructPaletteOptions wrapper method implementations
//

#pragma implementation_key(609)
inline void VGCore::IVGStructPaletteOptions::PutNumColors ( long pVal ) {
    HRESULT _hr = put_NumColors(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(610)
inline long VGCore::IVGStructPaletteOptions::GetNumColors ( ) {
    long _result = 0;
    HRESULT _hr = get_NumColors(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(611)
inline void VGCore::IVGStructPaletteOptions::PutDitherIntensity ( long pVal ) {
    HRESULT _hr = put_DitherIntensity(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(612)
inline long VGCore::IVGStructPaletteOptions::GetDitherIntensity ( ) {
    long _result = 0;
    HRESULT _hr = get_DitherIntensity(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(613)
inline void VGCore::IVGStructPaletteOptions::PutSmoothing ( long pVal ) {
    HRESULT _hr = put_Smoothing(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(614)
inline long VGCore::IVGStructPaletteOptions::GetSmoothing ( ) {
    long _result = 0;
    HRESULT _hr = get_Smoothing(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(615)
inline void VGCore::IVGStructPaletteOptions::PutDitherType ( enum cdrDitherType pVal ) {
    HRESULT _hr = put_DitherType(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(616)
inline enum VGCore::cdrDitherType VGCore::IVGStructPaletteOptions::GetDitherType ( ) {
    enum cdrDitherType _result;
    HRESULT _hr = get_DitherType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(617)
inline void VGCore::IVGStructPaletteOptions::PutPaletteType ( enum cdrImagePaletteType pVal ) {
    HRESULT _hr = put_PaletteType(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(618)
inline enum VGCore::cdrImagePaletteType VGCore::IVGStructPaletteOptions::GetPaletteType ( ) {
    enum cdrImagePaletteType _result;
    HRESULT _hr = get_PaletteType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(619)
inline void VGCore::IVGStructPaletteOptions::PutImportance ( long pVal ) {
    HRESULT _hr = put_Importance(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(620)
inline long VGCore::IVGStructPaletteOptions::GetImportance ( ) {
    long _result = 0;
    HRESULT _hr = get_Importance(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(621)
inline void VGCore::IVGStructPaletteOptions::PutLightness ( long pVal ) {
    HRESULT _hr = put_Lightness(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(622)
inline long VGCore::IVGStructPaletteOptions::GetLightness ( ) {
    long _result = 0;
    HRESULT _hr = get_Lightness(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(623)
inline void VGCore::IVGStructPaletteOptions::PutToleranceA ( long pVal ) {
    HRESULT _hr = put_ToleranceA(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(624)
inline long VGCore::IVGStructPaletteOptions::GetToleranceA ( ) {
    long _result = 0;
    HRESULT _hr = get_ToleranceA(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(625)
inline void VGCore::IVGStructPaletteOptions::PutToleranceB ( long pVal ) {
    HRESULT _hr = put_ToleranceB(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(626)
inline long VGCore::IVGStructPaletteOptions::GetToleranceB ( ) {
    long _result = 0;
    HRESULT _hr = get_ToleranceB(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(627)
inline void VGCore::IVGStructPaletteOptions::PutColorSensitive ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_ColorSensitive(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(628)
inline VARIANT_BOOL VGCore::IVGStructPaletteOptions::GetColorSensitive ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_ColorSensitive(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(629)
inline void VGCore::IVGStructPaletteOptions::PutTargetColor ( long pVal ) {
    HRESULT _hr = put_TargetColor(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(630)
inline long VGCore::IVGStructPaletteOptions::GetTargetColor ( ) {
    long _result = 0;
    HRESULT _hr = get_TargetColor(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(631)
inline void VGCore::IVGStructPaletteOptions::PutPalette ( const _variant_t & pVal ) {
    HRESULT _hr = put_Palette(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(632)
inline _variant_t VGCore::IVGStructPaletteOptions::GetPalette ( ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = get_Palette(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

//
// interface IVGOutlineStyle wrapper method implementations
//

#pragma implementation_key(633)
inline long VGCore::IVGOutlineStyle::GetIndex ( ) {
    long _result = 0;
    HRESULT _hr = get_Index(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(634)
inline long VGCore::IVGOutlineStyle::GetDashCount ( ) {
    long _result = 0;
    HRESULT _hr = get_DashCount(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(635)
inline void VGCore::IVGOutlineStyle::PutDashCount ( long pVal ) {
    HRESULT _hr = put_DashCount(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(636)
inline long VGCore::IVGOutlineStyle::GetDashLength ( long Index ) {
    long _result = 0;
    HRESULT _hr = get_DashLength(Index, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(637)
inline void VGCore::IVGOutlineStyle::PutDashLength ( long Index, long pVal ) {
    HRESULT _hr = put_DashLength(Index, pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(638)
inline long VGCore::IVGOutlineStyle::GetGapLength ( long Index ) {
    long _result = 0;
    HRESULT _hr = get_GapLength(Index, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(639)
inline void VGCore::IVGOutlineStyle::PutGapLength ( long Index, long pVal ) {
    HRESULT _hr = put_GapLength(Index, pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(640)
inline VARIANT_BOOL VGCore::IVGOutlineStyle::GetEnhanced ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_Enhanced(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface IVGPatternCanvas wrapper method implementations
//

#pragma implementation_key(641)
inline enum VGCore::cdrPatternCanvasSize VGCore::IVGPatternCanvas::GetSize ( ) {
    enum cdrPatternCanvasSize _result;
    HRESULT _hr = get_Size(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(642)
inline void VGCore::IVGPatternCanvas::PutSize ( enum cdrPatternCanvasSize pVal ) {
    HRESULT _hr = put_Size(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(643)
inline VARIANT_BOOL VGCore::IVGPatternCanvas::GetPixel ( long x, long y ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_Pixel(x, y, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(644)
inline void VGCore::IVGPatternCanvas::PutPixel ( long x, long y, VARIANT_BOOL pVal ) {
    HRESULT _hr = put_Pixel(x, y, pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(645)
inline long VGCore::IVGPatternCanvas::GetIndex ( ) {
    long _result = 0;
    HRESULT _hr = get_Index(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(646)
inline HRESULT VGCore::IVGPatternCanvas::FillArea ( long x1, long y1, long x2, long y2, VARIANT_BOOL State ) {
    HRESULT _hr = raw_FillArea(x1, y1, x2, y2, State);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(647)
inline HRESULT VGCore::IVGPatternCanvas::CopyArea ( long x1, long y1, long x2, long y2, long x, long y ) {
    HRESULT _hr = raw_CopyArea(x1, y1, x2, y2, x, y);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(648)
inline HRESULT VGCore::IVGPatternCanvas::FlipArea ( long x1, long y1, long x2, long y2, enum cdrFlipAxes Axes ) {
    HRESULT _hr = raw_FlipArea(x1, y1, x2, y2, Axes);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(649)
inline HRESULT VGCore::IVGPatternCanvas::RotateArea ( long x1, long y1, long x2, long y2, double Angle ) {
    HRESULT _hr = raw_RotateArea(x1, y1, x2, y2, Angle);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(650)
inline HRESULT VGCore::IVGPatternCanvas::Select ( long Index ) {
    HRESULT _hr = raw_Select(Index);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(651)
inline HRESULT VGCore::IVGPatternCanvas::Clear ( ) {
    HRESULT _hr = raw_Clear();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(652)
inline HRESULT VGCore::IVGPatternCanvas::PutCopy ( struct IVGPatternCanvas * PatternCanvas ) {
    HRESULT _hr = raw_PutCopy(PatternCanvas);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(653)
inline long VGCore::IVGPatternCanvas::GetWidth ( ) {
    long _result = 0;
    HRESULT _hr = get_Width(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(654)
inline void VGCore::IVGPatternCanvas::PutWidth ( long pVal ) {
    HRESULT _hr = put_Width(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(655)
inline long VGCore::IVGPatternCanvas::GetHeight ( ) {
    long _result = 0;
    HRESULT _hr = get_Height(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(656)
inline void VGCore::IVGPatternCanvas::PutHeight ( long pVal ) {
    HRESULT _hr = put_Height(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(657)
inline _bstr_t VGCore::IVGPatternCanvas::GetData ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Data(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(658)
inline void VGCore::IVGPatternCanvas::PutData ( _bstr_t pVal ) {
    HRESULT _hr = put_Data(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(659)
inline HRESULT VGCore::IVGPatternCanvas::PSet ( short Step, long x, long y, VARIANT_BOOL Color ) {
    HRESULT _hr = raw_PSet(Step, x, y, Color);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(660)
inline HRESULT VGCore::IVGPatternCanvas::Line ( short Flags, long x1, long y1, long x2, long y2, VARIANT_BOOL Color ) {
    HRESULT _hr = raw_Line(Flags, x1, y1, x2, y2, Color);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface IVGTextureFillProperty wrapper method implementations
//

#pragma implementation_key(661)
inline _bstr_t VGCore::IVGTextureFillProperty::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(662)
inline enum VGCore::cdrTexturePropertyType VGCore::IVGTextureFillProperty::GetType ( ) {
    enum cdrTexturePropertyType _result;
    HRESULT _hr = get_Type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(663)
inline _variant_t VGCore::IVGTextureFillProperty::GetValue ( ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = get_Value(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

#pragma implementation_key(664)
inline void VGCore::IVGTextureFillProperty::PutValue ( const _variant_t & pVal ) {
    HRESULT _hr = put_Value(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IVGTextureFillProperties wrapper method implementations
//

#pragma implementation_key(665)
inline long VGCore::IVGTextureFillProperties::GetCount ( ) {
    long _result = 0;
    HRESULT _hr = get_Count(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(666)
inline VGCore::IVGTextureFillPropertyPtr VGCore::IVGTextureFillProperties::GetItem ( const _variant_t & IndexOrName ) {
    struct IVGTextureFillProperty * _result = 0;
    HRESULT _hr = get_Item(IndexOrName, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGTextureFillPropertyPtr(_result, false);
}

#pragma implementation_key(667)
inline IUnknownPtr VGCore::IVGTextureFillProperties::Get_NewEnum ( ) {
    IUnknown * _result = 0;
    HRESULT _hr = get__NewEnum(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IUnknownPtr(_result, false);
}

//
// interface IVGTextureFill wrapper method implementations
//

#pragma implementation_key(668)
inline double VGCore::IVGTextureFill::GetOriginX ( ) {
    double _result = 0;
    HRESULT _hr = get_OriginX(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(669)
inline void VGCore::IVGTextureFill::PutOriginX ( double pVal ) {
    HRESULT _hr = put_OriginX(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(670)
inline double VGCore::IVGTextureFill::GetOriginY ( ) {
    double _result = 0;
    HRESULT _hr = get_OriginY(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(671)
inline void VGCore::IVGTextureFill::PutOriginY ( double pVal ) {
    HRESULT _hr = put_OriginY(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(672)
inline double VGCore::IVGTextureFill::GetTileWidth ( ) {
    double _result = 0;
    HRESULT _hr = get_TileWidth(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(673)
inline void VGCore::IVGTextureFill::PutTileWidth ( double pVal ) {
    HRESULT _hr = put_TileWidth(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(674)
inline double VGCore::IVGTextureFill::GetTileHeight ( ) {
    double _result = 0;
    HRESULT _hr = get_TileHeight(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(675)
inline void VGCore::IVGTextureFill::PutTileHeight ( double pVal ) {
    HRESULT _hr = put_TileHeight(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(676)
inline enum VGCore::cdrTileOffsetType VGCore::IVGTextureFill::GetTileOffsetType ( ) {
    enum cdrTileOffsetType _result;
    HRESULT _hr = get_TileOffsetType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(677)
inline void VGCore::IVGTextureFill::PutTileOffsetType ( enum cdrTileOffsetType pVal ) {
    HRESULT _hr = put_TileOffsetType(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(678)
inline long VGCore::IVGTextureFill::GetTileOffset ( ) {
    long _result = 0;
    HRESULT _hr = get_TileOffset(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(679)
inline void VGCore::IVGTextureFill::PutTileOffset ( long pVal ) {
    HRESULT _hr = put_TileOffset(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(680)
inline double VGCore::IVGTextureFill::GetSkewAngle ( ) {
    double _result = 0;
    HRESULT _hr = get_SkewAngle(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(681)
inline void VGCore::IVGTextureFill::PutSkewAngle ( double pVal ) {
    HRESULT _hr = put_SkewAngle(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(682)
inline double VGCore::IVGTextureFill::GetRotationAngle ( ) {
    double _result = 0;
    HRESULT _hr = get_RotationAngle(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(683)
inline void VGCore::IVGTextureFill::PutRotationAngle ( double pVal ) {
    HRESULT _hr = put_RotationAngle(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(684)
inline VARIANT_BOOL VGCore::IVGTextureFill::GetTransformWithShape ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_TransformWithShape(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(685)
inline void VGCore::IVGTextureFill::PutTransformWithShape ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_TransformWithShape(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(686)
inline long VGCore::IVGTextureFill::GetResolution ( ) {
    long _result = 0;
    HRESULT _hr = get_Resolution(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(687)
inline void VGCore::IVGTextureFill::PutResolution ( long pVal ) {
    HRESULT _hr = put_Resolution(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(688)
inline long VGCore::IVGTextureFill::GetMaximumTileWidth ( ) {
    long _result = 0;
    HRESULT _hr = get_MaximumTileWidth(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(689)
inline void VGCore::IVGTextureFill::PutMaximumTileWidth ( long pVal ) {
    HRESULT _hr = put_MaximumTileWidth(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(690)
inline _bstr_t VGCore::IVGTextureFill::GetLibraryName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_LibraryName(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(691)
inline _bstr_t VGCore::IVGTextureFill::GetTextureName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_TextureName(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(692)
inline _bstr_t VGCore::IVGTextureFill::GetStyleName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_StyleName(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(693)
inline HRESULT VGCore::IVGTextureFill::Select ( _bstr_t Texture, _bstr_t Library ) {
    HRESULT _hr = raw_Select(Texture, Library);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(694)
inline HRESULT VGCore::IVGTextureFill::SetProperties ( SAFEARRAY * * SettingArray ) {
    HRESULT _hr = raw_SetProperties(SettingArray);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(695)
inline VARIANT_BOOL VGCore::IVGTextureFill::GetMirrorFill ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_MirrorFill(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(696)
inline void VGCore::IVGTextureFill::PutMirrorFill ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_MirrorFill(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(697)
inline VGCore::IVGTextureFillPropertiesPtr VGCore::IVGTextureFill::GetProperties ( ) {
    struct IVGTextureFillProperties * _result = 0;
    HRESULT _hr = get_Properties(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGTextureFillPropertiesPtr(_result, false);
}

#pragma implementation_key(698)
inline VARIANT_BOOL VGCore::IVGTextureFill::GetMirrorFillX ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_MirrorFillX(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(699)
inline void VGCore::IVGTextureFill::PutMirrorFillX ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_MirrorFillX(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(700)
inline VARIANT_BOOL VGCore::IVGTextureFill::GetMirrorFillY ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_MirrorFillY(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(701)
inline void VGCore::IVGTextureFill::PutMirrorFillY ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_MirrorFillY(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IVGPostScriptFill wrapper method implementations
//

#pragma implementation_key(702)
inline _bstr_t VGCore::IVGPostScriptFill::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(703)
inline long VGCore::IVGPostScriptFill::GetIndex ( ) {
    long _result = 0;
    HRESULT _hr = get_Index(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(704)
inline long VGCore::IVGPostScriptFill::GetProperties ( long Index ) {
    long _result = 0;
    HRESULT _hr = get_Properties(Index, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(705)
inline void VGCore::IVGPostScriptFill::PutProperties ( long Index, long pVal ) {
    HRESULT _hr = put_Properties(Index, pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(706)
inline HRESULT VGCore::IVGPostScriptFill::Select ( const _variant_t & IndexOrName ) {
    HRESULT _hr = raw_Select(IndexOrName);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(707)
inline HRESULT VGCore::IVGPostScriptFill::SetProperties ( long Param1, long Param2, long Param3, long Param4, long Param5 ) {
    HRESULT _hr = raw_SetProperties(Param1, Param2, Param3, Param4, Param5);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface IVGPSScreenOptions wrapper method implementations
//

#pragma implementation_key(708)
inline long VGCore::IVGPSScreenOptions::GetIndex ( ) {
    long _result = 0;
    HRESULT _hr = get_Index(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(709)
inline _bstr_t VGCore::IVGPSScreenOptions::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(710)
inline double VGCore::IVGPSScreenOptions::GetAngle ( ) {
    double _result = 0;
    HRESULT _hr = get_Angle(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(711)
inline void VGCore::IVGPSScreenOptions::PutAngle ( double pVal ) {
    HRESULT _hr = put_Angle(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(712)
inline long VGCore::IVGPSScreenOptions::GetFrequency ( ) {
    long _result = 0;
    HRESULT _hr = get_Frequency(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(713)
inline void VGCore::IVGPSScreenOptions::PutFrequency ( long pVal ) {
    HRESULT _hr = put_Frequency(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(714)
inline VARIANT_BOOL VGCore::IVGPSScreenOptions::Select ( _bstr_t Name ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_Select(Name, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(715)
inline VARIANT_BOOL VGCore::IVGPSScreenOptions::SetProperties ( const _variant_t & IndexOrName, double Angle, long Frequency ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_SetProperties(IndexOrName, Angle, Frequency, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(716)
inline _bstr_t VGCore::IVGPSScreenOptions::NameByIndex ( long Index ) {
    BSTR _result = 0;
    HRESULT _hr = raw_NameByIndex(Index, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(717)
inline HRESULT VGCore::IVGPSScreenOptions::Reset ( ) {
    HRESULT _hr = raw_Reset();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(718)
inline VARIANT_BOOL VGCore::IVGPSScreenOptions::UserAssign ( long ParentWindowHandle ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_UserAssign(ParentWindowHandle, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface IVGArrowHeadOptions wrapper method implementations
//

#pragma implementation_key(719)
inline double VGCore::IVGArrowHeadOptions::GetLength ( ) {
    double _result = 0;
    HRESULT _hr = get_Length(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(720)
inline void VGCore::IVGArrowHeadOptions::PutLength ( double pVal ) {
    HRESULT _hr = put_Length(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(721)
inline double VGCore::IVGArrowHeadOptions::GetWidth ( ) {
    double _result = 0;
    HRESULT _hr = get_Width(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(722)
inline void VGCore::IVGArrowHeadOptions::PutWidth ( double pVal ) {
    HRESULT _hr = put_Width(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(723)
inline double VGCore::IVGArrowHeadOptions::GetOffsetX ( ) {
    double _result = 0;
    HRESULT _hr = get_OffsetX(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(724)
inline void VGCore::IVGArrowHeadOptions::PutOffsetX ( double pVal ) {
    HRESULT _hr = put_OffsetX(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(725)
inline double VGCore::IVGArrowHeadOptions::GetOffsetY ( ) {
    double _result = 0;
    HRESULT _hr = get_OffsetY(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(726)
inline void VGCore::IVGArrowHeadOptions::PutOffsetY ( double pVal ) {
    HRESULT _hr = put_OffsetY(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(727)
inline VARIANT_BOOL VGCore::IVGArrowHeadOptions::GetFlipHorizontal ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_FlipHorizontal(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(728)
inline void VGCore::IVGArrowHeadOptions::PutFlipHorizontal ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_FlipHorizontal(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(729)
inline VARIANT_BOOL VGCore::IVGArrowHeadOptions::GetFlipVertical ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_FlipVertical(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(730)
inline void VGCore::IVGArrowHeadOptions::PutFlipVertical ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_FlipVertical(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(731)
inline HRESULT VGCore::IVGArrowHeadOptions::Flip ( enum cdrFlipAxes Axes ) {
    HRESULT _hr = raw_Flip(Axes);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(732)
inline double VGCore::IVGArrowHeadOptions::GetRotationAngle ( ) {
    double _result = 0;
    HRESULT _hr = get_RotationAngle(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(733)
inline void VGCore::IVGArrowHeadOptions::PutRotationAngle ( double pVal ) {
    HRESULT _hr = put_RotationAngle(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(734)
inline HRESULT VGCore::IVGArrowHeadOptions::CopyAssign ( struct IVGArrowHeadOptions * Source ) {
    HRESULT _hr = raw_CopyAssign(Source);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(735)
inline VGCore::IVGArrowHeadOptionsPtr VGCore::IVGArrowHeadOptions::GetCopy ( ) {
    struct IVGArrowHeadOptions * _result = 0;
    HRESULT _hr = raw_GetCopy(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGArrowHeadOptionsPtr(_result, false);
}

#pragma implementation_key(736)
inline VARIANT_BOOL VGCore::IVGArrowHeadOptions::GetFlipVerical ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_FlipVerical(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(737)
inline void VGCore::IVGArrowHeadOptions::PutFlipVerical ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_FlipVerical(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IVGImageTile wrapper method implementations
//

#pragma implementation_key(738)
inline long VGCore::IVGImageTile::GetLeft ( ) {
    long _result = 0;
    HRESULT _hr = get_Left(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(739)
inline long VGCore::IVGImageTile::GetTop ( ) {
    long _result = 0;
    HRESULT _hr = get_Top(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(740)
inline long VGCore::IVGImageTile::GetRight ( ) {
    long _result = 0;
    HRESULT _hr = get_Right(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(741)
inline long VGCore::IVGImageTile::GetBottom ( ) {
    long _result = 0;
    HRESULT _hr = get_Bottom(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(742)
inline long VGCore::IVGImageTile::GetWidth ( ) {
    long _result = 0;
    HRESULT _hr = get_Width(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(743)
inline long VGCore::IVGImageTile::GetHeight ( ) {
    long _result = 0;
    HRESULT _hr = get_Height(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(744)
inline long VGCore::IVGImageTile::GetBytesPerTile ( ) {
    long _result = 0;
    HRESULT _hr = get_BytesPerTile(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(745)
inline long VGCore::IVGImageTile::GetBytesPerLine ( ) {
    long _result = 0;
    HRESULT _hr = get_BytesPerLine(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(746)
inline long VGCore::IVGImageTile::GetBytesPerPixel ( ) {
    long _result = 0;
    HRESULT _hr = get_BytesPerPixel(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(747)
inline SAFEARRAY * VGCore::IVGImageTile::GetPixelData ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = get_PixelData(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(748)
inline void VGCore::IVGImageTile::PutPixelData ( SAFEARRAY * * pVal ) {
    HRESULT _hr = put_PixelData(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(749)
inline VARIANT_BOOL VGCore::IVGImageTile::GetReadOnly ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_ReadOnly(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface IVGImageTiles wrapper method implementations
//

#pragma implementation_key(750)
inline long VGCore::IVGImageTiles::GetCount ( ) {
    long _result = 0;
    HRESULT _hr = get_Count(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(751)
inline VGCore::IVGImageTilePtr VGCore::IVGImageTiles::GetItem ( long Index ) {
    struct IVGImageTile * _result = 0;
    HRESULT _hr = get_Item(Index, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGImageTilePtr(_result, false);
}

#pragma implementation_key(752)
inline IUnknownPtr VGCore::IVGImageTiles::Get_NewEnum ( ) {
    IUnknown * _result = 0;
    HRESULT _hr = get__NewEnum(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IUnknownPtr(_result, false);
}

#pragma implementation_key(753)
inline VGCore::IVGImageTilePtr VGCore::IVGImageTiles::GetFirst ( ) {
    struct IVGImageTile * _result = 0;
    HRESULT _hr = get_First(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGImageTilePtr(_result, false);
}

#pragma implementation_key(754)
inline VGCore::IVGImageTilePtr VGCore::IVGImageTiles::GetLast ( ) {
    struct IVGImageTile * _result = 0;
    HRESULT _hr = get_Last(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGImageTilePtr(_result, false);
}

//
// interface IVGStructAlignProperties wrapper method implementations
//

#pragma implementation_key(755)
inline void VGCore::IVGStructAlignProperties::PutAlignment ( enum cdrAlignment pVal ) {
    HRESULT _hr = put_Alignment(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(756)
inline enum VGCore::cdrAlignment VGCore::IVGStructAlignProperties::GetAlignment ( ) {
    enum cdrAlignment _result;
    HRESULT _hr = get_Alignment(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(757)
inline void VGCore::IVGStructAlignProperties::PutFirstLineIndent ( double pVal ) {
    HRESULT _hr = put_FirstLineIndent(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(758)
inline double VGCore::IVGStructAlignProperties::GetFirstLineIndent ( ) {
    double _result = 0;
    HRESULT _hr = get_FirstLineIndent(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(759)
inline void VGCore::IVGStructAlignProperties::PutLeftIndent ( double pVal ) {
    HRESULT _hr = put_LeftIndent(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(760)
inline double VGCore::IVGStructAlignProperties::GetLeftIndent ( ) {
    double _result = 0;
    HRESULT _hr = get_LeftIndent(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(761)
inline void VGCore::IVGStructAlignProperties::PutRightIndent ( double pVal ) {
    HRESULT _hr = put_RightIndent(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(762)
inline double VGCore::IVGStructAlignProperties::GetRightIndent ( ) {
    double _result = 0;
    HRESULT _hr = get_RightIndent(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(763)
inline void VGCore::IVGStructAlignProperties::PutMaxWordSpacing ( float pVal ) {
    HRESULT _hr = put_MaxWordSpacing(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(764)
inline float VGCore::IVGStructAlignProperties::GetMaxWordSpacing ( ) {
    float _result = 0;
    HRESULT _hr = get_MaxWordSpacing(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(765)
inline void VGCore::IVGStructAlignProperties::PutMinWordSpacing ( float pVal ) {
    HRESULT _hr = put_MinWordSpacing(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(766)
inline float VGCore::IVGStructAlignProperties::GetMinWordSpacing ( ) {
    float _result = 0;
    HRESULT _hr = get_MinWordSpacing(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(767)
inline void VGCore::IVGStructAlignProperties::PutMaxCharacterSpacing ( float pVal ) {
    HRESULT _hr = put_MaxCharacterSpacing(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(768)
inline float VGCore::IVGStructAlignProperties::GetMaxCharacterSpacing ( ) {
    float _result = 0;
    HRESULT _hr = get_MaxCharacterSpacing(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(769)
inline void VGCore::IVGStructAlignProperties::PutHorizontalCharacterShift ( long pVal ) {
    HRESULT _hr = put_HorizontalCharacterShift(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(770)
inline long VGCore::IVGStructAlignProperties::GetHorizontalCharacterShift ( ) {
    long _result = 0;
    HRESULT _hr = get_HorizontalCharacterShift(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(771)
inline void VGCore::IVGStructAlignProperties::PutVerticalCharacterShift ( long pVal ) {
    HRESULT _hr = put_VerticalCharacterShift(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(772)
inline long VGCore::IVGStructAlignProperties::GetVerticalCharacterShift ( ) {
    long _result = 0;
    HRESULT _hr = get_VerticalCharacterShift(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(773)
inline void VGCore::IVGStructAlignProperties::PutCharacterRotation ( float pVal ) {
    HRESULT _hr = put_CharacterRotation(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(774)
inline float VGCore::IVGStructAlignProperties::GetCharacterRotation ( ) {
    float _result = 0;
    HRESULT _hr = get_CharacterRotation(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface IVGStructSpaceProperties wrapper method implementations
//

#pragma implementation_key(775)
inline void VGCore::IVGStructSpaceProperties::PutCharacterSpacing ( float pVal ) {
    HRESULT _hr = put_CharacterSpacing(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(776)
inline float VGCore::IVGStructSpaceProperties::GetCharacterSpacing ( ) {
    float _result = 0;
    HRESULT _hr = get_CharacterSpacing(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(777)
inline void VGCore::IVGStructSpaceProperties::PutWordSpacing ( float pVal ) {
    HRESULT _hr = put_WordSpacing(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(778)
inline float VGCore::IVGStructSpaceProperties::GetWordSpacing ( ) {
    float _result = 0;
    HRESULT _hr = get_WordSpacing(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(779)
inline void VGCore::IVGStructSpaceProperties::PutLineSpacing ( float pVal ) {
    HRESULT _hr = put_LineSpacing(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(780)
inline float VGCore::IVGStructSpaceProperties::GetLineSpacing ( ) {
    float _result = 0;
    HRESULT _hr = get_LineSpacing(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(781)
inline void VGCore::IVGStructSpaceProperties::PutLineSpacingType ( enum cdrLineSpacingType pVal ) {
    HRESULT _hr = put_LineSpacingType(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(782)
inline enum VGCore::cdrLineSpacingType VGCore::IVGStructSpaceProperties::GetLineSpacingType ( ) {
    enum cdrLineSpacingType _result;
    HRESULT _hr = get_LineSpacingType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(783)
inline void VGCore::IVGStructSpaceProperties::PutBeforeParagraphSpacing ( float pVal ) {
    HRESULT _hr = put_BeforeParagraphSpacing(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(784)
inline float VGCore::IVGStructSpaceProperties::GetBeforeParagraphSpacing ( ) {
    float _result = 0;
    HRESULT _hr = get_BeforeParagraphSpacing(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(785)
inline void VGCore::IVGStructSpaceProperties::PutAfterParagraphSpacing ( float pVal ) {
    HRESULT _hr = put_AfterParagraphSpacing(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(786)
inline float VGCore::IVGStructSpaceProperties::GetAfterParagraphSpacing ( ) {
    float _result = 0;
    HRESULT _hr = get_AfterParagraphSpacing(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface IVGStructHyphenationSettings wrapper method implementations
//

#pragma implementation_key(787)
inline void VGCore::IVGStructHyphenationSettings::PutUseAutomaticHyphenation ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_UseAutomaticHyphenation(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(788)
inline VARIANT_BOOL VGCore::IVGStructHyphenationSettings::GetUseAutomaticHyphenation ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_UseAutomaticHyphenation(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(789)
inline void VGCore::IVGStructHyphenationSettings::PutBreakCapitalized ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_BreakCapitalized(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(790)
inline VARIANT_BOOL VGCore::IVGStructHyphenationSettings::GetBreakCapitalized ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_BreakCapitalized(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(791)
inline void VGCore::IVGStructHyphenationSettings::PutHotZone ( double pVal ) {
    HRESULT _hr = put_HotZone(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(792)
inline double VGCore::IVGStructHyphenationSettings::GetHotZone ( ) {
    double _result = 0;
    HRESULT _hr = get_HotZone(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(793)
inline void VGCore::IVGStructHyphenationSettings::PutMinWordLength ( long pVal ) {
    HRESULT _hr = put_MinWordLength(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(794)
inline long VGCore::IVGStructHyphenationSettings::GetMinWordLength ( ) {
    long _result = 0;
    HRESULT _hr = get_MinWordLength(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(795)
inline void VGCore::IVGStructHyphenationSettings::PutMinCharactersBefore ( long pVal ) {
    HRESULT _hr = put_MinCharactersBefore(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(796)
inline long VGCore::IVGStructHyphenationSettings::GetMinCharactersBefore ( ) {
    long _result = 0;
    HRESULT _hr = get_MinCharactersBefore(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(797)
inline void VGCore::IVGStructHyphenationSettings::PutMinCharactersAfter ( long pVal ) {
    HRESULT _hr = put_MinCharactersAfter(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(798)
inline long VGCore::IVGStructHyphenationSettings::GetMinCharactersAfter ( ) {
    long _result = 0;
    HRESULT _hr = get_MinCharactersAfter(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(799)
inline void VGCore::IVGStructHyphenationSettings::PutBreakAllCapWords ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_BreakAllCapWords(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(800)
inline VARIANT_BOOL VGCore::IVGStructHyphenationSettings::GetBreakAllCapWords ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_BreakAllCapWords(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface IVGUserSnapPoint wrapper method implementations
//

#pragma implementation_key(801)
inline _bstr_t VGCore::IVGUserSnapPoint::GetID ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_ID(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(802)
inline VARIANT_BOOL VGCore::IVGUserSnapPoint::GetAutoSnap ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_AutoSnap(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(803)
inline void VGCore::IVGUserSnapPoint::PutAutoSnap ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_AutoSnap(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IVGObjectSnapPoint wrapper method implementations
//

#pragma implementation_key(804)
inline enum VGCore::cdrObjectSnapPointType VGCore::IVGObjectSnapPoint::GetType ( ) {
    enum cdrObjectSnapPointType _result;
    HRESULT _hr = get_Type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface IVGBBoxSnapPoint wrapper method implementations
//

#pragma implementation_key(805)
inline enum VGCore::cdrReferencePoint VGCore::IVGBBoxSnapPoint::GetType ( ) {
    enum cdrReferencePoint _result;
    HRESULT _hr = get_Type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface IVGEdgeSnapPoint wrapper method implementations
//

#pragma implementation_key(806)
inline long VGCore::IVGEdgeSnapPoint::GetSegmentIndex ( ) {
    long _result = 0;
    HRESULT _hr = get_SegmentIndex(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(807)
inline double VGCore::IVGEdgeSnapPoint::GetSegmentOffset ( ) {
    double _result = 0;
    HRESULT _hr = get_SegmentOffset(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface IVGEffectCustomDistortion wrapper method implementations
//

#pragma implementation_key(808)
inline _bstr_t VGCore::IVGEffectCustomDistortion::GetDistortionID ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_DistortionID(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

//
// interface IVGTextTabPosition wrapper method implementations
//

#pragma implementation_key(809)
inline double VGCore::IVGTextTabPosition::GetPosition ( ) {
    double _result = 0;
    HRESULT _hr = get_Position(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(810)
inline void VGCore::IVGTextTabPosition::PutPosition ( double pVal ) {
    HRESULT _hr = put_Position(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(811)
inline long VGCore::IVGTextTabPosition::GetIndex ( ) {
    long _result = 0;
    HRESULT _hr = get_Index(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(812)
inline enum VGCore::cdrTextTabAlignment VGCore::IVGTextTabPosition::GetAlignment ( ) {
    enum cdrTextTabAlignment _result;
    HRESULT _hr = get_Alignment(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(813)
inline void VGCore::IVGTextTabPosition::PutAlignment ( enum cdrTextTabAlignment pVal ) {
    HRESULT _hr = put_Alignment(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(814)
inline VARIANT_BOOL VGCore::IVGTextTabPosition::GetLeadered ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_Leadered(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(815)
inline void VGCore::IVGTextTabPosition::PutLeadered ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_Leadered(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(816)
inline HRESULT VGCore::IVGTextTabPosition::Delete ( ) {
    HRESULT _hr = raw_Delete();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface IVGTextTabPositions wrapper method implementations
//

#pragma implementation_key(817)
inline VGCore::IVGTextTabPositionPtr VGCore::IVGTextTabPositions::GetItem ( long Index ) {
    struct IVGTextTabPosition * _result = 0;
    HRESULT _hr = get_Item(Index, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGTextTabPositionPtr(_result, false);
}

#pragma implementation_key(818)
inline long VGCore::IVGTextTabPositions::GetCount ( ) {
    long _result = 0;
    HRESULT _hr = get_Count(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(819)
inline IUnknownPtr VGCore::IVGTextTabPositions::Get_NewEnum ( ) {
    IUnknown * _result = 0;
    HRESULT _hr = get__NewEnum(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IUnknownPtr(_result, false);
}

#pragma implementation_key(820)
inline long VGCore::IVGTextTabPositions::GetLeaderSpacing ( ) {
    long _result = 0;
    HRESULT _hr = get_LeaderSpacing(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(821)
inline void VGCore::IVGTextTabPositions::PutLeaderSpacing ( long pVal ) {
    HRESULT _hr = put_LeaderSpacing(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(822)
inline _bstr_t VGCore::IVGTextTabPositions::GetLeaderCharacter ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_LeaderCharacter(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(823)
inline void VGCore::IVGTextTabPositions::PutLeaderCharacter ( _bstr_t pVal ) {
    HRESULT _hr = put_LeaderCharacter(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(824)
inline HRESULT VGCore::IVGTextTabPositions::Clear ( ) {
    HRESULT _hr = raw_Clear();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(825)
inline VGCore::IVGTextTabPositionPtr VGCore::IVGTextTabPositions::Add ( double Position, enum cdrTextTabAlignment Alignment, VARIANT_BOOL Leadered ) {
    struct IVGTextTabPosition * _result = 0;
    HRESULT _hr = raw_Add(Position, Alignment, Leadered, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGTextTabPositionPtr(_result, false);
}

#pragma implementation_key(826)
inline HRESULT VGCore::IVGTextTabPositions::AddEvery ( double Position, enum cdrTextTabAlignment Alignment, VARIANT_BOOL Leadered ) {
    HRESULT _hr = raw_AddEvery(Position, Alignment, Leadered);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface IVGLocalizableString wrapper method implementations
//

#pragma implementation_key(827)
inline HRESULT VGCore::IVGLocalizableString::Clear ( ) {
    HRESULT _hr = raw_Clear();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(828)
inline VARIANT_BOOL VGCore::IVGLocalizableString::GetIsEmpty ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsEmpty(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(829)
inline _bstr_t VGCore::IVGLocalizableString::GetLangString ( _bstr_t Language ) {
    BSTR _result = 0;
    HRESULT _hr = raw_GetLangString(Language, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(830)
inline HRESULT VGCore::IVGLocalizableString::SetLangString ( _bstr_t Language, _bstr_t Value ) {
    HRESULT _hr = raw_SetLangString(Language, Value);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(831)
inline VARIANT_BOOL VGCore::IVGLocalizableString::HasLangString ( _bstr_t Language ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_HasLangString(Language, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(832)
inline VARIANT_BOOL VGCore::IVGLocalizableString::GetHasDefaultLangString ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_HasDefaultLangString(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(833)
inline VARIANT_BOOL VGCore::IVGLocalizableString::GetHasDefaultLangStringOnly ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_HasDefaultLangStringOnly(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(834)
inline VARIANT_BOOL VGCore::IVGLocalizableString::GetHasNonDefaultLangStrings ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_HasNonDefaultLangStrings(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(835)
inline _bstr_t VGCore::IVGLocalizableString::GetDefaultLangString ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_DefaultLangString(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(836)
inline void VGCore::IVGLocalizableString::PutDefaultLangString ( _bstr_t pVal ) {
    HRESULT _hr = put_DefaultLangString(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(837)
inline SAFEARRAY * VGCore::IVGLocalizableString::GetLanguages ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_GetLanguages(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface IVGFillMetadata wrapper method implementations
//

#pragma implementation_key(838)
inline VGCore::IVGLocalizableStringPtr VGCore::IVGFillMetadata::GetTitle ( ) {
    struct IVGLocalizableString * _result = 0;
    HRESULT _hr = get_Title(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGLocalizableStringPtr(_result, false);
}

#pragma implementation_key(839)
inline VGCore::IVGLocalizableStringPtr VGCore::IVGFillMetadata::GetDescription ( ) {
    struct IVGLocalizableString * _result = 0;
    HRESULT _hr = get_Description(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGLocalizableStringPtr(_result, false);
}

#pragma implementation_key(840)
inline VGCore::IVGLocalizableStringPtr VGCore::IVGFillMetadata::GetKeywords ( ) {
    struct IVGLocalizableString * _result = 0;
    HRESULT _hr = get_Keywords(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGLocalizableStringPtr(_result, false);
}

#pragma implementation_key(841)
inline VGCore::IVGLocalizableStringPtr VGCore::IVGFillMetadata::GetSubject ( ) {
    struct IVGLocalizableString * _result = 0;
    HRESULT _hr = get_Subject(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGLocalizableStringPtr(_result, false);
}

#pragma implementation_key(842)
inline VGCore::IVGLocalizableStringPtr VGCore::IVGFillMetadata::GetCopyright ( ) {
    struct IVGLocalizableString * _result = 0;
    HRESULT _hr = get_Copyright(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGLocalizableStringPtr(_result, false);
}

#pragma implementation_key(843)
inline _bstr_t VGCore::IVGFillMetadata::GetCreatorTool ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_CreatorTool(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(844)
inline DATE VGCore::IVGFillMetadata::GetCreationDate ( ) {
    DATE _result = 0;
    HRESULT _hr = get_CreationDate(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(845)
inline DATE VGCore::IVGFillMetadata::GetModificationDate ( ) {
    DATE _result = 0;
    HRESULT _hr = get_ModificationDate(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(846)
inline _bstr_t VGCore::IVGFillMetadata::GetDocumentID ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_DocumentID(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(847)
inline _bstr_t VGCore::IVGFillMetadata::GetInstanceID ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_InstanceID(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(848)
inline SAFEARRAY * VGCore::IVGFillMetadata::GetDerivedFrom ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = get_DerivedFrom(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(849)
inline VGCore::IVGLocalizableStringPtr VGCore::IVGFillMetadata::GetCategory ( ) {
    struct IVGLocalizableString * _result = 0;
    HRESULT _hr = get_Category(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGLocalizableStringPtr(_result, false);
}

//
// interface IVGTextIndentLevelStyle wrapper method implementations
//

#pragma implementation_key(850)
inline long VGCore::IVGTextIndentLevelStyle::GetLevel ( ) {
    long _result = 0;
    HRESULT _hr = get_Level(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(851)
inline _bstr_t VGCore::IVGTextIndentLevelStyle::GetFont ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Font(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(852)
inline void VGCore::IVGTextIndentLevelStyle::PutFont ( _bstr_t pVal ) {
    HRESULT _hr = put_Font(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(853)
inline VARIANT_BOOL VGCore::IVGTextIndentLevelStyle::GetUseParagraphFont ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_UseParagraphFont(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(854)
inline void VGCore::IVGTextIndentLevelStyle::PutUseParagraphFont ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_UseParagraphFont(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(855)
inline _bstr_t VGCore::IVGTextIndentLevelStyle::GetSymbol ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Symbol(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(856)
inline void VGCore::IVGTextIndentLevelStyle::PutSymbol ( _bstr_t pVal ) {
    HRESULT _hr = put_Symbol(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(857)
inline float VGCore::IVGTextIndentLevelStyle::GetSize ( ) {
    float _result = 0;
    HRESULT _hr = get_Size(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(858)
inline void VGCore::IVGTextIndentLevelStyle::PutSize ( float pVal ) {
    HRESULT _hr = put_Size(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(859)
inline float VGCore::IVGTextIndentLevelStyle::GetBaselineShift ( ) {
    float _result = 0;
    HRESULT _hr = get_BaselineShift(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(860)
inline void VGCore::IVGTextIndentLevelStyle::PutBaselineShift ( float pVal ) {
    HRESULT _hr = put_BaselineShift(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(861)
inline VARIANT_BOOL VGCore::IVGTextIndentLevelStyle::GetHangingIndent ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_HangingIndent(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(862)
inline void VGCore::IVGTextIndentLevelStyle::PutHangingIndent ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_HangingIndent(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(863)
inline double VGCore::IVGTextIndentLevelStyle::GetFirstCharIndent ( ) {
    double _result = 0;
    HRESULT _hr = get_FirstCharIndent(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(864)
inline void VGCore::IVGTextIndentLevelStyle::PutFirstCharIndent ( double pVal ) {
    HRESULT _hr = put_FirstCharIndent(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(865)
inline VARIANT_BOOL VGCore::IVGTextIndentLevelStyle::GetFirstCharIndentIncludesBullet ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_FirstCharIndentIncludesBullet(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(866)
inline void VGCore::IVGTextIndentLevelStyle::PutFirstCharIndentIncludesBullet ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_FirstCharIndentIncludesBullet(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(867)
inline _bstr_t VGCore::IVGTextIndentLevelStyle::GetFormat ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Format(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(868)
inline void VGCore::IVGTextIndentLevelStyle::PutFormat ( _bstr_t pVal ) {
    HRESULT _hr = put_Format(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(869)
inline enum VGCore::cdrTextIndentLevelStyle VGCore::IVGTextIndentLevelStyle::GetNumberStyle ( ) {
    enum cdrTextIndentLevelStyle _result;
    HRESULT _hr = get_NumberStyle(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(870)
inline void VGCore::IVGTextIndentLevelStyle::PutNumberStyle ( enum cdrTextIndentLevelStyle pVal ) {
    HRESULT _hr = put_NumberStyle(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IVGTextIndentLevelStyles wrapper method implementations
//

#pragma implementation_key(871)
inline IUnknownPtr VGCore::IVGTextIndentLevelStyles::Get_NewEnum ( ) {
    IUnknown * _result = 0;
    HRESULT _hr = get__NewEnum(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IUnknownPtr(_result, false);
}

#pragma implementation_key(872)
inline VGCore::IVGTextIndentLevelStylePtr VGCore::IVGTextIndentLevelStyles::GetItem ( long Index ) {
    struct IVGTextIndentLevelStyle * _result = 0;
    HRESULT _hr = get_Item(Index, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGTextIndentLevelStylePtr(_result, false);
}

#pragma implementation_key(873)
inline long VGCore::IVGTextIndentLevelStyles::GetCount ( ) {
    long _result = 0;
    HRESULT _hr = get_Count(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface IVGTextVariableAxis wrapper method implementations
//

#pragma implementation_key(874)
inline long VGCore::IVGTextVariableAxis::GetTag ( ) {
    long _result = 0;
    HRESULT _hr = get_Tag(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(875)
inline _bstr_t VGCore::IVGTextVariableAxis::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(876)
inline double VGCore::IVGTextVariableAxis::GetValue ( ) {
    double _result = 0;
    HRESULT _hr = get_Value(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(877)
inline void VGCore::IVGTextVariableAxis::PutValue ( double pVal ) {
    HRESULT _hr = put_Value(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(878)
inline double VGCore::IVGTextVariableAxis::GetMinValue ( ) {
    double _result = 0;
    HRESULT _hr = get_MinValue(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(879)
inline double VGCore::IVGTextVariableAxis::GetMaxValue ( ) {
    double _result = 0;
    HRESULT _hr = get_MaxValue(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(880)
inline double VGCore::IVGTextVariableAxis::GetDefaultValue ( ) {
    double _result = 0;
    HRESULT _hr = get_DefaultValue(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface IVGTextVariableAxes wrapper method implementations
//

#pragma implementation_key(881)
inline IUnknownPtr VGCore::IVGTextVariableAxes::Get_NewEnum ( ) {
    IUnknown * _result = 0;
    HRESULT _hr = get__NewEnum(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IUnknownPtr(_result, false);
}

#pragma implementation_key(882)
inline VGCore::IVGTextVariableAxisPtr VGCore::IVGTextVariableAxes::GetItem ( long Index ) {
    struct IVGTextVariableAxis * _result = 0;
    HRESULT _hr = get_Item(Index, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGTextVariableAxisPtr(_result, false);
}

#pragma implementation_key(883)
inline long VGCore::IVGTextVariableAxes::GetCount ( ) {
    long _result = 0;
    HRESULT _hr = get_Count(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface IVGGuide wrapper method implementations
//

#pragma implementation_key(884)
inline enum VGCore::cdrGuideType VGCore::IVGGuide::GetType ( ) {
    enum cdrGuideType _result;
    HRESULT _hr = get_Type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(885)
inline VARIANT_BOOL VGCore::IVGGuide::GetPreset ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_Preset(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(886)
inline HRESULT VGCore::IVGGuide::MakeEditable ( ) {
    HRESULT _hr = raw_MakeEditable();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(887)
inline double VGCore::IVGGuide::GetPoint1X ( ) {
    double _result = 0;
    HRESULT _hr = get_Point1X(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(888)
inline double VGCore::IVGGuide::GetPoint1Y ( ) {
    double _result = 0;
    HRESULT _hr = get_Point1Y(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(889)
inline double VGCore::IVGGuide::GetPoint2X ( ) {
    double _result = 0;
    HRESULT _hr = get_Point2X(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(890)
inline double VGCore::IVGGuide::GetPoint2Y ( ) {
    double _result = 0;
    HRESULT _hr = get_Point2Y(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(891)
inline double VGCore::IVGGuide::GetAngle ( ) {
    double _result = 0;
    HRESULT _hr = get_Angle(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(892)
inline HRESULT VGCore::IVGGuide::GetPoints ( double * Point1X, double * Point1Y, double * Point2X, double * Point2Y ) {
    HRESULT _hr = raw_GetPoints(Point1X, Point1Y, Point2X, Point2Y);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(893)
inline HRESULT VGCore::IVGGuide::GetPointAndAngle ( double * PointX, double * PointY, double * Angle ) {
    HRESULT _hr = raw_GetPointAndAngle(PointX, PointY, Angle);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(894)
inline HRESULT VGCore::IVGGuide::SetPoints ( double Point1X, double Point1Y, double Point2X, double Point2Y ) {
    HRESULT _hr = raw_SetPoints(Point1X, Point1Y, Point2X, Point2Y);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(895)
inline HRESULT VGCore::IVGGuide::SetPointAndAngle ( double PointX, double PointY, double Angle ) {
    HRESULT _hr = raw_SetPointAndAngle(PointX, PointY, Angle);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(896)
inline double VGCore::IVGGuide::GetInterceptX ( ) {
    double _result = 0;
    HRESULT _hr = get_InterceptX(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(897)
inline double VGCore::IVGGuide::GetInterceptY ( ) {
    double _result = 0;
    HRESULT _hr = get_InterceptY(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(898)
inline double VGCore::IVGGuide::GetCenterX ( ) {
    double _result = 0;
    HRESULT _hr = get_CenterX(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(899)
inline double VGCore::IVGGuide::GetCenterY ( ) {
    double _result = 0;
    HRESULT _hr = get_CenterY(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface IVGURL wrapper method implementations
//

#pragma implementation_key(900)
inline _bstr_t VGCore::IVGURL::GetAddress ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Address(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(901)
inline void VGCore::IVGURL::PutAddress ( _bstr_t pVal ) {
    HRESULT _hr = put_Address(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(902)
inline _bstr_t VGCore::IVGURL::GetTargetFrame ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_TargetFrame(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(903)
inline void VGCore::IVGURL::PutTargetFrame ( _bstr_t pVal ) {
    HRESULT _hr = put_TargetFrame(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(904)
inline _bstr_t VGCore::IVGURL::GetAltComment ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_AltComment(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(905)
inline void VGCore::IVGURL::PutAltComment ( _bstr_t pVal ) {
    HRESULT _hr = put_AltComment(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(906)
inline _bstr_t VGCore::IVGURL::GetBookMark ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_BookMark(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(907)
inline void VGCore::IVGURL::PutBookMark ( _bstr_t pVal ) {
    HRESULT _hr = put_BookMark(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(908)
inline enum VGCore::cdrURLRegion VGCore::IVGURL::GetRegion ( ) {
    enum cdrURLRegion _result;
    HRESULT _hr = get_Region(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(909)
inline void VGCore::IVGURL::PutRegion ( enum cdrURLRegion pVal ) {
    HRESULT _hr = put_Region(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IVGCustomShape wrapper method implementations
//

#pragma implementation_key(910)
inline _bstr_t VGCore::IVGCustomShape::GetTypeID ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_TypeID(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

//
// interface IVGOLE wrapper method implementations
//

#pragma implementation_key(911)
inline _bstr_t VGCore::IVGOLE::GetClassID ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_ClassID(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(912)
inline _bstr_t VGCore::IVGOLE::GetProgID ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_ProgID(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(913)
inline enum VGCore::cdrOLEType VGCore::IVGOLE::GetType ( ) {
    enum cdrOLEType _result;
    HRESULT _hr = get_Type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(914)
inline _bstr_t VGCore::IVGOLE::GetFullName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_FullName(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(915)
inline _bstr_t VGCore::IVGOLE::GetShortName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_ShortName(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(916)
inline _bstr_t VGCore::IVGOLE::GetServerName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_ServerName(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(917)
inline VARIANT_BOOL VGCore::IVGOLE::GetModified ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_Modified(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(918)
inline VARIANT_BOOL VGCore::IVGOLE::GetIsInPlaceActive ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsInPlaceActive(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(919)
inline VARIANT_BOOL VGCore::IVGOLE::GetIsOpen ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsOpen(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(920)
inline VARIANT_BOOL VGCore::IVGOLE::GetIsServerRunning ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsServerRunning(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(921)
inline long VGCore::IVGOLE::GetInPlaceWindowHandle ( ) {
    long _result = 0;
    HRESULT _hr = get_InPlaceWindowHandle(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(922)
inline HRESULT VGCore::IVGOLE::Edit ( ) {
    HRESULT _hr = raw_Edit();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(923)
inline HRESULT VGCore::IVGOLE::Open ( ) {
    HRESULT _hr = raw_Open();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(924)
inline HRESULT VGCore::IVGOLE::Activate ( ) {
    HRESULT _hr = raw_Activate();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(925)
inline HRESULT VGCore::IVGOLE::Deactivate ( ) {
    HRESULT _hr = raw_Deactivate();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(926)
inline HRESULT VGCore::IVGOLE::DoVerb ( long VerbID ) {
    HRESULT _hr = raw_DoVerb(VerbID);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(927)
inline VARIANT_BOOL VGCore::IVGOLE::GetIsLinkUpToDate ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsLinkUpToDate(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(928)
inline _bstr_t VGCore::IVGOLE::GetLinkPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_LinkPath(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(929)
inline HRESULT VGCore::IVGOLE::UpdateLink ( ) {
    HRESULT _hr = raw_UpdateLink();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface IVGBSplineControlPoint wrapper method implementations
//

#pragma implementation_key(930)
inline double VGCore::IVGBSplineControlPoint::Getx ( ) {
    double _result = 0;
    HRESULT _hr = get_x(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(931)
inline void VGCore::IVGBSplineControlPoint::Putx ( double pVal ) {
    HRESULT _hr = put_x(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(932)
inline double VGCore::IVGBSplineControlPoint::Gety ( ) {
    double _result = 0;
    HRESULT _hr = get_y(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(933)
inline void VGCore::IVGBSplineControlPoint::Puty ( double pVal ) {
    HRESULT _hr = put_y(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(934)
inline VARIANT_BOOL VGCore::IVGBSplineControlPoint::GetClamped ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_Clamped(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(935)
inline void VGCore::IVGBSplineControlPoint::PutClamped ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_Clamped(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(936)
inline HRESULT VGCore::IVGBSplineControlPoint::Move ( double x, double y ) {
    HRESULT _hr = raw_Move(x, y);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(937)
inline HRESULT VGCore::IVGBSplineControlPoint::Delete ( ) {
    HRESULT _hr = raw_Delete();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(938)
inline HRESULT VGCore::IVGBSplineControlPoint::GetPosition ( double * x, double * y ) {
    HRESULT _hr = raw_GetPosition(x, y);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(939)
inline HRESULT VGCore::IVGBSplineControlPoint::SetPosition ( double x, double y ) {
    HRESULT _hr = raw_SetPosition(x, y);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(940)
inline HRESULT VGCore::IVGBSplineControlPoint::SetProperties ( double x, double y, VARIANT_BOOL Clamped ) {
    HRESULT _hr = raw_SetProperties(x, y, Clamped);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(941)
inline long VGCore::IVGBSplineControlPoint::GetIndex ( ) {
    long _result = 0;
    HRESULT _hr = get_Index(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface IVGBSplineControlPoints wrapper method implementations
//

#pragma implementation_key(942)
inline VGCore::IVGBSplineControlPointPtr VGCore::IVGBSplineControlPoints::GetFirst ( ) {
    struct IVGBSplineControlPoint * _result = 0;
    HRESULT _hr = get_First(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGBSplineControlPointPtr(_result, false);
}

#pragma implementation_key(943)
inline VGCore::IVGBSplineControlPointPtr VGCore::IVGBSplineControlPoints::GetLast ( ) {
    struct IVGBSplineControlPoint * _result = 0;
    HRESULT _hr = get_Last(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGBSplineControlPointPtr(_result, false);
}

#pragma implementation_key(944)
inline VGCore::IVGBSplineControlPointPtr VGCore::IVGBSplineControlPoints::GetItem ( long Index ) {
    struct IVGBSplineControlPoint * _result = 0;
    HRESULT _hr = get_Item(Index, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGBSplineControlPointPtr(_result, false);
}

#pragma implementation_key(945)
inline long VGCore::IVGBSplineControlPoints::GetCount ( ) {
    long _result = 0;
    HRESULT _hr = get_Count(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(946)
inline IUnknownPtr VGCore::IVGBSplineControlPoints::Get_NewEnum ( ) {
    IUnknown * _result = 0;
    HRESULT _hr = get__NewEnum(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IUnknownPtr(_result, false);
}

#pragma implementation_key(947)
inline HRESULT VGCore::IVGBSplineControlPoints::Resize ( long HowMany ) {
    HRESULT _hr = raw_Resize(HowMany);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface IVGBSpline wrapper method implementations
//

#pragma implementation_key(948)
inline VGCore::IVGBSplineControlPointsPtr VGCore::IVGBSpline::GetControlPoints ( ) {
    struct IVGBSplineControlPoints * _result = 0;
    HRESULT _hr = get_ControlPoints(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGBSplineControlPointsPtr(_result, false);
}

#pragma implementation_key(949)
inline VARIANT_BOOL VGCore::IVGBSpline::GetClosed ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_Closed(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(950)
inline void VGCore::IVGBSpline::PutClosed ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_Closed(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(951)
inline HRESULT VGCore::IVGBSpline::InsertControlPoint ( long Index, double x, double y, VARIANT_BOOL Clamped ) {
    HRESULT _hr = raw_InsertControlPoint(Index, x, y, Clamped);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(952)
inline HRESULT VGCore::IVGBSpline::InsertControlPoints ( long Index, long HowMany, double x, double y, VARIANT_BOOL Clamped ) {
    HRESULT _hr = raw_InsertControlPoints(Index, HowMany, x, y, Clamped);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(953)
inline VGCore::IVGBSplinePtr VGCore::IVGBSpline::GetCopy ( ) {
    struct IVGBSpline * _result = 0;
    HRESULT _hr = raw_GetCopy(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGBSplinePtr(_result, false);
}

#pragma implementation_key(954)
inline HRESULT VGCore::IVGBSpline::CopyAssign ( struct IVGBSpline * rhs ) {
    HRESULT _hr = raw_CopyAssign(rhs);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface IStructImportCropOptions wrapper method implementations
//

#pragma implementation_key(955)
inline _bstr_t VGCore::IStructImportCropOptions::GetFileName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_FileName(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(956)
inline long VGCore::IStructImportCropOptions::GetFilterID ( ) {
    long _result = 0;
    HRESULT _hr = get_FilterID(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(957)
inline long VGCore::IStructImportCropOptions::GetCustomData ( ) {
    long _result = 0;
    HRESULT _hr = get_CustomData(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(958)
inline long VGCore::IStructImportCropOptions::GetImageWidth ( ) {
    long _result = 0;
    HRESULT _hr = get_ImageWidth(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(959)
inline long VGCore::IStructImportCropOptions::GetImageHeight ( ) {
    long _result = 0;
    HRESULT _hr = get_ImageHeight(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(960)
inline long VGCore::IStructImportCropOptions::GetDpiX ( ) {
    long _result = 0;
    HRESULT _hr = get_DpiX(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(961)
inline long VGCore::IStructImportCropOptions::GetDpiY ( ) {
    long _result = 0;
    HRESULT _hr = get_DpiY(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(962)
inline long VGCore::IStructImportCropOptions::GetWidth ( ) {
    long _result = 0;
    HRESULT _hr = get_Width(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(963)
inline void VGCore::IStructImportCropOptions::PutWidth ( long pVal ) {
    HRESULT _hr = put_Width(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(964)
inline long VGCore::IStructImportCropOptions::GetHeight ( ) {
    long _result = 0;
    HRESULT _hr = get_Height(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(965)
inline void VGCore::IStructImportCropOptions::PutHeight ( long pVal ) {
    HRESULT _hr = put_Height(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(966)
inline long VGCore::IStructImportCropOptions::GetLeft ( ) {
    long _result = 0;
    HRESULT _hr = get_Left(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(967)
inline void VGCore::IStructImportCropOptions::PutLeft ( long pVal ) {
    HRESULT _hr = put_Left(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(968)
inline long VGCore::IStructImportCropOptions::GetTop ( ) {
    long _result = 0;
    HRESULT _hr = get_Top(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(969)
inline void VGCore::IStructImportCropOptions::PutTop ( long pVal ) {
    HRESULT _hr = put_Top(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IImportCropHandler wrapper method implementations
//

#pragma implementation_key(970)
inline VARIANT_BOOL VGCore::IImportCropHandler::Crop ( struct IStructImportCropOptions * Options ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_Crop(Options, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface IStructImportResampleOptions wrapper method implementations
//

#pragma implementation_key(971)
inline _bstr_t VGCore::IStructImportResampleOptions::GetFileName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_FileName(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(972)
inline long VGCore::IStructImportResampleOptions::GetFilterID ( ) {
    long _result = 0;
    HRESULT _hr = get_FilterID(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(973)
inline long VGCore::IStructImportResampleOptions::GetCustomData ( ) {
    long _result = 0;
    HRESULT _hr = get_CustomData(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(974)
inline long VGCore::IStructImportResampleOptions::GetWidth ( ) {
    long _result = 0;
    HRESULT _hr = get_Width(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(975)
inline void VGCore::IStructImportResampleOptions::PutWidth ( long pVal ) {
    HRESULT _hr = put_Width(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(976)
inline long VGCore::IStructImportResampleOptions::GetHeight ( ) {
    long _result = 0;
    HRESULT _hr = get_Height(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(977)
inline void VGCore::IStructImportResampleOptions::PutHeight ( long pVal ) {
    HRESULT _hr = put_Height(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(978)
inline long VGCore::IStructImportResampleOptions::GetDpiX ( ) {
    long _result = 0;
    HRESULT _hr = get_DpiX(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(979)
inline void VGCore::IStructImportResampleOptions::PutDpiX ( long pVal ) {
    HRESULT _hr = put_DpiX(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(980)
inline long VGCore::IStructImportResampleOptions::GetDpiY ( ) {
    long _result = 0;
    HRESULT _hr = get_DpiY(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(981)
inline void VGCore::IStructImportResampleOptions::PutDpiY ( long pVal ) {
    HRESULT _hr = put_DpiY(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IImportResampleHandler wrapper method implementations
//

#pragma implementation_key(982)
inline VARIANT_BOOL VGCore::IImportResampleHandler::Resample ( struct IStructImportResampleOptions * Options ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_Resample(Options, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface IVGColorManagementPolicy wrapper method implementations
//

#pragma implementation_key(983)
inline enum VGCore::clrColorPolicyAction VGCore::IVGColorManagementPolicy::GetActionForRGB ( ) {
    enum clrColorPolicyAction _result;
    HRESULT _hr = get_ActionForRGB(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(984)
inline void VGCore::IVGColorManagementPolicy::PutActionForRGB ( enum clrColorPolicyAction pVal ) {
    HRESULT _hr = put_ActionForRGB(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(985)
inline enum VGCore::clrColorPolicyAction VGCore::IVGColorManagementPolicy::GetActionForCMYK ( ) {
    enum clrColorPolicyAction _result;
    HRESULT _hr = get_ActionForCMYK(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(986)
inline void VGCore::IVGColorManagementPolicy::PutActionForCMYK ( enum clrColorPolicyAction pVal ) {
    HRESULT _hr = put_ActionForCMYK(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(987)
inline enum VGCore::clrColorPolicyAction VGCore::IVGColorManagementPolicy::GetActionForGrayscale ( ) {
    enum clrColorPolicyAction _result;
    HRESULT _hr = get_ActionForGrayscale(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(988)
inline void VGCore::IVGColorManagementPolicy::PutActionForGrayscale ( enum clrColorPolicyAction pVal ) {
    HRESULT _hr = put_ActionForGrayscale(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(989)
inline VARIANT_BOOL VGCore::IVGColorManagementPolicy::GetWarnOnMismatchedProfiles ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_WarnOnMismatchedProfiles(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(990)
inline void VGCore::IVGColorManagementPolicy::PutWarnOnMismatchedProfiles ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_WarnOnMismatchedProfiles(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(991)
inline VARIANT_BOOL VGCore::IVGColorManagementPolicy::GetWarnOnMissingProfiles ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_WarnOnMissingProfiles(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(992)
inline void VGCore::IVGColorManagementPolicy::PutWarnOnMissingProfiles ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_WarnOnMissingProfiles(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IVGStructColorConversionOptions wrapper method implementations
//

#pragma implementation_key(993)
inline VGCore::IVGColorManagementPolicyPtr VGCore::IVGStructColorConversionOptions::GetColorPolicy ( ) {
    struct IVGColorManagementPolicy * _result = 0;
    HRESULT _hr = get_ColorPolicy(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGColorManagementPolicyPtr(_result, false);
}

#pragma implementation_key(994)
inline _bstr_t VGCore::IVGStructColorConversionOptions::GetSourceColorProfileList ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_SourceColorProfileList(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(995)
inline void VGCore::IVGStructColorConversionOptions::PutSourceColorProfileList ( _bstr_t pVal ) {
    HRESULT _hr = put_SourceColorProfileList(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(996)
inline _bstr_t VGCore::IVGStructColorConversionOptions::GetTargetColorProfileList ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_TargetColorProfileList(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(997)
inline void VGCore::IVGStructColorConversionOptions::PutTargetColorProfileList ( _bstr_t pVal ) {
    HRESULT _hr = put_TargetColorProfileList(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(998)
inline VGCore::IColorConversionHandlerPtr VGCore::IVGStructColorConversionOptions::GetColorConversionHandler ( ) {
    struct IColorConversionHandler * _result = 0;
    HRESULT _hr = get_ColorConversionHandler(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IColorConversionHandlerPtr(_result, false);
}

#pragma implementation_key(999)
inline void VGCore::IVGStructColorConversionOptions::PutRefColorConversionHandler ( struct IColorConversionHandler * * ppVal ) {
    HRESULT _hr = putref_ColorConversionHandler(ppVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IVGStructImportOptions wrapper method implementations
//

#pragma implementation_key(1000)
inline VARIANT_BOOL VGCore::IVGStructImportOptions::GetLinkBitmapExternally ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_LinkBitmapExternally(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1001)
inline void VGCore::IVGStructImportOptions::PutLinkBitmapExternally ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_LinkBitmapExternally(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(1002)
inline VARIANT_BOOL VGCore::IVGStructImportOptions::GetCombineMultilayerBitmaps ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_CombineMultilayerBitmaps(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1003)
inline void VGCore::IVGStructImportOptions::PutCombineMultilayerBitmaps ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_CombineMultilayerBitmaps(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(1004)
inline VARIANT_BOOL VGCore::IVGStructImportOptions::GetExtractICCProfile ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_ExtractICCProfile(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1005)
inline void VGCore::IVGStructImportOptions::PutExtractICCProfile ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_ExtractICCProfile(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(1006)
inline _bstr_t VGCore::IVGStructImportOptions::GetICCFileName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_ICCFileName(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(1007)
inline void VGCore::IVGStructImportOptions::PutICCFileName ( _bstr_t pVal ) {
    HRESULT _hr = put_ICCFileName(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(1008)
inline VARIANT_BOOL VGCore::IVGStructImportOptions::GetMaintainLayers ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_MaintainLayers(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1009)
inline void VGCore::IVGStructImportOptions::PutMaintainLayers ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_MaintainLayers(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(1010)
inline VARIANT_BOOL VGCore::IVGStructImportOptions::GetUseOPILinks ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_UseOPILinks(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1011)
inline void VGCore::IVGStructImportOptions::PutUseOPILinks ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_UseOPILinks(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(1012)
inline VARIANT_BOOL VGCore::IVGStructImportOptions::GetDetectWatermark ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_DetectWatermark(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1013)
inline void VGCore::IVGStructImportOptions::PutDetectWatermark ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_DetectWatermark(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(1014)
inline enum VGCore::cdrImportMode VGCore::IVGStructImportOptions::GetMode ( ) {
    enum cdrImportMode _result;
    HRESULT _hr = get_Mode(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1015)
inline void VGCore::IVGStructImportOptions::PutMode ( enum cdrImportMode pVal ) {
    HRESULT _hr = put_Mode(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(1016)
inline long VGCore::IVGStructImportOptions::GetCustomData ( ) {
    long _result = 0;
    HRESULT _hr = get_CustomData(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1017)
inline void VGCore::IVGStructImportOptions::PutCustomData ( long pVal ) {
    HRESULT _hr = put_CustomData(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(1018)
inline long VGCore::IVGStructImportOptions::GetImageIndex ( ) {
    long _result = 0;
    HRESULT _hr = get_ImageIndex(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1019)
inline void VGCore::IVGStructImportOptions::PutImageIndex ( long pVal ) {
    HRESULT _hr = put_ImageIndex(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(1020)
inline VGCore::IImportCropHandlerPtr VGCore::IVGStructImportOptions::GetCropHandler ( ) {
    struct IImportCropHandler * _result = 0;
    HRESULT _hr = get_CropHandler(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IImportCropHandlerPtr(_result, false);
}

#pragma implementation_key(1021)
inline void VGCore::IVGStructImportOptions::PutRefCropHandler ( struct IImportCropHandler * * ppVal ) {
    HRESULT _hr = putref_CropHandler(ppVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(1022)
inline VGCore::IImportResampleHandlerPtr VGCore::IVGStructImportOptions::GetResampleHandler ( ) {
    struct IImportResampleHandler * _result = 0;
    HRESULT _hr = get_ResampleHandler(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IImportResampleHandlerPtr(_result, false);
}

#pragma implementation_key(1023)
inline void VGCore::IVGStructImportOptions::PutRefResampleHandler ( struct IImportResampleHandler * * ppVal ) {
    HRESULT _hr = putref_ResampleHandler(ppVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(1024)
inline enum VGCore::cdrImportTextFormatting VGCore::IVGStructImportOptions::GetTextFormatting ( ) {
    enum cdrImportTextFormatting _result;
    HRESULT _hr = get_TextFormatting(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1025)
inline void VGCore::IVGStructImportOptions::PutTextFormatting ( enum cdrImportTextFormatting pVal ) {
    HRESULT _hr = put_TextFormatting(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(1026)
inline enum VGCore::cdrImportTableOutline VGCore::IVGStructImportOptions::GetTableOutline ( ) {
    enum cdrImportTableOutline _result;
    HRESULT _hr = get_TableOutline(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1027)
inline void VGCore::IVGStructImportOptions::PutTableOutline ( enum cdrImportTableOutline pVal ) {
    HRESULT _hr = put_TableOutline(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(1028)
inline long VGCore::IVGStructImportOptions::GetCodePage ( ) {
    long _result = 0;
    HRESULT _hr = get_CodePage(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1029)
inline void VGCore::IVGStructImportOptions::PutCodePage ( long pVal ) {
    HRESULT _hr = put_CodePage(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(1030)
inline long VGCore::IVGStructImportOptions::GetResampleWidth ( ) {
    long _result = 0;
    HRESULT _hr = get_ResampleWidth(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1031)
inline void VGCore::IVGStructImportOptions::PutResampleWidth ( long pVal ) {
    HRESULT _hr = put_ResampleWidth(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(1032)
inline long VGCore::IVGStructImportOptions::GetResampleHeight ( ) {
    long _result = 0;
    HRESULT _hr = get_ResampleHeight(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1033)
inline void VGCore::IVGStructImportOptions::PutResampleHeight ( long pVal ) {
    HRESULT _hr = put_ResampleHeight(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(1034)
inline long VGCore::IVGStructImportOptions::GetCropLeft ( ) {
    long _result = 0;
    HRESULT _hr = get_CropLeft(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1035)
inline void VGCore::IVGStructImportOptions::PutCropLeft ( long pVal ) {
    HRESULT _hr = put_CropLeft(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(1036)
inline long VGCore::IVGStructImportOptions::GetCropTop ( ) {
    long _result = 0;
    HRESULT _hr = get_CropTop(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1037)
inline void VGCore::IVGStructImportOptions::PutCropTop ( long pVal ) {
    HRESULT _hr = put_CropTop(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(1038)
inline long VGCore::IVGStructImportOptions::GetCropWidth ( ) {
    long _result = 0;
    HRESULT _hr = get_CropWidth(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1039)
inline void VGCore::IVGStructImportOptions::PutCropWidth ( long pVal ) {
    HRESULT _hr = put_CropWidth(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(1040)
inline long VGCore::IVGStructImportOptions::GetCropHeight ( ) {
    long _result = 0;
    HRESULT _hr = get_CropHeight(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1041)
inline void VGCore::IVGStructImportOptions::PutCropHeight ( long pVal ) {
    HRESULT _hr = put_CropHeight(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(1042)
inline long VGCore::IVGStructImportOptions::GetResampleDpiX ( ) {
    long _result = 0;
    HRESULT _hr = get_ResampleDpiX(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1043)
inline void VGCore::IVGStructImportOptions::PutResampleDpiX ( long pVal ) {
    HRESULT _hr = put_ResampleDpiX(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(1044)
inline long VGCore::IVGStructImportOptions::GetResampleDpiY ( ) {
    long _result = 0;
    HRESULT _hr = get_ResampleDpiY(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1045)
inline void VGCore::IVGStructImportOptions::PutResampleDpiY ( long pVal ) {
    HRESULT _hr = put_ResampleDpiY(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(1046)
inline VARIANT_BOOL VGCore::IVGStructImportOptions::GetForceCMYKBlackText ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_ForceCMYKBlackText(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1047)
inline void VGCore::IVGStructImportOptions::PutForceCMYKBlackText ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_ForceCMYKBlackText(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(1048)
inline VARIANT_BOOL VGCore::IVGStructImportOptions::GetConvertTablesToText ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_ConvertTablesToText(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1049)
inline void VGCore::IVGStructImportOptions::PutConvertTablesToText ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_ConvertTablesToText(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(1050)
inline _bstr_t VGCore::IVGStructImportOptions::GetTableColumnDelimiter ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_TableColumnDelimiter(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(1051)
inline void VGCore::IVGStructImportOptions::PutTableColumnDelimiter ( _bstr_t pVal ) {
    HRESULT _hr = put_TableColumnDelimiter(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(1052)
inline VGCore::IVGStructColorConversionOptionsPtr VGCore::IVGStructImportOptions::GetColorConversionOptions ( ) {
    struct IVGStructColorConversionOptions * _result = 0;
    HRESULT _hr = get_ColorConversionOptions(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGStructColorConversionOptionsPtr(_result, false);
}

//
// interface IVGStructPasteOptions wrapper method implementations
//

#pragma implementation_key(1053)
inline VGCore::IVGStructColorConversionOptionsPtr VGCore::IVGStructPasteOptions::GetColorConversionOptions ( ) {
    struct IVGStructColorConversionOptions * _result = 0;
    HRESULT _hr = get_ColorConversionOptions(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGStructColorConversionOptionsPtr(_result, false);
}

//
// interface IVGCommentAuthor wrapper method implementations
//

#pragma implementation_key(1054)
inline _bstr_t VGCore::IVGCommentAuthor::GetEmail ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Email(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(1055)
inline _bstr_t VGCore::IVGCommentAuthor::GetAvatar ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Avatar(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(1056)
inline enum VGCore::cdrAuthorAuthentication VGCore::IVGCommentAuthor::GetAuthentication ( ) {
    enum cdrAuthorAuthentication _result;
    HRESULT _hr = get_Authentication(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1057)
inline _bstr_t VGCore::IVGCommentAuthor::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(1058)
inline _bstr_t VGCore::IVGCommentAuthor::GetOnlineID ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_OnlineID(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(1059)
inline void VGCore::IVGCommentAuthor::PutOnlineID ( _bstr_t pRet ) {
    HRESULT _hr = put_OnlineID(pRet);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface ICorelScriptTools wrapper method implementations
//

#pragma implementation_key(1060)
inline double VGCore::ICorelScriptTools::AngleConvert ( long FromUnit, long ToUnit, double Value ) {
    double _result = 0;
    HRESULT _hr = raw_AngleConvert(FromUnit, ToUnit, Value, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1061)
inline double VGCore::ICorelScriptTools::ASin ( double Value ) {
    double _result = 0;
    HRESULT _hr = raw_ASin(Value, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1062)
inline HRESULT VGCore::ICorelScriptTools::BeginWaitCursor ( ) {
    HRESULT _hr = raw_BeginWaitCursor();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(1063)
inline HRESULT VGCore::ICorelScriptTools::EndWaitCursor ( ) {
    HRESULT _hr = raw_EndWaitCursor();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(1064)
inline DATE VGCore::ICorelScriptTools::BuildDate ( long Year, long Month, long Day ) {
    DATE _result = 0;
    HRESULT _hr = raw_BuildDate(Year, Month, Day, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1065)
inline DATE VGCore::ICorelScriptTools::BuildTime ( long Hour, long Minute, long Second ) {
    DATE _result = 0;
    HRESULT _hr = raw_BuildTime(Hour, Minute, Second, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1066)
inline long VGCore::ICorelScriptTools::Dec ( _bstr_t Hex ) {
    long _result = 0;
    HRESULT _hr = raw_Dec(Hex, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1067)
inline long VGCore::ICorelScriptTools::FileAttr ( _bstr_t FolderFile ) {
    long _result = 0;
    HRESULT _hr = raw_FileAttr(FolderFile, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1068)
inline _bstr_t VGCore::ICorelScriptTools::FindFirstFolder ( _bstr_t SearchCriteria, long Attributes ) {
    BSTR _result = 0;
    HRESULT _hr = raw_FindFirstFolder(SearchCriteria, Attributes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(1069)
inline _bstr_t VGCore::ICorelScriptTools::FindNextFolder ( ) {
    BSTR _result = 0;
    HRESULT _hr = raw_FindNextFolder(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(1070)
inline _bstr_t VGCore::ICorelScriptTools::FormatTime ( DATE Time, _bstr_t Format ) {
    BSTR _result = 0;
    HRESULT _hr = raw_FormatTime(Time, Format, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(1071)
inline double VGCore::ICorelScriptTools::FromCentimeters ( double Value ) {
    double _result = 0;
    HRESULT _hr = raw_FromCentimeters(Value, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1072)
inline double VGCore::ICorelScriptTools::FromCiceros ( double Value ) {
    double _result = 0;
    HRESULT _hr = raw_FromCiceros(Value, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1073)
inline double VGCore::ICorelScriptTools::FromDidots ( double Value ) {
    double _result = 0;
    HRESULT _hr = raw_FromDidots(Value, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1074)
inline double VGCore::ICorelScriptTools::FromInches ( double Value ) {
    double _result = 0;
    HRESULT _hr = raw_FromInches(Value, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1075)
inline double VGCore::ICorelScriptTools::FromPicas ( double Value ) {
    double _result = 0;
    HRESULT _hr = raw_FromPicas(Value, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1076)
inline double VGCore::ICorelScriptTools::FromPoints ( double Value ) {
    double _result = 0;
    HRESULT _hr = raw_FromPoints(Value, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1077)
inline long VGCore::ICorelScriptTools::GetAppHandle ( ) {
    long _result = 0;
    HRESULT _hr = raw_GetAppHandle(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1078)
inline VARIANT_BOOL VGCore::ICorelScriptTools::GetColor ( long * Red, long * Green, long * Blue ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_GetColor(Red, Green, Blue, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1079)
inline _bstr_t VGCore::ICorelScriptTools::GetCommandLine ( ) {
    BSTR _result = 0;
    HRESULT _hr = raw_GetCommandLine(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(1080)
inline _bstr_t VGCore::ICorelScriptTools::GetCurrFolder ( ) {
    BSTR _result = 0;
    HRESULT _hr = raw_GetCurrFolder(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(1081)
inline HRESULT VGCore::ICorelScriptTools::GetDateInfo ( DATE Date, long * Year, long * Month, long * Day, long * DayOfWeek ) {
    HRESULT _hr = raw_GetDateInfo(Date, Year, Month, Day, DayOfWeek);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(1082)
inline _bstr_t VGCore::ICorelScriptTools::GetFileBox ( _bstr_t Filter, _bstr_t Title, long Type, _bstr_t File, _bstr_t Extension, _bstr_t Folder, _bstr_t Button ) {
    BSTR _result = 0;
    HRESULT _hr = raw_GetFileBox(Filter, Title, Type, File, Extension, Folder, Button, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(1083)
inline _bstr_t VGCore::ICorelScriptTools::GetFolder ( _bstr_t InitFolder, _bstr_t Title, long ParentWindowHandle ) {
    BSTR _result = 0;
    HRESULT _hr = raw_GetFolder(InitFolder, Title, ParentWindowHandle, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(1084)
inline VARIANT_BOOL VGCore::ICorelScriptTools::GetFont ( BSTR * FaceName, long * PointSize, long * Weight, VARIANT_BOOL * Italic, VARIANT_BOOL * Underline, VARIANT_BOOL * StrikeOut, long * Red, long * Green, long * Blue ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_GetFont(FaceName, PointSize, Weight, Italic, Underline, StrikeOut, Red, Green, Blue, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1085)
inline long VGCore::ICorelScriptTools::GetProcessInfo ( long ProcessHandle ) {
    long _result = 0;
    HRESULT _hr = raw_GetProcessInfo(ProcessHandle, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1086)
inline _bstr_t VGCore::ICorelScriptTools::GetScriptFolder ( ) {
    BSTR _result = 0;
    HRESULT _hr = raw_GetScriptFolder(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(1087)
inline _bstr_t VGCore::ICorelScriptTools::GetTempFolder ( ) {
    BSTR _result = 0;
    HRESULT _hr = raw_GetTempFolder(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(1088)
inline HRESULT VGCore::ICorelScriptTools::GetTimeInfo ( DATE Time, long * Hour, long * Minute, long * Second ) {
    HRESULT _hr = raw_GetTimeInfo(Time, Hour, Minute, Second);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(1089)
inline long VGCore::ICorelScriptTools::GetType ( const _variant_t & Expression ) {
    long _result = 0;
    HRESULT _hr = raw_GetType(Expression, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1090)
inline long VGCore::ICorelScriptTools::GetVersion ( long Option ) {
    long _result = 0;
    HRESULT _hr = raw_GetVersion(Option, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1091)
inline long VGCore::ICorelScriptTools::GetWinHandle ( ) {
    long _result = 0;
    HRESULT _hr = raw_GetWinHandle(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1092)
inline VARIANT_BOOL VGCore::ICorelScriptTools::Kill ( _bstr_t FileName ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_Kill(FileName, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1093)
inline double VGCore::ICorelScriptTools::LengthConvert ( long FromUnit, long ToUnit, double Value ) {
    double _result = 0;
    HRESULT _hr = raw_LengthConvert(FromUnit, ToUnit, Value, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1094)
inline double VGCore::ICorelScriptTools::Log ( double Value ) {
    double _result = 0;
    HRESULT _hr = raw_Log(Value, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1095)
inline VARIANT_BOOL VGCore::ICorelScriptTools::MkFolder ( _bstr_t Folder ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_MkFolder(Folder, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1096)
inline _variant_t VGCore::ICorelScriptTools::RegistryQuery ( long MainKey, _bstr_t SubKey, _bstr_t Value ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = raw_RegistryQuery(MainKey, SubKey, Value, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

#pragma implementation_key(1097)
inline VARIANT_BOOL VGCore::ICorelScriptTools::Rename ( _bstr_t Src, _bstr_t Dst, long Overwrite ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_Rename(Src, Dst, Overwrite, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1098)
inline VARIANT_BOOL VGCore::ICorelScriptTools::RmFolder ( _bstr_t Folder ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_RmFolder(Folder, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1099)
inline double VGCore::ICorelScriptTools::ToCentimeters ( double Value ) {
    double _result = 0;
    HRESULT _hr = raw_ToCentimeters(Value, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1100)
inline double VGCore::ICorelScriptTools::ToCiceros ( double Value ) {
    double _result = 0;
    HRESULT _hr = raw_ToCiceros(Value, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1101)
inline double VGCore::ICorelScriptTools::ToDidots ( double Value ) {
    double _result = 0;
    HRESULT _hr = raw_ToDidots(Value, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1102)
inline double VGCore::ICorelScriptTools::ToInches ( double Value ) {
    double _result = 0;
    HRESULT _hr = raw_ToInches(Value, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1103)
inline double VGCore::ICorelScriptTools::ToPicas ( double Value ) {
    double _result = 0;
    HRESULT _hr = raw_ToPicas(Value, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1104)
inline double VGCore::ICorelScriptTools::ToPoints ( double Value ) {
    double _result = 0;
    HRESULT _hr = raw_ToPoints(Value, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface IVGFontList wrapper method implementations
//

#pragma implementation_key(1105)
inline IDispatchPtr VGCore::IVGFontList::GetApplication ( ) {
    IDispatch * _result = 0;
    HRESULT _hr = get_Application(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IDispatchPtr(_result, false);
}

#pragma implementation_key(1106)
inline IDispatchPtr VGCore::IVGFontList::GetParent ( ) {
    IDispatch * _result = 0;
    HRESULT _hr = get_Parent(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IDispatchPtr(_result, false);
}

#pragma implementation_key(1107)
inline _bstr_t VGCore::IVGFontList::GetItem ( long Index ) {
    BSTR _result = 0;
    HRESULT _hr = get_Item(Index, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(1108)
inline IUnknownPtr VGCore::IVGFontList::Get_NewEnum ( ) {
    IUnknown * _result = 0;
    HRESULT _hr = get__NewEnum(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IUnknownPtr(_result, false);
}

#pragma implementation_key(1109)
inline long VGCore::IVGFontList::GetCount ( ) {
    long _result = 0;
    HRESULT _hr = get_Count(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface IVGAppWindow wrapper method implementations
//

#pragma implementation_key(1110)
inline IDispatchPtr VGCore::IVGAppWindow::GetApplication ( ) {
    IDispatch * _result = 0;
    HRESULT _hr = get_Application(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IDispatchPtr(_result, false);
}

#pragma implementation_key(1111)
inline IDispatchPtr VGCore::IVGAppWindow::GetParent ( ) {
    IDispatch * _result = 0;
    HRESULT _hr = get_Parent(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IDispatchPtr(_result, false);
}

#pragma implementation_key(1112)
inline HRESULT VGCore::IVGAppWindow::Activate ( ) {
    HRESULT _hr = raw_Activate();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(1113)
inline VARIANT_BOOL VGCore::IVGAppWindow::GetActive ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_Active(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1114)
inline _bstr_t VGCore::IVGAppWindow::GetCaption ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Caption(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(1115)
inline void VGCore::IVGAppWindow::PutCaption ( _bstr_t pVal ) {
    HRESULT _hr = put_Caption(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(1116)
inline long VGCore::IVGAppWindow::GetHeight ( ) {
    long _result = 0;
    HRESULT _hr = get_Height(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1117)
inline void VGCore::IVGAppWindow::PutHeight ( long pVal ) {
    HRESULT _hr = put_Height(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(1118)
inline long VGCore::IVGAppWindow::GetWidth ( ) {
    long _result = 0;
    HRESULT _hr = get_Width(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1119)
inline void VGCore::IVGAppWindow::PutWidth ( long pVal ) {
    HRESULT _hr = put_Width(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(1120)
inline long VGCore::IVGAppWindow::GetLeft ( ) {
    long _result = 0;
    HRESULT _hr = get_Left(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1121)
inline void VGCore::IVGAppWindow::PutLeft ( long pVal ) {
    HRESULT _hr = put_Left(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(1122)
inline long VGCore::IVGAppWindow::GetTop ( ) {
    long _result = 0;
    HRESULT _hr = get_Top(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1123)
inline void VGCore::IVGAppWindow::PutTop ( long pVal ) {
    HRESULT _hr = put_Top(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(1124)
inline enum VGCore::cdrWindowState VGCore::IVGAppWindow::GetWindowState ( ) {
    enum cdrWindowState _result;
    HRESULT _hr = get_WindowState(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1125)
inline void VGCore::IVGAppWindow::PutWindowState ( enum cdrWindowState pVal ) {
    HRESULT _hr = put_WindowState(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(1126)
inline long VGCore::IVGAppWindow::GetClientWidth ( ) {
    long _result = 0;
    HRESULT _hr = get_ClientWidth(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1127)
inline long VGCore::IVGAppWindow::GetClientHeight ( ) {
    long _result = 0;
    HRESULT _hr = get_ClientHeight(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1128)
inline long VGCore::IVGAppWindow::GetHandle ( ) {
    long _result = 0;
    HRESULT _hr = get_Handle(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface IVGPatternCanvases wrapper method implementations
//

#pragma implementation_key(1129)
inline VGCore::IVGPatternCanvasPtr VGCore::IVGPatternCanvases::GetItem ( long Index ) {
    struct IVGPatternCanvas * _result = 0;
    HRESULT _hr = get_Item(Index, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGPatternCanvasPtr(_result, false);
}

#pragma implementation_key(1130)
inline void VGCore::IVGPatternCanvases::PutItem ( long Index, struct IVGPatternCanvas * ppVal ) {
    HRESULT _hr = put_Item(Index, ppVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(1131)
inline IUnknownPtr VGCore::IVGPatternCanvases::Get_NewEnum ( ) {
    IUnknown * _result = 0;
    HRESULT _hr = get__NewEnum(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IUnknownPtr(_result, false);
}

#pragma implementation_key(1132)
inline long VGCore::IVGPatternCanvases::GetCount ( ) {
    long _result = 0;
    HRESULT _hr = get_Count(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1133)
inline long VGCore::IVGPatternCanvases::Add ( struct IVGPatternCanvas * PatternCanvas ) {
    long _result = 0;
    HRESULT _hr = raw_Add(PatternCanvas, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1134)
inline HRESULT VGCore::IVGPatternCanvases::Remove ( long Index ) {
    HRESULT _hr = raw_Remove(Index);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface IVGClipboard wrapper method implementations
//

#pragma implementation_key(1135)
inline IDispatchPtr VGCore::IVGClipboard::GetApplication ( ) {
    IDispatch * _result = 0;
    HRESULT _hr = get_Application(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IDispatchPtr(_result, false);
}

#pragma implementation_key(1136)
inline IDispatchPtr VGCore::IVGClipboard::GetParent ( ) {
    IDispatch * _result = 0;
    HRESULT _hr = get_Parent(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IDispatchPtr(_result, false);
}

#pragma implementation_key(1137)
inline VARIANT_BOOL VGCore::IVGClipboard::GetValid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_Valid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1138)
inline VARIANT_BOOL VGCore::IVGClipboard::GetEmpty ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_Empty(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1139)
inline HRESULT VGCore::IVGClipboard::Clear ( ) {
    HRESULT _hr = raw_Clear();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(1140)
inline VARIANT_BOOL VGCore::IVGClipboard::DataPresent ( _bstr_t FormatName ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_DataPresent(FormatName, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface IVGGMSMacro wrapper method implementations
//

#pragma implementation_key(1141)
inline _bstr_t VGCore::IVGGMSMacro::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(1142)
inline HRESULT VGCore::IVGGMSMacro::Run ( ) {
    HRESULT _hr = raw_Run();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(1143)
inline HRESULT VGCore::IVGGMSMacro::Edit ( ) {
    HRESULT _hr = raw_Edit();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(1144)
inline HRESULT VGCore::IVGGMSMacro::Delete ( ) {
    HRESULT _hr = raw_Delete();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface IVGGMSMacros wrapper method implementations
//

#pragma implementation_key(1145)
inline IUnknownPtr VGCore::IVGGMSMacros::Get_NewEnum ( ) {
    IUnknown * _result = 0;
    HRESULT _hr = get__NewEnum(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IUnknownPtr(_result, false);
}

#pragma implementation_key(1146)
inline VGCore::IVGGMSMacroPtr VGCore::IVGGMSMacros::GetItem ( const _variant_t & IndexOrName ) {
    struct IVGGMSMacro * _result = 0;
    HRESULT _hr = get_Item(IndexOrName, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGGMSMacroPtr(_result, false);
}

#pragma implementation_key(1147)
inline long VGCore::IVGGMSMacros::GetCount ( ) {
    long _result = 0;
    HRESULT _hr = get_Count(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1148)
inline VGCore::IVGGMSMacroPtr VGCore::IVGGMSMacros::Create ( _bstr_t Name ) {
    struct IVGGMSMacro * _result = 0;
    HRESULT _hr = raw_Create(Name, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGGMSMacroPtr(_result, false);
}

//
// interface IVGGMSProject wrapper method implementations
//

#pragma implementation_key(1149)
inline _bstr_t VGCore::IVGGMSProject::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(1150)
inline void VGCore::IVGGMSProject::PutName ( _bstr_t pVal ) {
    HRESULT _hr = put_Name(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(1151)
inline _bstr_t VGCore::IVGGMSProject::GetDisplayName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_DisplayName(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(1152)
inline VGCore::IVGGMSMacrosPtr VGCore::IVGGMSProject::GetMacros ( ) {
    struct IVGGMSMacros * _result = 0;
    HRESULT _hr = get_Macros(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGGMSMacrosPtr(_result, false);
}

#pragma implementation_key(1153)
inline HRESULT VGCore::IVGGMSProject::Unload ( ) {
    HRESULT _hr = raw_Unload();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(1154)
inline _bstr_t VGCore::IVGGMSProject::GetFileName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_FileName(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(1155)
inline _bstr_t VGCore::IVGGMSProject::GetFilePath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_FilePath(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(1156)
inline _bstr_t VGCore::IVGGMSProject::GetFullFileName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_FullFileName(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(1157)
inline VARIANT_BOOL VGCore::IVGGMSProject::GetDirty ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_Dirty(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1158)
inline void VGCore::IVGGMSProject::PutDirty ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_Dirty(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(1159)
inline VARIANT_BOOL VGCore::IVGGMSProject::GetLocked ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_Locked(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1160)
inline VARIANT_BOOL VGCore::IVGGMSProject::GetPasswordProtected ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_PasswordProtected(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface IVGGMSProjects wrapper method implementations
//

#pragma implementation_key(1161)
inline IUnknownPtr VGCore::IVGGMSProjects::Get_NewEnum ( ) {
    IUnknown * _result = 0;
    HRESULT _hr = get__NewEnum(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IUnknownPtr(_result, false);
}

#pragma implementation_key(1162)
inline VGCore::IVGGMSProjectPtr VGCore::IVGGMSProjects::GetItem ( const _variant_t & IndexOrName ) {
    struct IVGGMSProject * _result = 0;
    HRESULT _hr = get_Item(IndexOrName, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGGMSProjectPtr(_result, false);
}

#pragma implementation_key(1163)
inline long VGCore::IVGGMSProjects::GetCount ( ) {
    long _result = 0;
    HRESULT _hr = get_Count(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1164)
inline VGCore::IVGGMSProjectPtr VGCore::IVGGMSProjects::Load ( _bstr_t FileName, VARIANT_BOOL CopyFile, VARIANT_BOOL ForAllUsers ) {
    struct IVGGMSProject * _result = 0;
    HRESULT _hr = raw_Load(FileName, CopyFile, ForAllUsers, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGGMSProjectPtr(_result, false);
}

#pragma implementation_key(1165)
inline VGCore::IVGGMSProjectPtr VGCore::IVGGMSProjects::Create ( _bstr_t Name, VARIANT_BOOL ForAllUsers, _bstr_t FileName ) {
    struct IVGGMSProject * _result = 0;
    HRESULT _hr = raw_Create(Name, ForAllUsers, FileName, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGGMSProjectPtr(_result, false);
}

//
// interface IVGGMSManager wrapper method implementations
//

#pragma implementation_key(1166)
inline _bstr_t VGCore::IVGGMSManager::GetGMSPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_GMSPath(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(1167)
inline _variant_t VGCore::IVGGMSManager::RunMacro ( _bstr_t ModuleName, _bstr_t MacroName, SAFEARRAY * * Parameters ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = raw_RunMacro(ModuleName, MacroName, Parameters, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

#pragma implementation_key(1168)
inline _bstr_t VGCore::IVGGMSManager::GetUserGMSPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_UserGMSPath(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(1169)
inline VGCore::IVGGMSProjectsPtr VGCore::IVGGMSManager::GetProjects ( ) {
    struct IVGGMSProjects * _result = 0;
    HRESULT _hr = get_Projects(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGGMSProjectsPtr(_result, false);
}

//
// interface IVGStructSaveAsOptions wrapper method implementations
//

#pragma implementation_key(1170)
inline void VGCore::IVGStructSaveAsOptions::PutFilter ( enum cdrFilter pVal ) {
    HRESULT _hr = put_Filter(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(1171)
inline enum VGCore::cdrFilter VGCore::IVGStructSaveAsOptions::GetFilter ( ) {
    enum cdrFilter _result;
    HRESULT _hr = get_Filter(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1172)
inline void VGCore::IVGStructSaveAsOptions::PutVersion ( enum cdrFileVersion pVal ) {
    HRESULT _hr = put_Version(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(1173)
inline enum VGCore::cdrFileVersion VGCore::IVGStructSaveAsOptions::GetVersion ( ) {
    enum cdrFileVersion _result;
    HRESULT _hr = get_Version(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1174)
inline void VGCore::IVGStructSaveAsOptions::PutThumbnailSize ( enum cdrThumbnailSize pVal ) {
    HRESULT _hr = put_ThumbnailSize(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(1175)
inline enum VGCore::cdrThumbnailSize VGCore::IVGStructSaveAsOptions::GetThumbnailSize ( ) {
    enum cdrThumbnailSize _result;
    HRESULT _hr = get_ThumbnailSize(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1176)
inline void VGCore::IVGStructSaveAsOptions::PutRange ( enum cdrExportRange pVal ) {
    HRESULT _hr = put_Range(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(1177)
inline enum VGCore::cdrExportRange VGCore::IVGStructSaveAsOptions::GetRange ( ) {
    enum cdrExportRange _result;
    HRESULT _hr = get_Range(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1178)
inline void VGCore::IVGStructSaveAsOptions::PutOverwrite ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_Overwrite(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(1179)
inline VARIANT_BOOL VGCore::IVGStructSaveAsOptions::GetOverwrite ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_Overwrite(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1180)
inline void VGCore::IVGStructSaveAsOptions::PutEmbedICCProfile ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_EmbedICCProfile(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(1181)
inline VARIANT_BOOL VGCore::IVGStructSaveAsOptions::GetEmbedICCProfile ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_EmbedICCProfile(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1182)
inline void VGCore::IVGStructSaveAsOptions::PutEmbedVBAProject ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_EmbedVBAProject(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(1183)
inline VARIANT_BOOL VGCore::IVGStructSaveAsOptions::GetEmbedVBAProject ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_EmbedVBAProject(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1184)
inline void VGCore::IVGStructSaveAsOptions::PutIncludeCMXData ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_IncludeCMXData(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(1185)
inline VARIANT_BOOL VGCore::IVGStructSaveAsOptions::GetIncludeCMXData ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IncludeCMXData(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1186)
inline void VGCore::IVGStructSaveAsOptions::PutKeepAppearance ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_KeepAppearance(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(1187)
inline VARIANT_BOOL VGCore::IVGStructSaveAsOptions::GetKeepAppearance ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_KeepAppearance(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface IVGComponent wrapper method implementations
//

#pragma implementation_key(1188)
inline _bstr_t VGCore::IVGComponent::GetComponentID ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_ComponentID(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

//
// interface IVGComponents wrapper method implementations
//

#pragma implementation_key(1189)
inline IUnknownPtr VGCore::IVGComponents::Get_NewEnum ( ) {
    IUnknown * _result = 0;
    HRESULT _hr = get__NewEnum(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IUnknownPtr(_result, false);
}

#pragma implementation_key(1190)
inline VGCore::IVGComponentPtr VGCore::IVGComponents::GetItem ( const _variant_t & IndexOrName ) {
    struct IVGComponent * _result = 0;
    HRESULT _hr = get_Item(IndexOrName, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGComponentPtr(_result, false);
}

#pragma implementation_key(1191)
inline long VGCore::IVGComponents::GetCount ( ) {
    long _result = 0;
    HRESULT _hr = get_Count(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1192)
inline VARIANT_BOOL VGCore::IVGComponents::IsComponentInstalled ( _bstr_t ComponentID ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_IsComponentInstalled(ComponentID, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface IVGAppStatus wrapper method implementations
//

#pragma implementation_key(1193)
inline HRESULT VGCore::IVGAppStatus::BeginProgress ( _bstr_t Message, VARIANT_BOOL CanAbort ) {
    HRESULT _hr = raw_BeginProgress(Message, CanAbort);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(1194)
inline HRESULT VGCore::IVGAppStatus::UpdateProgress ( long Step ) {
    HRESULT _hr = raw_UpdateProgress(Step);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(1195)
inline HRESULT VGCore::IVGAppStatus::SetProgressMessage ( _bstr_t Message ) {
    HRESULT _hr = raw_SetProgressMessage(Message);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(1196)
inline HRESULT VGCore::IVGAppStatus::EndProgress ( ) {
    HRESULT _hr = raw_EndProgress();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(1197)
inline long VGCore::IVGAppStatus::GetProgress ( ) {
    long _result = 0;
    HRESULT _hr = get_Progress(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1198)
inline void VGCore::IVGAppStatus::PutProgress ( long pVal ) {
    HRESULT _hr = put_Progress(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(1199)
inline VARIANT_BOOL VGCore::IVGAppStatus::GetAborted ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_Aborted(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface IVGStructOpenOptions wrapper method implementations
//

#pragma implementation_key(1200)
inline long VGCore::IVGStructOpenOptions::GetCodePage ( ) {
    long _result = 0;
    HRESULT _hr = get_CodePage(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1201)
inline void VGCore::IVGStructOpenOptions::PutCodePage ( long pVal ) {
    HRESULT _hr = put_CodePage(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(1202)
inline VGCore::IVGStructColorConversionOptionsPtr VGCore::IVGStructOpenOptions::GetColorConversionOptions ( ) {
    struct IVGStructColorConversionOptions * _result = 0;
    HRESULT _hr = get_ColorConversionOptions(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGStructColorConversionOptionsPtr(_result, false);
}

//
// interface IVGOnScreenHandle wrapper method implementations
//

#pragma implementation_key(1203)
inline HRESULT VGCore::IVGOnScreenHandle::Show ( ) {
    HRESULT _hr = raw_Show();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(1204)
inline HRESULT VGCore::IVGOnScreenHandle::Hide ( ) {
    HRESULT _hr = raw_Hide();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(1205)
inline HRESULT VGCore::IVGOnScreenHandle::SetHandleColor ( long Color ) {
    HRESULT _hr = raw_SetHandleColor(Color);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(1206)
inline HRESULT VGCore::IVGOnScreenHandle::SetPosition ( double x, double y ) {
    HRESULT _hr = raw_SetPosition(x, y);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(1207)
inline HRESULT VGCore::IVGOnScreenHandle::UpdateHotTracking ( double MouseX, double MouseY ) {
    HRESULT _hr = raw_UpdateHotTracking(MouseX, MouseY);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(1208)
inline VARIANT_BOOL VGCore::IVGOnScreenHandle::GetIsHotTracked ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsHotTracked(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1209)
inline VARIANT_BOOL VGCore::IVGOnScreenHandle::GetIsOnHandle ( double MouseX, double MouseY ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsOnHandle(MouseX, MouseY, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface IVGOnScreenText wrapper method implementations
//

#pragma implementation_key(1210)
inline HRESULT VGCore::IVGOnScreenText::Show ( ) {
    HRESULT _hr = raw_Show();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(1211)
inline HRESULT VGCore::IVGOnScreenText::Hide ( ) {
    HRESULT _hr = raw_Hide();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(1212)
inline HRESULT VGCore::IVGOnScreenText::SetTextColor ( long Color ) {
    HRESULT _hr = raw_SetTextColor(Color);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(1213)
inline HRESULT VGCore::IVGOnScreenText::SetTextAndPosition ( _bstr_t Text, double x, double y, enum cdrOnScreenTextAlign align, double xRef, double yRef ) {
    HRESULT _hr = raw_SetTextAndPosition(Text, x, y, align, xRef, yRef);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(1214)
inline HRESULT VGCore::IVGOnScreenText::SetText ( _bstr_t Text ) {
    HRESULT _hr = raw_SetText(Text);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(1215)
inline HRESULT VGCore::IVGOnScreenText::SetPixelOffset ( long x, long y ) {
    HRESULT _hr = raw_SetPixelOffset(x, y);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(1216)
inline HRESULT VGCore::IVGOnScreenText::UpdatePosition ( double x, double y ) {
    HRESULT _hr = raw_UpdatePosition(x, y);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface IVGToolShapeAttributes wrapper method implementations
//

#pragma implementation_key(1217)
inline HRESULT VGCore::IVGToolShapeAttributes::SetCanResize ( VARIANT_BOOL val ) {
    HRESULT _hr = raw_SetCanResize(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(1218)
inline HRESULT VGCore::IVGToolShapeAttributes::SetCanRotate ( VARIANT_BOOL val ) {
    HRESULT _hr = raw_SetCanRotate(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(1219)
inline HRESULT VGCore::IVGToolShapeAttributes::SetCanSkew ( VARIANT_BOOL val ) {
    HRESULT _hr = raw_SetCanSkew(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(1220)
inline HRESULT VGCore::IVGToolShapeAttributes::SetCanSizeDisproportionally ( VARIANT_BOOL val ) {
    HRESULT _hr = raw_SetCanSizeDisproportionally(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(1221)
inline HRESULT VGCore::IVGToolShapeAttributes::SetCanApplyNonlinearTransforms ( VARIANT_BOOL val ) {
    HRESULT _hr = raw_SetCanApplyNonlinearTransforms(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(1222)
inline HRESULT VGCore::IVGToolShapeAttributes::SetRegenerateOnTransform ( VARIANT_BOOL val ) {
    HRESULT _hr = raw_SetRegenerateOnTransform(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(1223)
inline HRESULT VGCore::IVGToolShapeAttributes::SetRegenerateOnStyleChange ( VARIANT_BOOL val ) {
    HRESULT _hr = raw_SetRegenerateOnStyleChange(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(1224)
inline HRESULT VGCore::IVGToolShapeAttributes::SetPropertyBarGuid ( _bstr_t val ) {
    HRESULT _hr = raw_SetPropertyBarGuid(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(1225)
inline HRESULT VGCore::IVGToolShapeAttributes::SetContextMenuGuid ( _bstr_t val ) {
    HRESULT _hr = raw_SetContextMenuGuid(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(1226)
inline HRESULT VGCore::IVGToolShapeAttributes::SetObjectManagerBitmapGuid ( _bstr_t val ) {
    HRESULT _hr = raw_SetObjectManagerBitmapGuid(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(1227)
inline HRESULT VGCore::IVGToolShapeAttributes::SetEditStateGuid ( _bstr_t val ) {
    HRESULT _hr = raw_SetEditStateGuid(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(1228)
inline HRESULT VGCore::IVGToolShapeAttributes::SetDefaultShapename ( _bstr_t val ) {
    HRESULT _hr = raw_SetDefaultShapename(val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface IVGMetadata wrapper method implementations
//

#pragma implementation_key(1229)
inline _bstr_t VGCore::IVGMetadata::GetKeywords ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Keywords(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(1230)
inline void VGCore::IVGMetadata::PutKeywords ( _bstr_t pVal ) {
    HRESULT _hr = put_Keywords(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(1231)
inline _bstr_t VGCore::IVGMetadata::GetNotes ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Notes(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(1232)
inline void VGCore::IVGMetadata::PutNotes ( _bstr_t pVal ) {
    HRESULT _hr = put_Notes(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(1233)
inline _bstr_t VGCore::IVGMetadata::GetAuthor ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Author(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(1234)
inline void VGCore::IVGMetadata::PutAuthor ( _bstr_t pVal ) {
    HRESULT _hr = put_Author(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(1235)
inline _bstr_t VGCore::IVGMetadata::GetLastAuthor ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_LastAuthor(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(1236)
inline void VGCore::IVGMetadata::PutLastAuthor ( _bstr_t pVal ) {
    HRESULT _hr = put_LastAuthor(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(1237)
inline _bstr_t VGCore::IVGMetadata::GetSubject ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Subject(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(1238)
inline void VGCore::IVGMetadata::PutSubject ( _bstr_t pVal ) {
    HRESULT _hr = put_Subject(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(1239)
inline _bstr_t VGCore::IVGMetadata::GetCopyright ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Copyright(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(1240)
inline void VGCore::IVGMetadata::PutCopyright ( _bstr_t pVal ) {
    HRESULT _hr = put_Copyright(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(1241)
inline long VGCore::IVGMetadata::GetRevision ( ) {
    long _result = 0;
    HRESULT _hr = get_Revision(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1242)
inline void VGCore::IVGMetadata::PutRevision ( long pVal ) {
    HRESULT _hr = put_Revision(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(1243)
inline _bstr_t VGCore::IVGMetadata::GetTemplateSided ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_TemplateSided(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(1244)
inline void VGCore::IVGMetadata::PutTemplateSided ( _bstr_t pVal ) {
    HRESULT _hr = put_TemplateSided(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(1245)
inline _bstr_t VGCore::IVGMetadata::GetTemplateFolds ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_TemplateFolds(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(1246)
inline void VGCore::IVGMetadata::PutTemplateFolds ( _bstr_t pVal ) {
    HRESULT _hr = put_TemplateFolds(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(1247)
inline _bstr_t VGCore::IVGMetadata::GetTemplateType ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_TemplateType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(1248)
inline void VGCore::IVGMetadata::PutTemplateType ( _bstr_t pVal ) {
    HRESULT _hr = put_TemplateType(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(1249)
inline _bstr_t VGCore::IVGMetadata::GetTemplateIndustry ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_TemplateIndustry(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(1250)
inline void VGCore::IVGMetadata::PutTemplateIndustry ( _bstr_t pVal ) {
    HRESULT _hr = put_TemplateIndustry(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(1251)
inline _bstr_t VGCore::IVGMetadata::GetTitle ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Title(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(1252)
inline void VGCore::IVGMetadata::PutTitle ( _bstr_t pVal ) {
    HRESULT _hr = put_Title(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(1253)
inline _bstr_t VGCore::IVGMetadata::GetDocID ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_DocID(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(1254)
inline void VGCore::IVGMetadata::PutDocID ( _bstr_t pVal ) {
    HRESULT _hr = put_DocID(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(1255)
inline enum VGCore::cdrTextLanguage VGCore::IVGMetadata::GetDocLanguage ( ) {
    enum cdrTextLanguage _result;
    HRESULT _hr = get_DocLanguage(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1256)
inline void VGCore::IVGMetadata::PutDocLanguage ( enum cdrTextLanguage pVal ) {
    HRESULT _hr = put_DocLanguage(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(1257)
inline _bstr_t VGCore::IVGMetadata::GetTemplateDesignerNotes ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_TemplateDesignerNotes(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(1258)
inline void VGCore::IVGMetadata::PutTemplateDesignerNotes ( _bstr_t pVal ) {
    HRESULT _hr = put_TemplateDesignerNotes(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(1259)
inline VGCore::IVGLocalizableStringPtr VGCore::IVGMetadata::GetLocalizableKeywords ( ) {
    struct IVGLocalizableString * _result = 0;
    HRESULT _hr = get_LocalizableKeywords(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGLocalizableStringPtr(_result, false);
}

#pragma implementation_key(1260)
inline VGCore::IVGLocalizableStringPtr VGCore::IVGMetadata::GetLocalizableNotes ( ) {
    struct IVGLocalizableString * _result = 0;
    HRESULT _hr = get_LocalizableNotes(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGLocalizableStringPtr(_result, false);
}

#pragma implementation_key(1261)
inline VGCore::IVGLocalizableStringPtr VGCore::IVGMetadata::GetLocalizableTitle ( ) {
    struct IVGLocalizableString * _result = 0;
    HRESULT _hr = get_LocalizableTitle(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGLocalizableStringPtr(_result, false);
}

#pragma implementation_key(1262)
inline VGCore::IVGLocalizableStringPtr VGCore::IVGMetadata::GetLocalizableSubject ( ) {
    struct IVGLocalizableString * _result = 0;
    HRESULT _hr = get_LocalizableSubject(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGLocalizableStringPtr(_result, false);
}

#pragma implementation_key(1263)
inline VGCore::IVGLocalizableStringPtr VGCore::IVGMetadata::GetLocalizableCopyright ( ) {
    struct IVGLocalizableString * _result = 0;
    HRESULT _hr = get_LocalizableCopyright(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGLocalizableStringPtr(_result, false);
}

#pragma implementation_key(1264)
inline VGCore::IVGLocalizableStringPtr VGCore::IVGMetadata::GetLocalizableTemplateDesignerNotes ( ) {
    struct IVGLocalizableString * _result = 0;
    HRESULT _hr = get_LocalizableTemplateDesignerNotes(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGLocalizableStringPtr(_result, false);
}

#pragma implementation_key(1265)
inline VGCore::IVGLocalizableStringPtr VGCore::IVGMetadata::GetCategory ( ) {
    struct IVGLocalizableString * _result = 0;
    HRESULT _hr = get_Category(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGLocalizableStringPtr(_result, false);
}

//
// interface _IGlobalMacroStorage wrapper method implementations
//

#pragma implementation_key(1266)
inline _bstr_t VGCore::_IGlobalMacroStorage::Get_CodeName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get__CodeName(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(1267)
inline void VGCore::_IGlobalMacroStorage::Put_CodeName ( _bstr_t pVal ) {
    HRESULT _hr = put__CodeName(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// dispinterface DIVGDocumentEvents wrapper method implementations
//

#pragma implementation_key(1268)
inline HRESULT VGCore::DIVGDocumentEvents::QueryClose ( VARIANT_BOOL * Cancel ) {
    return _com_dispatch_method(this, 0x1, DISPATCH_METHOD, VT_EMPTY, NULL, 
        L"\x400b", Cancel);
}

#pragma implementation_key(1269)
inline HRESULT VGCore::DIVGDocumentEvents::QuerySave ( VARIANT_BOOL * Cancel ) {
    return _com_dispatch_method(this, 0x2, DISPATCH_METHOD, VT_EMPTY, NULL, 
        L"\x400b", Cancel);
}

#pragma implementation_key(1270)
inline HRESULT VGCore::DIVGDocumentEvents::QueryPrint ( VARIANT_BOOL * Cancel ) {
    return _com_dispatch_method(this, 0x3, DISPATCH_METHOD, VT_EMPTY, NULL, 
        L"\x400b", Cancel);
}

#pragma implementation_key(1271)
inline HRESULT VGCore::DIVGDocumentEvents::QueryExport ( VARIANT_BOOL * Cancel ) {
    return _com_dispatch_method(this, 0x4, DISPATCH_METHOD, VT_EMPTY, NULL, 
        L"\x400b", Cancel);
}

#pragma implementation_key(1272)
inline HRESULT VGCore::DIVGDocumentEvents::Open ( ) {
    return _com_dispatch_method(this, 0x5, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}

#pragma implementation_key(1273)
inline HRESULT VGCore::DIVGDocumentEvents::Close ( ) {
    return _com_dispatch_method(this, 0x6, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}

#pragma implementation_key(1274)
inline HRESULT VGCore::DIVGDocumentEvents::BeforeSave ( VARIANT_BOOL SaveAs, _bstr_t FileName ) {
    return _com_dispatch_method(this, 0x7, DISPATCH_METHOD, VT_EMPTY, NULL, 
        L"\x000b\x0008", SaveAs, (BSTR)FileName);
}

#pragma implementation_key(1275)
inline HRESULT VGCore::DIVGDocumentEvents::AfterSave ( VARIANT_BOOL SaveAs, _bstr_t FileName ) {
    return _com_dispatch_method(this, 0x8, DISPATCH_METHOD, VT_EMPTY, NULL, 
        L"\x000b\x0008", SaveAs, (BSTR)FileName);
}

#pragma implementation_key(1276)
inline HRESULT VGCore::DIVGDocumentEvents::BeforePrint ( ) {
    return _com_dispatch_method(this, 0x9, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}

#pragma implementation_key(1277)
inline HRESULT VGCore::DIVGDocumentEvents::AfterPrint ( ) {
    return _com_dispatch_method(this, 0xa, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}

#pragma implementation_key(1278)
inline HRESULT VGCore::DIVGDocumentEvents::BeforeExport ( _bstr_t FileName, enum cdrFilter Filter, VARIANT_BOOL SaveBitmap ) {
    return _com_dispatch_method(this, 0xb, DISPATCH_METHOD, VT_EMPTY, NULL, 
        L"\x0008\x0003\x000b", (BSTR)FileName, Filter, SaveBitmap);
}

#pragma implementation_key(1279)
inline HRESULT VGCore::DIVGDocumentEvents::AfterExport ( _bstr_t FileName, enum cdrFilter Filter, VARIANT_BOOL SaveBitmap ) {
    return _com_dispatch_method(this, 0xc, DISPATCH_METHOD, VT_EMPTY, NULL, 
        L"\x0008\x0003\x000b", (BSTR)FileName, Filter, SaveBitmap);
}

#pragma implementation_key(1280)
inline HRESULT VGCore::DIVGDocumentEvents::LayerCreate ( struct IVGLayer * Layer ) {
    return _com_dispatch_method(this, 0xd, DISPATCH_METHOD, VT_EMPTY, NULL, 
        L"\x0009", Layer);
}

#pragma implementation_key(1281)
inline HRESULT VGCore::DIVGDocumentEvents::LayerDelete ( long Count ) {
    return _com_dispatch_method(this, 0xe, DISPATCH_METHOD, VT_EMPTY, NULL, 
        L"\x0003", Count);
}

#pragma implementation_key(1282)
inline HRESULT VGCore::DIVGDocumentEvents::LayerActivate ( struct IVGLayer * Layer ) {
    return _com_dispatch_method(this, 0xf, DISPATCH_METHOD, VT_EMPTY, NULL, 
        L"\x0009", Layer);
}

#pragma implementation_key(1283)
inline HRESULT VGCore::DIVGDocumentEvents::LayerChange ( struct IVGLayer * Layer ) {
    return _com_dispatch_method(this, 0x10, DISPATCH_METHOD, VT_EMPTY, NULL, 
        L"\x0009", Layer);
}

#pragma implementation_key(1284)
inline HRESULT VGCore::DIVGDocumentEvents::PageCreate ( struct IVGPage * Page ) {
    return _com_dispatch_method(this, 0x11, DISPATCH_METHOD, VT_EMPTY, NULL, 
        L"\x0009", Page);
}

#pragma implementation_key(1285)
inline HRESULT VGCore::DIVGDocumentEvents::PageDelete ( long Count ) {
    return _com_dispatch_method(this, 0x12, DISPATCH_METHOD, VT_EMPTY, NULL, 
        L"\x0003", Count);
}

#pragma implementation_key(1286)
inline HRESULT VGCore::DIVGDocumentEvents::PageActivate ( struct IVGPage * Page ) {
    return _com_dispatch_method(this, 0x13, DISPATCH_METHOD, VT_EMPTY, NULL, 
        L"\x0009", Page);
}

#pragma implementation_key(1287)
inline HRESULT VGCore::DIVGDocumentEvents::PageChange ( struct IVGPage * Page ) {
    return _com_dispatch_method(this, 0x14, DISPATCH_METHOD, VT_EMPTY, NULL, 
        L"\x0009", Page);
}

#pragma implementation_key(1288)
inline HRESULT VGCore::DIVGDocumentEvents::ShapeCreate ( struct IVGShape * Shape ) {
    return _com_dispatch_method(this, 0x15, DISPATCH_METHOD, VT_EMPTY, NULL, 
        L"\x0009", Shape);
}

#pragma implementation_key(1289)
inline HRESULT VGCore::DIVGDocumentEvents::ShapeDelete ( long Count ) {
    return _com_dispatch_method(this, 0x16, DISPATCH_METHOD, VT_EMPTY, NULL, 
        L"\x0003", Count);
}

#pragma implementation_key(1290)
inline HRESULT VGCore::DIVGDocumentEvents::ShapeMove ( struct IVGShape * Shape ) {
    return _com_dispatch_method(this, 0x17, DISPATCH_METHOD, VT_EMPTY, NULL, 
        L"\x0009", Shape);
}

#pragma implementation_key(1291)
inline HRESULT VGCore::DIVGDocumentEvents::ShapeTransform ( struct IVGShape * Shape ) {
    return _com_dispatch_method(this, 0x18, DISPATCH_METHOD, VT_EMPTY, NULL, 
        L"\x0009", Shape);
}

#pragma implementation_key(1292)
inline HRESULT VGCore::DIVGDocumentEvents::ShapeDistort ( struct IVGShape * Shape ) {
    return _com_dispatch_method(this, 0x19, DISPATCH_METHOD, VT_EMPTY, NULL, 
        L"\x0009", Shape);
}

#pragma implementation_key(1293)
inline HRESULT VGCore::DIVGDocumentEvents::ShapeChange ( struct IVGShape * Shape, enum cdrShapeChangeScope Scope ) {
    return _com_dispatch_method(this, 0x1a, DISPATCH_METHOD, VT_EMPTY, NULL, 
        L"\x0009\x0003", Shape, Scope);
}

#pragma implementation_key(1294)
inline HRESULT VGCore::DIVGDocumentEvents::SelectionChange ( ) {
    return _com_dispatch_method(this, 0x1b, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}

//
// interface IVGDocumentEvents wrapper method implementations
//

#pragma implementation_key(1295)
inline HRESULT VGCore::IVGDocumentEvents::QueryClose ( VARIANT_BOOL * Cancel ) {
    HRESULT _hr = raw_QueryClose(Cancel);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(1296)
inline HRESULT VGCore::IVGDocumentEvents::QuerySave ( VARIANT_BOOL * Cancel ) {
    HRESULT _hr = raw_QuerySave(Cancel);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(1297)
inline HRESULT VGCore::IVGDocumentEvents::QueryPrint ( VARIANT_BOOL * Cancel ) {
    HRESULT _hr = raw_QueryPrint(Cancel);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(1298)
inline HRESULT VGCore::IVGDocumentEvents::QueryExport ( VARIANT_BOOL * Cancel ) {
    HRESULT _hr = raw_QueryExport(Cancel);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(1299)
inline HRESULT VGCore::IVGDocumentEvents::Open ( ) {
    HRESULT _hr = raw_Open();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(1300)
inline HRESULT VGCore::IVGDocumentEvents::Close ( ) {
    HRESULT _hr = raw_Close();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(1301)
inline HRESULT VGCore::IVGDocumentEvents::BeforeSave ( VARIANT_BOOL SaveAs, _bstr_t FileName ) {
    HRESULT _hr = raw_BeforeSave(SaveAs, FileName);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(1302)
inline HRESULT VGCore::IVGDocumentEvents::AfterSave ( VARIANT_BOOL SaveAs, _bstr_t FileName ) {
    HRESULT _hr = raw_AfterSave(SaveAs, FileName);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(1303)
inline HRESULT VGCore::IVGDocumentEvents::BeforePrint ( ) {
    HRESULT _hr = raw_BeforePrint();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(1304)
inline HRESULT VGCore::IVGDocumentEvents::AfterPrint ( ) {
    HRESULT _hr = raw_AfterPrint();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(1305)
inline HRESULT VGCore::IVGDocumentEvents::BeforeExport ( _bstr_t FileName, enum cdrFilter Filter, VARIANT_BOOL SaveBitmap ) {
    HRESULT _hr = raw_BeforeExport(FileName, Filter, SaveBitmap);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(1306)
inline HRESULT VGCore::IVGDocumentEvents::AfterExport ( _bstr_t FileName, enum cdrFilter Filter, VARIANT_BOOL SaveBitmap ) {
    HRESULT _hr = raw_AfterExport(FileName, Filter, SaveBitmap);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(1307)
inline HRESULT VGCore::IVGDocumentEvents::LayerCreate ( struct IVGLayer * Layer ) {
    HRESULT _hr = raw_LayerCreate(Layer);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(1308)
inline HRESULT VGCore::IVGDocumentEvents::LayerDelete ( long Count ) {
    HRESULT _hr = raw_LayerDelete(Count);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(1309)
inline HRESULT VGCore::IVGDocumentEvents::LayerActivate ( struct IVGLayer * Layer ) {
    HRESULT _hr = raw_LayerActivate(Layer);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(1310)
inline HRESULT VGCore::IVGDocumentEvents::LayerChange ( struct IVGLayer * Layer ) {
    HRESULT _hr = raw_LayerChange(Layer);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(1311)
inline HRESULT VGCore::IVGDocumentEvents::PageCreate ( struct IVGPage * Page ) {
    HRESULT _hr = raw_PageCreate(Page);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(1312)
inline HRESULT VGCore::IVGDocumentEvents::PageDelete ( long Count ) {
    HRESULT _hr = raw_PageDelete(Count);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(1313)
inline HRESULT VGCore::IVGDocumentEvents::PageActivate ( struct IVGPage * Page ) {
    HRESULT _hr = raw_PageActivate(Page);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(1314)
inline HRESULT VGCore::IVGDocumentEvents::PageChange ( struct IVGPage * Page ) {
    HRESULT _hr = raw_PageChange(Page);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(1315)
inline HRESULT VGCore::IVGDocumentEvents::ShapeCreate ( struct IVGShape * Shape ) {
    HRESULT _hr = raw_ShapeCreate(Shape);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(1316)
inline HRESULT VGCore::IVGDocumentEvents::ShapeDelete ( long Count ) {
    HRESULT _hr = raw_ShapeDelete(Count);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(1317)
inline HRESULT VGCore::IVGDocumentEvents::ShapeMove ( struct IVGShape * Shape ) {
    HRESULT _hr = raw_ShapeMove(Shape);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(1318)
inline HRESULT VGCore::IVGDocumentEvents::ShapeTransform ( struct IVGShape * Shape ) {
    HRESULT _hr = raw_ShapeTransform(Shape);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(1319)
inline HRESULT VGCore::IVGDocumentEvents::ShapeDistort ( struct IVGShape * Shape ) {
    HRESULT _hr = raw_ShapeDistort(Shape);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(1320)
inline HRESULT VGCore::IVGDocumentEvents::ShapeChange ( struct IVGShape * Shape, enum cdrShapeChangeScope Scope ) {
    HRESULT _hr = raw_ShapeChange(Shape, Scope);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(1321)
inline HRESULT VGCore::IVGDocumentEvents::SelectionChange ( ) {
    HRESULT _hr = raw_SelectionChange();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface IVGApplicationEvents wrapper method implementations
//

#pragma implementation_key(1322)
inline HRESULT VGCore::IVGApplicationEvents::QueryDocumentClose ( struct IVGDocument * Doc, VARIANT_BOOL * Cancel ) {
    HRESULT _hr = raw_QueryDocumentClose(Doc, Cancel);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(1323)
inline HRESULT VGCore::IVGApplicationEvents::QueryDocumentSave ( struct IVGDocument * Doc, VARIANT_BOOL * Cancel ) {
    HRESULT _hr = raw_QueryDocumentSave(Doc, Cancel);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(1324)
inline HRESULT VGCore::IVGApplicationEvents::QueryDocumentPrint ( struct IVGDocument * Doc, VARIANT_BOOL * Cancel ) {
    HRESULT _hr = raw_QueryDocumentPrint(Doc, Cancel);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(1325)
inline HRESULT VGCore::IVGApplicationEvents::QueryDocumentExport ( struct IVGDocument * Doc, VARIANT_BOOL * Cancel ) {
    HRESULT _hr = raw_QueryDocumentExport(Doc, Cancel);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(1326)
inline HRESULT VGCore::IVGApplicationEvents::QueryQuit ( VARIANT_BOOL * Cancel ) {
    HRESULT _hr = raw_QueryQuit(Cancel);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(1327)
inline HRESULT VGCore::IVGApplicationEvents::DocumentOpen ( struct IVGDocument * Doc, _bstr_t FileName ) {
    HRESULT _hr = raw_DocumentOpen(Doc, FileName);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(1328)
inline HRESULT VGCore::IVGApplicationEvents::DocumentNew ( struct IVGDocument * Doc, VARIANT_BOOL FromTemplate, _bstr_t Template, VARIANT_BOOL IncludeGraphics ) {
    HRESULT _hr = raw_DocumentNew(Doc, FromTemplate, Template, IncludeGraphics);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(1329)
inline HRESULT VGCore::IVGApplicationEvents::DocumentClose ( struct IVGDocument * Doc ) {
    HRESULT _hr = raw_DocumentClose(Doc);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(1330)
inline HRESULT VGCore::IVGApplicationEvents::DocumentBeforeSave ( struct IVGDocument * Doc, VARIANT_BOOL SaveAs, _bstr_t FileName ) {
    HRESULT _hr = raw_DocumentBeforeSave(Doc, SaveAs, FileName);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(1331)
inline HRESULT VGCore::IVGApplicationEvents::DocumentAfterSave ( struct IVGDocument * Doc, VARIANT_BOOL SaveAs, _bstr_t FileName ) {
    HRESULT _hr = raw_DocumentAfterSave(Doc, SaveAs, FileName);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(1332)
inline HRESULT VGCore::IVGApplicationEvents::DocumentBeforePrint ( struct IVGDocument * Doc ) {
    HRESULT _hr = raw_DocumentBeforePrint(Doc);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(1333)
inline HRESULT VGCore::IVGApplicationEvents::DocumentAfterPrint ( struct IVGDocument * Doc ) {
    HRESULT _hr = raw_DocumentAfterPrint(Doc);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(1334)
inline HRESULT VGCore::IVGApplicationEvents::DocumentBeforeExport ( struct IVGDocument * Doc, _bstr_t FileName, enum cdrFilter Filter, VARIANT_BOOL SaveBitmap ) {
    HRESULT _hr = raw_DocumentBeforeExport(Doc, FileName, Filter, SaveBitmap);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(1335)
inline HRESULT VGCore::IVGApplicationEvents::DocumentAfterExport ( struct IVGDocument * Doc, _bstr_t FileName, enum cdrFilter Filter, VARIANT_BOOL SaveBitmap ) {
    HRESULT _hr = raw_DocumentAfterExport(Doc, FileName, Filter, SaveBitmap);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(1336)
inline HRESULT VGCore::IVGApplicationEvents::WindowActivate ( struct IVGDocument * Doc, struct IVGWindow * Window ) {
    HRESULT _hr = raw_WindowActivate(Doc, Window);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(1337)
inline HRESULT VGCore::IVGApplicationEvents::WindowDeactivate ( struct IVGDocument * Doc, struct IVGWindow * Window ) {
    HRESULT _hr = raw_WindowDeactivate(Doc, Window);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(1338)
inline HRESULT VGCore::IVGApplicationEvents::SelectionChange ( ) {
    HRESULT _hr = raw_SelectionChange();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(1339)
inline HRESULT VGCore::IVGApplicationEvents::Start ( ) {
    HRESULT _hr = raw_Start();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(1340)
inline HRESULT VGCore::IVGApplicationEvents::Quit ( ) {
    HRESULT _hr = raw_Quit();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(1341)
inline HRESULT VGCore::IVGApplicationEvents::OnPluginCommand ( _bstr_t CommandID ) {
    HRESULT _hr = raw_OnPluginCommand(CommandID);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(1342)
inline HRESULT VGCore::IVGApplicationEvents::OnUpdatePluginCommand ( _bstr_t CommandID, VARIANT_BOOL * Enabled, enum cdrCommandCheckState * Checked ) {
    HRESULT _hr = raw_OnUpdatePluginCommand(CommandID, Enabled, Checked);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(1343)
inline HRESULT VGCore::IVGApplicationEvents::OnApplicationEvent ( _bstr_t EventName, SAFEARRAY * * Parameters ) {
    HRESULT _hr = raw_OnApplicationEvent(EventName, Parameters);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// dispinterface DIVGApplicationEvents wrapper method implementations
//

#pragma implementation_key(1344)
inline HRESULT VGCore::DIVGApplicationEvents::QueryDocumentClose ( struct IVGDocument * Doc, VARIANT_BOOL * Cancel ) {
    return _com_dispatch_method(this, 0x1, DISPATCH_METHOD, VT_EMPTY, NULL, 
        L"\x0009\x400b", Doc, Cancel);
}

#pragma implementation_key(1345)
inline HRESULT VGCore::DIVGApplicationEvents::QueryDocumentSave ( struct IVGDocument * Doc, VARIANT_BOOL * Cancel ) {
    return _com_dispatch_method(this, 0x2, DISPATCH_METHOD, VT_EMPTY, NULL, 
        L"\x0009\x400b", Doc, Cancel);
}

#pragma implementation_key(1346)
inline HRESULT VGCore::DIVGApplicationEvents::QueryDocumentPrint ( struct IVGDocument * Doc, VARIANT_BOOL * Cancel ) {
    return _com_dispatch_method(this, 0x3, DISPATCH_METHOD, VT_EMPTY, NULL, 
        L"\x0009\x400b", Doc, Cancel);
}

#pragma implementation_key(1347)
inline HRESULT VGCore::DIVGApplicationEvents::QueryDocumentExport ( struct IVGDocument * Doc, VARIANT_BOOL * Cancel ) {
    return _com_dispatch_method(this, 0x4, DISPATCH_METHOD, VT_EMPTY, NULL, 
        L"\x0009\x400b", Doc, Cancel);
}

#pragma implementation_key(1348)
inline HRESULT VGCore::DIVGApplicationEvents::QueryQuit ( VARIANT_BOOL * Cancel ) {
    return _com_dispatch_method(this, 0x5, DISPATCH_METHOD, VT_EMPTY, NULL, 
        L"\x400b", Cancel);
}

#pragma implementation_key(1349)
inline HRESULT VGCore::DIVGApplicationEvents::DocumentOpen ( struct IVGDocument * Doc, _bstr_t FileName ) {
    return _com_dispatch_method(this, 0x6, DISPATCH_METHOD, VT_EMPTY, NULL, 
        L"\x0009\x0008", Doc, (BSTR)FileName);
}

#pragma implementation_key(1350)
inline HRESULT VGCore::DIVGApplicationEvents::DocumentNew ( struct IVGDocument * Doc, VARIANT_BOOL FromTemplate, _bstr_t Template, VARIANT_BOOL IncludeGraphics ) {
    return _com_dispatch_method(this, 0x7, DISPATCH_METHOD, VT_EMPTY, NULL, 
        L"\x0009\x000b\x0008\x000b", Doc, FromTemplate, (BSTR)Template, IncludeGraphics);
}

#pragma implementation_key(1351)
inline HRESULT VGCore::DIVGApplicationEvents::DocumentClose ( struct IVGDocument * Doc ) {
    return _com_dispatch_method(this, 0x8, DISPATCH_METHOD, VT_EMPTY, NULL, 
        L"\x0009", Doc);
}

#pragma implementation_key(1352)
inline HRESULT VGCore::DIVGApplicationEvents::DocumentBeforeSave ( struct IVGDocument * Doc, VARIANT_BOOL SaveAs, _bstr_t FileName ) {
    return _com_dispatch_method(this, 0x9, DISPATCH_METHOD, VT_EMPTY, NULL, 
        L"\x0009\x000b\x0008", Doc, SaveAs, (BSTR)FileName);
}

#pragma implementation_key(1353)
inline HRESULT VGCore::DIVGApplicationEvents::DocumentAfterSave ( struct IVGDocument * Doc, VARIANT_BOOL SaveAs, _bstr_t FileName ) {
    return _com_dispatch_method(this, 0xa, DISPATCH_METHOD, VT_EMPTY, NULL, 
        L"\x0009\x000b\x0008", Doc, SaveAs, (BSTR)FileName);
}

#pragma implementation_key(1354)
inline HRESULT VGCore::DIVGApplicationEvents::DocumentBeforePrint ( struct IVGDocument * Doc ) {
    return _com_dispatch_method(this, 0xb, DISPATCH_METHOD, VT_EMPTY, NULL, 
        L"\x0009", Doc);
}

#pragma implementation_key(1355)
inline HRESULT VGCore::DIVGApplicationEvents::DocumentAfterPrint ( struct IVGDocument * Doc ) {
    return _com_dispatch_method(this, 0xc, DISPATCH_METHOD, VT_EMPTY, NULL, 
        L"\x0009", Doc);
}

#pragma implementation_key(1356)
inline HRESULT VGCore::DIVGApplicationEvents::DocumentBeforeExport ( struct IVGDocument * Doc, _bstr_t FileName, enum cdrFilter Filter, VARIANT_BOOL SaveBitmap ) {
    return _com_dispatch_method(this, 0xd, DISPATCH_METHOD, VT_EMPTY, NULL, 
        L"\x0009\x0008\x0003\x000b", Doc, (BSTR)FileName, Filter, SaveBitmap);
}

#pragma implementation_key(1357)
inline HRESULT VGCore::DIVGApplicationEvents::DocumentAfterExport ( struct IVGDocument * Doc, _bstr_t FileName, enum cdrFilter Filter, VARIANT_BOOL SaveBitmap ) {
    return _com_dispatch_method(this, 0xe, DISPATCH_METHOD, VT_EMPTY, NULL, 
        L"\x0009\x0008\x0003\x000b", Doc, (BSTR)FileName, Filter, SaveBitmap);
}

#pragma implementation_key(1358)
inline HRESULT VGCore::DIVGApplicationEvents::WindowActivate ( struct IVGDocument * Doc, struct IVGWindow * Window ) {
    return _com_dispatch_method(this, 0xf, DISPATCH_METHOD, VT_EMPTY, NULL, 
        L"\x0009\x0009", Doc, Window);
}

#pragma implementation_key(1359)
inline HRESULT VGCore::DIVGApplicationEvents::WindowDeactivate ( struct IVGDocument * Doc, struct IVGWindow * Window ) {
    return _com_dispatch_method(this, 0x10, DISPATCH_METHOD, VT_EMPTY, NULL, 
        L"\x0009\x0009", Doc, Window);
}

#pragma implementation_key(1360)
inline HRESULT VGCore::DIVGApplicationEvents::SelectionChange ( ) {
    return _com_dispatch_method(this, 0x11, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}

#pragma implementation_key(1361)
inline HRESULT VGCore::DIVGApplicationEvents::Start ( ) {
    return _com_dispatch_method(this, 0x12, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}

#pragma implementation_key(1362)
inline HRESULT VGCore::DIVGApplicationEvents::Quit ( ) {
    return _com_dispatch_method(this, 0x13, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}

#pragma implementation_key(1363)
inline HRESULT VGCore::DIVGApplicationEvents::OnPluginCommand ( _bstr_t CommandID ) {
    return _com_dispatch_method(this, 0x14, DISPATCH_METHOD, VT_EMPTY, NULL, 
        L"\x0008", (BSTR)CommandID);
}

#pragma implementation_key(1364)
inline HRESULT VGCore::DIVGApplicationEvents::OnUpdatePluginCommand ( _bstr_t CommandID, VARIANT_BOOL * Enabled, enum cdrCommandCheckState * Checked ) {
    return _com_dispatch_method(this, 0x15, DISPATCH_METHOD, VT_EMPTY, NULL, 
        L"\x0008\x400b\x4003", (BSTR)CommandID, Enabled, Checked);
}

#pragma implementation_key(1365)
inline HRESULT VGCore::DIVGApplicationEvents::OnApplicationEvent ( _bstr_t EventName, SAFEARRAY * * Parameters ) {
    return _com_dispatch_method(this, 0x16, DISPATCH_METHOD, VT_EMPTY, NULL, 
        L"\x0008\x600c", (BSTR)EventName, Parameters);
}

//
// interface ICUIFrameWork wrapper method implementations
//

#pragma implementation_key(1366)
inline VGCore::ICUICommandBarsPtr VGCore::ICUIFrameWork::GetCommandBars ( ) {
    struct ICUICommandBars * _result = 0;
    HRESULT _hr = get_CommandBars(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return ICUICommandBarsPtr(_result, false);
}

#pragma implementation_key(1367)
inline VGCore::ICUICommandBarPtr VGCore::ICUIFrameWork::GetMainMenu ( ) {
    struct ICUICommandBar * _result = 0;
    HRESULT _hr = get_MainMenu(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return ICUICommandBarPtr(_result, false);
}

#pragma implementation_key(1368)
inline VGCore::ICUICommandBarPtr VGCore::ICUIFrameWork::GetStatusBar ( ) {
    struct ICUICommandBar * _result = 0;
    HRESULT _hr = get_StatusBar(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return ICUICommandBarPtr(_result, false);
}

#pragma implementation_key(1369)
inline _bstr_t VGCore::ICUIFrameWork::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(1370)
inline HRESULT VGCore::ICUIFrameWork::ImportWorkspace ( _bstr_t FileName ) {
    HRESULT _hr = raw_ImportWorkspace(FileName);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(1371)
inline VGCore::ICUIAutomationPtr VGCore::ICUIFrameWork::GetAutomation ( ) {
    struct ICUIAutomation * _result = 0;
    HRESULT _hr = get_Automation(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return ICUIAutomationPtr(_result, false);
}

#pragma implementation_key(1372)
inline HRESULT VGCore::ICUIFrameWork::ShowDocker ( _bstr_t Guid ) {
    HRESULT _hr = raw_ShowDocker(Guid);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(1373)
inline HRESULT VGCore::ICUIFrameWork::HideDocker ( _bstr_t Guid ) {
    HRESULT _hr = raw_HideDocker(Guid);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(1374)
inline VARIANT_BOOL VGCore::ICUIFrameWork::IsDockerVisible ( _bstr_t Guid ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_IsDockerVisible(Guid, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1375)
inline HRESULT VGCore::ICUIFrameWork::AddDocker ( _bstr_t Guid, _bstr_t ClassName, _bstr_t AssemblyPath ) {
    HRESULT _hr = raw_AddDocker(Guid, ClassName, AssemblyPath);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(1376)
inline HRESULT VGCore::ICUIFrameWork::RemoveDocker ( _bstr_t Guid ) {
    HRESULT _hr = raw_RemoveDocker(Guid);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(1377)
inline VGCore::ICUIFrameWindowsPtr VGCore::ICUIFrameWork::GetFrameWindows ( ) {
    struct ICUIFrameWindows * _result = 0;
    HRESULT _hr = get_FrameWindows(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return ICUIFrameWindowsPtr(_result, false);
}

#pragma implementation_key(1378)
inline VGCore::ICUIFrameWindowPtr VGCore::ICUIFrameWork::GetMainFrameWindow ( ) {
    struct ICUIFrameWindow * _result = 0;
    HRESULT _hr = get_MainFrameWindow(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return ICUIFrameWindowPtr(_result, false);
}

#pragma implementation_key(1379)
inline VGCore::ICUIApplicationPtr VGCore::ICUIFrameWork::GetApplication ( ) {
    struct ICUIApplication * _result = 0;
    HRESULT _hr = get_Application(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return ICUIApplicationPtr(_result, false);
}

#pragma implementation_key(1380)
inline VGCore::ICUIFrameWindowPtr VGCore::ICUIFrameWork::CreateFrameWindowForViewHost ( struct ICUIViewHost * ViewHostToInsert ) {
    struct ICUIFrameWindow * _result = 0;
    HRESULT _hr = raw_CreateFrameWindowForViewHost(ViewHostToInsert, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return ICUIFrameWindowPtr(_result, false);
}

#pragma implementation_key(1381)
inline VGCore::ICUIFrameWindowPtr VGCore::ICUIFrameWork::CreateFrameWindowForView ( struct ICUIViewWindow * ViewToInsert ) {
    struct ICUIFrameWindow * _result = 0;
    HRESULT _hr = raw_CreateFrameWindowForView(ViewToInsert, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return ICUIFrameWindowPtr(_result, false);
}

#pragma implementation_key(1382)
inline HRESULT VGCore::ICUIFrameWork::ShowDialog ( _bstr_t Guid ) {
    HRESULT _hr = raw_ShowDialog(Guid);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(1383)
inline HRESULT VGCore::ICUIFrameWork::HideDialog ( _bstr_t Guid ) {
    HRESULT _hr = raw_HideDialog(Guid);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(1384)
inline long VGCore::ICUIFrameWork::ShowMessageBox ( _bstr_t szMessage, _bstr_t szMainInstruction, long unFlags, struct ICUIBitmapImage * pImage, _bstr_t szHelpGuid, _bstr_t szWarningName, enum cuiMessageBoxFlags eFlags, struct ICUIDataContext * pDataContext ) {
    long _result = 0;
    HRESULT _hr = raw_ShowMessageBox(szMessage, szMainInstruction, unFlags, pImage, szHelpGuid, szWarningName, eFlags, pDataContext, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1385)
inline VGCore::ICUIWarningPtr VGCore::ICUIFrameWork::GetWarning ( _bstr_t szWarningID, VARIANT_BOOL bHidden ) {
    struct ICUIWarning * _result = 0;
    HRESULT _hr = raw_GetWarning(szWarningID, bHidden, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return ICUIWarningPtr(_result, false);
}

#pragma implementation_key(1386)
inline VGCore::ICUITaskManagerPtr VGCore::ICUIFrameWork::GetTaskManager ( ) {
    struct ICUITaskManager * _result = 0;
    HRESULT _hr = get_TaskManager(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return ICUITaskManagerPtr(_result, false);
}

//
// interface ICUIFrameWindows wrapper method implementations
//

#pragma implementation_key(1387)
inline long VGCore::ICUIFrameWindows::GetCount ( ) {
    long _result = 0;
    HRESULT _hr = get_Count(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1388)
inline VGCore::ICUIFrameWindowPtr VGCore::ICUIFrameWindows::GetItem ( long Index ) {
    struct ICUIFrameWindow * _result = 0;
    HRESULT _hr = get_Item(Index, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return ICUIFrameWindowPtr(_result, false);
}

#pragma implementation_key(1389)
inline IUnknownPtr VGCore::ICUIFrameWindows::Get_NewEnum ( ) {
    IUnknown * _result = 0;
    HRESULT _hr = get__NewEnum(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IUnknownPtr(_result, false);
}

#pragma implementation_key(1390)
inline VGCore::ICUIFrameWindowPtr VGCore::ICUIFrameWindows::Find ( _bstr_t ID ) {
    struct ICUIFrameWindow * _result = 0;
    HRESULT _hr = raw_Find(ID, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return ICUIFrameWindowPtr(_result, false);
}

#pragma implementation_key(1391)
inline VGCore::ICUIFrameWindowPtr VGCore::ICUIFrameWindows::GetFirst ( ) {
    struct ICUIFrameWindow * _result = 0;
    HRESULT _hr = get_First(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return ICUIFrameWindowPtr(_result, false);
}

#pragma implementation_key(1392)
inline VGCore::ICUIFrameWindowPtr VGCore::ICUIFrameWindows::GetLast ( ) {
    struct ICUIFrameWindow * _result = 0;
    HRESULT _hr = get_Last(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return ICUIFrameWindowPtr(_result, false);
}

//
// interface ICUIFrameWindow wrapper method implementations
//

#pragma implementation_key(1393)
inline _bstr_t VGCore::ICUIFrameWindow::GetID ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_ID(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(1394)
inline _bstr_t VGCore::ICUIFrameWindow::GetCaption ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Caption(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(1395)
inline HRESULT VGCore::ICUIFrameWindow::Minimize ( ) {
    HRESULT _hr = raw_Minimize();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(1396)
inline HRESULT VGCore::ICUIFrameWindow::Maximize ( ) {
    HRESULT _hr = raw_Maximize();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(1397)
inline HRESULT VGCore::ICUIFrameWindow::Restore ( ) {
    HRESULT _hr = raw_Restore();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(1398)
inline enum VGCore::cuiWindowState VGCore::ICUIFrameWindow::GetState ( ) {
    enum cuiWindowState _result;
    HRESULT _hr = get_State(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1399)
inline VARIANT_BOOL VGCore::ICUIFrameWindow::GetIsMainFrame ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsMainFrame(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1400)
inline HRESULT VGCore::ICUIFrameWindow::Close ( ) {
    HRESULT _hr = raw_Close();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(1401)
inline HRESULT VGCore::ICUIFrameWindow::Activate ( ) {
    HRESULT _hr = raw_Activate();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(1402)
inline VARIANT_BOOL VGCore::ICUIFrameWindow::GetIsActive ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsActive(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1403)
inline long VGCore::ICUIFrameWindow::GetHandle ( ) {
    long _result = 0;
    HRESULT _hr = get_Handle(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1404)
inline HRESULT VGCore::ICUIFrameWindow::TileViews ( VARIANT_BOOL TileHorizontally ) {
    HRESULT _hr = raw_TileViews(TileHorizontally);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(1405)
inline HRESULT VGCore::ICUIFrameWindow::CombineViews ( ) {
    HRESULT _hr = raw_CombineViews();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(1406)
inline VGCore::ICUIViewHostsPtr VGCore::ICUIFrameWindow::GetViewHosts ( ) {
    struct ICUIViewHosts * _result = 0;
    HRESULT _hr = get_ViewHosts(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return ICUIViewHostsPtr(_result, false);
}

#pragma implementation_key(1407)
inline VGCore::ICUIDockHostsPtr VGCore::ICUIFrameWindow::GetDockHosts ( ) {
    struct ICUIDockHosts * _result = 0;
    HRESULT _hr = get_DockHosts(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return ICUIDockHostsPtr(_result, false);
}

#pragma implementation_key(1408)
inline VGCore::ICUIDockHostPtr VGCore::ICUIFrameWindow::GetRootDockHost ( ) {
    struct ICUIDockHost * _result = 0;
    HRESULT _hr = get_RootDockHost(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return ICUIDockHostPtr(_result, false);
}

#pragma implementation_key(1409)
inline VGCore::ICUIScreenRectPtr VGCore::ICUIFrameWindow::GetPosition ( ) {
    struct ICUIScreenRect * _result = 0;
    HRESULT _hr = get_Position(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return ICUIScreenRectPtr(_result, false);
}

//
// interface ICUIViewHosts wrapper method implementations
//

#pragma implementation_key(1410)
inline long VGCore::ICUIViewHosts::GetCount ( ) {
    long _result = 0;
    HRESULT _hr = get_Count(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1411)
inline VGCore::ICUIViewHostPtr VGCore::ICUIViewHosts::GetItem ( long Index ) {
    struct ICUIViewHost * _result = 0;
    HRESULT _hr = get_Item(Index, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return ICUIViewHostPtr(_result, false);
}

#pragma implementation_key(1412)
inline IUnknownPtr VGCore::ICUIViewHosts::Get_NewEnum ( ) {
    IUnknown * _result = 0;
    HRESULT _hr = get__NewEnum(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IUnknownPtr(_result, false);
}

#pragma implementation_key(1413)
inline VGCore::ICUIViewHostPtr VGCore::ICUIViewHosts::Find ( _bstr_t ID ) {
    struct ICUIViewHost * _result = 0;
    HRESULT _hr = raw_Find(ID, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return ICUIViewHostPtr(_result, false);
}

#pragma implementation_key(1414)
inline VGCore::ICUIViewHostPtr VGCore::ICUIViewHosts::GetFirst ( ) {
    struct ICUIViewHost * _result = 0;
    HRESULT _hr = get_First(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return ICUIViewHostPtr(_result, false);
}

#pragma implementation_key(1415)
inline VGCore::ICUIViewHostPtr VGCore::ICUIViewHosts::GetLast ( ) {
    struct ICUIViewHost * _result = 0;
    HRESULT _hr = get_Last(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return ICUIViewHostPtr(_result, false);
}

//
// interface ICUIViewHost wrapper method implementations
//

#pragma implementation_key(1416)
inline _bstr_t VGCore::ICUIViewHost::GetID ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_ID(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(1417)
inline VGCore::ICUIDockHostPtr VGCore::ICUIViewHost::GetDockHost ( ) {
    struct ICUIDockHost * _result = 0;
    HRESULT _hr = get_DockHost(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return ICUIDockHostPtr(_result, false);
}

#pragma implementation_key(1418)
inline VGCore::ICUIViewWindowsPtr VGCore::ICUIViewHost::GetViews ( ) {
    struct ICUIViewWindows * _result = 0;
    HRESULT _hr = get_Views(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return ICUIViewWindowsPtr(_result, false);
}

#pragma implementation_key(1419)
inline VGCore::ICUIDockItemPtr VGCore::ICUIViewHost::GetDockItem ( ) {
    struct ICUIDockItem * _result = 0;
    HRESULT _hr = get_DockItem(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return ICUIDockItemPtr(_result, false);
}

#pragma implementation_key(1420)
inline VGCore::ICUIScreenRectPtr VGCore::ICUIViewHost::GetPosition ( ) {
    struct ICUIScreenRect * _result = 0;
    HRESULT _hr = get_Position(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return ICUIScreenRectPtr(_result, false);
}

#pragma implementation_key(1421)
inline HRESULT VGCore::ICUIViewHost::InsertView ( struct ICUIViewWindow * ViewToInsert, long Index ) {
    HRESULT _hr = raw_InsertView(ViewToInsert, Index);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(1422)
inline HRESULT VGCore::ICUIViewHost::InsertViewHost ( struct ICUIViewHost * ViewHostToInsert, long Index ) {
    HRESULT _hr = raw_InsertViewHost(ViewHostToInsert, Index);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface ICUIViewWindow wrapper method implementations
//

#pragma implementation_key(1423)
inline _bstr_t VGCore::ICUIViewWindow::GetID ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_ID(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(1424)
inline VGCore::ICUIViewHostPtr VGCore::ICUIViewWindow::GetViewHost ( ) {
    struct ICUIViewHost * _result = 0;
    HRESULT _hr = get_ViewHost(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return ICUIViewHostPtr(_result, false);
}

#pragma implementation_key(1425)
inline long VGCore::ICUIViewWindow::GetIndex ( ) {
    long _result = 0;
    HRESULT _hr = get_Index(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1426)
inline _bstr_t VGCore::ICUIViewWindow::GetKind ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Kind(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(1427)
inline _bstr_t VGCore::ICUIViewWindow::GetTitle ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Title(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(1428)
inline _bstr_t VGCore::ICUIViewWindow::GetDescription ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Description(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(1429)
inline VGCore::ICUIScreenRectPtr VGCore::ICUIViewWindow::GetPosition ( ) {
    struct ICUIScreenRect * _result = 0;
    HRESULT _hr = get_Position(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return ICUIScreenRectPtr(_result, false);
}

#pragma implementation_key(1430)
inline HRESULT VGCore::ICUIViewWindow::Activate ( ) {
    HRESULT _hr = raw_Activate();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(1431)
inline HRESULT VGCore::ICUIViewWindow::Close ( ) {
    HRESULT _hr = raw_Close();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(1432)
inline IDispatchPtr VGCore::ICUIViewWindow::GetAppView ( ) {
    IDispatch * _result = 0;
    HRESULT _hr = get_AppView(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IDispatchPtr(_result, false);
}

//
// interface ICUIViewWindows wrapper method implementations
//

#pragma implementation_key(1433)
inline long VGCore::ICUIViewWindows::GetCount ( ) {
    long _result = 0;
    HRESULT _hr = get_Count(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1434)
inline VGCore::ICUIViewWindowPtr VGCore::ICUIViewWindows::GetItem ( long Index ) {
    struct ICUIViewWindow * _result = 0;
    HRESULT _hr = get_Item(Index, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return ICUIViewWindowPtr(_result, false);
}

#pragma implementation_key(1435)
inline IUnknownPtr VGCore::ICUIViewWindows::Get_NewEnum ( ) {
    IUnknown * _result = 0;
    HRESULT _hr = get__NewEnum(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IUnknownPtr(_result, false);
}

#pragma implementation_key(1436)
inline VGCore::ICUIViewWindowPtr VGCore::ICUIViewWindows::Find ( _bstr_t ID ) {
    struct ICUIViewWindow * _result = 0;
    HRESULT _hr = raw_Find(ID, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return ICUIViewWindowPtr(_result, false);
}

#pragma implementation_key(1437)
inline VGCore::ICUIViewWindowPtr VGCore::ICUIViewWindows::GetFirst ( ) {
    struct ICUIViewWindow * _result = 0;
    HRESULT _hr = get_First(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return ICUIViewWindowPtr(_result, false);
}

#pragma implementation_key(1438)
inline VGCore::ICUIViewWindowPtr VGCore::ICUIViewWindows::GetLast ( ) {
    struct ICUIViewWindow * _result = 0;
    HRESULT _hr = get_Last(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return ICUIViewWindowPtr(_result, false);
}

//
// interface ICUIDockHost wrapper method implementations
//

#pragma implementation_key(1439)
inline _bstr_t VGCore::ICUIDockHost::GetID ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_ID(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(1440)
inline enum VGCore::cuiDockHostOrientation VGCore::ICUIDockHost::GetOrientation ( ) {
    enum cuiDockHostOrientation _result;
    HRESULT _hr = get_Orientation(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1441)
inline VGCore::ICUIDockHostPtr VGCore::ICUIDockHost::GetParentDockHost ( ) {
    struct ICUIDockHost * _result = 0;
    HRESULT _hr = get_ParentDockHost(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return ICUIDockHostPtr(_result, false);
}

#pragma implementation_key(1442)
inline VGCore::ICUIDockItemPtr VGCore::ICUIDockHost::GetDockItem ( ) {
    struct ICUIDockItem * _result = 0;
    HRESULT _hr = get_DockItem(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return ICUIDockItemPtr(_result, false);
}

#pragma implementation_key(1443)
inline VGCore::ICUIDockItemsPtr VGCore::ICUIDockHost::GetChildren ( ) {
    struct ICUIDockItems * _result = 0;
    HRESULT _hr = get_Children(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return ICUIDockItemsPtr(_result, false);
}

#pragma implementation_key(1444)
inline HRESULT VGCore::ICUIDockHost::InsertViewHost ( struct ICUIViewHost * ViewHostToInsert, long Index, enum cuiDockOperation Operation ) {
    HRESULT _hr = raw_InsertViewHost(ViewHostToInsert, Index, Operation);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(1445)
inline VGCore::ICUIViewHostPtr VGCore::ICUIDockHost::InsertView ( struct ICUIViewWindow * ViewToInsert, long Index, enum cuiDockOperation Operation ) {
    struct ICUIViewHost * _result = 0;
    HRESULT _hr = raw_InsertView(ViewToInsert, Index, Operation, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return ICUIViewHostPtr(_result, false);
}

#pragma implementation_key(1446)
inline VGCore::ICUIScreenRectPtr VGCore::ICUIDockHost::GetPosition ( ) {
    struct ICUIScreenRect * _result = 0;
    HRESULT _hr = get_Position(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return ICUIScreenRectPtr(_result, false);
}

//
// interface ICUIDockItem wrapper method implementations
//

#pragma implementation_key(1447)
inline _bstr_t VGCore::ICUIDockItem::GetID ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_ID(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(1448)
inline enum VGCore::cuiDockItemType VGCore::ICUIDockItem::GetType ( ) {
    enum cuiDockItemType _result;
    HRESULT _hr = get_Type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1449)
inline VGCore::ICUIViewHostPtr VGCore::ICUIDockItem::GetViewHost ( ) {
    struct ICUIViewHost * _result = 0;
    HRESULT _hr = get_ViewHost(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return ICUIViewHostPtr(_result, false);
}

#pragma implementation_key(1450)
inline VGCore::ICUIDockHostPtr VGCore::ICUIDockItem::GetDockHost ( ) {
    struct ICUIDockHost * _result = 0;
    HRESULT _hr = get_DockHost(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return ICUIDockHostPtr(_result, false);
}

#pragma implementation_key(1451)
inline long VGCore::ICUIDockItem::GetIndex ( ) {
    long _result = 0;
    HRESULT _hr = get_Index(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1452)
inline long VGCore::ICUIDockItem::GetRelativeSize ( ) {
    long _result = 0;
    HRESULT _hr = get_RelativeSize(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1453)
inline void VGCore::ICUIDockItem::PutRelativeSize ( long pVal ) {
    HRESULT _hr = put_RelativeSize(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(1454)
inline VGCore::ICUIScreenRectPtr VGCore::ICUIDockItem::GetPosition ( ) {
    struct ICUIScreenRect * _result = 0;
    HRESULT _hr = get_Position(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return ICUIScreenRectPtr(_result, false);
}

//
// interface ICUIDockItems wrapper method implementations
//

#pragma implementation_key(1455)
inline long VGCore::ICUIDockItems::GetCount ( ) {
    long _result = 0;
    HRESULT _hr = get_Count(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1456)
inline VGCore::ICUIDockItemPtr VGCore::ICUIDockItems::GetItem ( long Index ) {
    struct ICUIDockItem * _result = 0;
    HRESULT _hr = get_Item(Index, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return ICUIDockItemPtr(_result, false);
}

#pragma implementation_key(1457)
inline IUnknownPtr VGCore::ICUIDockItems::Get_NewEnum ( ) {
    IUnknown * _result = 0;
    HRESULT _hr = get__NewEnum(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IUnknownPtr(_result, false);
}

#pragma implementation_key(1458)
inline VGCore::ICUIDockItemPtr VGCore::ICUIDockItems::Find ( _bstr_t ID ) {
    struct ICUIDockItem * _result = 0;
    HRESULT _hr = raw_Find(ID, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return ICUIDockItemPtr(_result, false);
}

#pragma implementation_key(1459)
inline VGCore::ICUIDockItemPtr VGCore::ICUIDockItems::GetFirst ( ) {
    struct ICUIDockItem * _result = 0;
    HRESULT _hr = get_First(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return ICUIDockItemPtr(_result, false);
}

#pragma implementation_key(1460)
inline VGCore::ICUIDockItemPtr VGCore::ICUIDockItems::GetLast ( ) {
    struct ICUIDockItem * _result = 0;
    HRESULT _hr = get_Last(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return ICUIDockItemPtr(_result, false);
}

//
// interface ICUIDockHosts wrapper method implementations
//

#pragma implementation_key(1461)
inline long VGCore::ICUIDockHosts::GetCount ( ) {
    long _result = 0;
    HRESULT _hr = get_Count(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1462)
inline VGCore::ICUIDockHostPtr VGCore::ICUIDockHosts::GetItem ( long Index ) {
    struct ICUIDockHost * _result = 0;
    HRESULT _hr = get_Item(Index, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return ICUIDockHostPtr(_result, false);
}

#pragma implementation_key(1463)
inline IUnknownPtr VGCore::ICUIDockHosts::Get_NewEnum ( ) {
    IUnknown * _result = 0;
    HRESULT _hr = get__NewEnum(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IUnknownPtr(_result, false);
}

#pragma implementation_key(1464)
inline VGCore::ICUIDockHostPtr VGCore::ICUIDockHosts::Find ( _bstr_t ID ) {
    struct ICUIDockHost * _result = 0;
    HRESULT _hr = raw_Find(ID, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return ICUIDockHostPtr(_result, false);
}

#pragma implementation_key(1465)
inline VGCore::ICUIDockHostPtr VGCore::ICUIDockHosts::GetFirst ( ) {
    struct ICUIDockHost * _result = 0;
    HRESULT _hr = get_First(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return ICUIDockHostPtr(_result, false);
}

#pragma implementation_key(1466)
inline VGCore::ICUIDockHostPtr VGCore::ICUIDockHosts::GetLast ( ) {
    struct ICUIDockHost * _result = 0;
    HRESULT _hr = get_Last(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return ICUIDockHostPtr(_result, false);
}

//
// interface ICUIApplication wrapper method implementations
//

#pragma implementation_key(1467)
inline VGCore::ICUIDataContextPtr VGCore::ICUIApplication::GetDataContext ( ) {
    struct ICUIDataContext * _result = 0;
    HRESULT _hr = get_DataContext(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return ICUIDataContextPtr(_result, false);
}

#pragma implementation_key(1468)
inline VARIANT_BOOL VGCore::ICUIApplication::RegisterDataSource ( _bstr_t DataSourceName, struct ICUIDataSourceFactory * Factory, _bstr_t CategoryList, VARIANT_BOOL AutoCreateInstance ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_RegisterDataSource(DataSourceName, Factory, CategoryList, AutoCreateInstance, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1469)
inline VARIANT_BOOL VGCore::ICUIApplication::UnregisterDataSource ( _bstr_t DataSourceName ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_UnregisterDataSource(DataSourceName, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1470)
inline VGCore::ICUIImageListPtr VGCore::ICUIApplication::CreateImageList ( ) {
    struct ICUIImageList * _result = 0;
    HRESULT _hr = raw_CreateImageList(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return ICUIImageListPtr(_result, false);
}

#pragma implementation_key(1471)
inline VGCore::ICUIFrameWorkPtr VGCore::ICUIApplication::GetFrameWork ( ) {
    struct ICUIFrameWork * _result = 0;
    HRESULT _hr = get_FrameWork(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return ICUIFrameWorkPtr(_result, false);
}

#pragma implementation_key(1472)
inline VGCore::ICUIScreenRectPtr VGCore::ICUIApplication::CreateScreenRect ( long Left, long Top, long Width, long Height ) {
    struct ICUIScreenRect * _result = 0;
    HRESULT _hr = raw_CreateScreenRect(Left, Top, Width, Height, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return ICUIScreenRectPtr(_result, false);
}

#pragma implementation_key(1473)
inline VGCore::ICUIBitmapImagePtr VGCore::ICUIApplication::CreateBitmapImage ( const _variant_t & ImageData, long MaxSize ) {
    struct ICUIBitmapImage * _result = 0;
    HRESULT _hr = raw_CreateBitmapImage(ImageData, MaxSize, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return ICUIBitmapImagePtr(_result, false);
}

#pragma implementation_key(1474)
inline VGCore::ICUIStatusTextPtr VGCore::ICUIApplication::CreateStatusText ( ) {
    struct ICUIStatusText * _result = 0;
    HRESULT _hr = raw_CreateStatusText(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return ICUIStatusTextPtr(_result, false);
}

#pragma implementation_key(1475)
inline _bstr_t VGCore::ICUIApplication::LoadLocalizedString ( _bstr_t Guid ) {
    BSTR _result = 0;
    HRESULT _hr = raw_LoadLocalizedString(Guid, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(1476)
inline VGCore::ICUIDataSourceFactoryPtr VGCore::ICUIApplication::CreateDataSourceFactory ( IDispatch * DataSourceFactoryObject ) {
    struct ICUIDataSourceFactory * _result = 0;
    HRESULT _hr = raw_CreateDataSourceFactory(DataSourceFactoryObject, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return ICUIDataSourceFactoryPtr(_result, false);
}

//
// interface ICUIDataSourceProxy wrapper method implementations
//

#pragma implementation_key(1477)
inline HRESULT VGCore::ICUIDataSourceProxy::UpdateListeners ( _bstr_t ListenerNames ) {
    HRESULT _hr = raw_UpdateListeners(ListenerNames);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(1478)
inline VGCore::ICUIApplicationPtr VGCore::ICUIDataSourceProxy::GetApplication ( ) {
    struct ICUIApplication * _result = 0;
    HRESULT _hr = get_Application(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return ICUIApplicationPtr(_result, false);
}

#pragma implementation_key(1479)
inline _bstr_t VGCore::ICUIDataSourceProxy::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(1480)
inline HRESULT VGCore::ICUIDataSourceProxy::InvokeMethod ( _bstr_t MethodName ) {
    HRESULT _hr = raw_InvokeMethod(MethodName);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(1481)
inline _variant_t VGCore::ICUIDataSourceProxy::GetProperty ( _bstr_t PropertyName ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = raw_GetProperty(PropertyName, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

#pragma implementation_key(1482)
inline HRESULT VGCore::ICUIDataSourceProxy::SetProperty ( _bstr_t PropertyName, const _variant_t & Value ) {
    HRESULT _hr = raw_SetProperty(PropertyName, Value);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface ICUIDataContext wrapper method implementations
//

#pragma implementation_key(1483)
inline VGCore::ICUIDataContextPtr VGCore::ICUIDataContext::CreateChildDataContext ( _bstr_t CategoryList ) {
    struct ICUIDataContext * _result = 0;
    HRESULT _hr = raw_CreateChildDataContext(CategoryList, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return ICUIDataContextPtr(_result, false);
}

#pragma implementation_key(1484)
inline _bstr_t VGCore::ICUIDataContext::GetCategories ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Categories(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(1485)
inline VARIANT_BOOL VGCore::ICUIDataContext::HasCategory ( _bstr_t Category ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_HasCategory(Category, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1486)
inline VGCore::ICUIDataSourceProxyPtr VGCore::ICUIDataContext::AddDataSource ( _bstr_t DataSourceName, IDispatch * DataSourceObject ) {
    struct ICUIDataSourceProxy * _result = 0;
    HRESULT _hr = raw_AddDataSource(DataSourceName, DataSourceObject, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return ICUIDataSourceProxyPtr(_result, false);
}

#pragma implementation_key(1487)
inline VARIANT_BOOL VGCore::ICUIDataContext::ShowDialog ( _bstr_t dialogID ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_ShowDialog(dialogID, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1488)
inline VGCore::ICUIDataSourceProxyPtr VGCore::ICUIDataContext::GetDataSource ( _bstr_t DataSourceName ) {
    struct ICUIDataSourceProxy * _result = 0;
    HRESULT _hr = raw_GetDataSource(DataSourceName, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return ICUIDataSourceProxyPtr(_result, false);
}

//
// interface ICUIDataSourceFactory wrapper method implementations
//

#pragma implementation_key(1489)
inline IDispatchPtr VGCore::ICUIDataSourceFactory::CreateDataSource ( _bstr_t DataSourceName, struct ICUIDataSourceProxy * Proxy ) {
    IDispatch * _result = 0;
    HRESULT _hr = raw_CreateDataSource(DataSourceName, Proxy, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IDispatchPtr(_result, false);
}

//
// interface IVGDocument wrapper method implementations
//

#pragma implementation_key(1490)
inline VGCore::IVGApplicationPtr VGCore::IVGDocument::GetApplication ( ) {
    struct IVGApplication * _result = 0;
    HRESULT _hr = get_Application(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGApplicationPtr(_result, false);
}

#pragma implementation_key(1491)
inline VGCore::IVGDocumentsPtr VGCore::IVGDocument::GetParent ( ) {
    struct IVGDocuments * _result = 0;
    HRESULT _hr = get_Parent(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGDocumentsPtr(_result, false);
}

#pragma implementation_key(1492)
inline _bstr_t VGCore::IVGDocument::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(1493)
inline HRESULT VGCore::IVGDocument::SaveAs ( _bstr_t FileName, struct IVGStructSaveAsOptions * Options ) {
    HRESULT _hr = raw_SaveAs(FileName, Options);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(1494)
inline HRESULT VGCore::IVGDocument::Save ( ) {
    HRESULT _hr = raw_Save();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(1495)
inline VGCore::IVGPagesPtr VGCore::IVGDocument::GetPages ( ) {
    struct IVGPages * _result = 0;
    HRESULT _hr = get_Pages(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGPagesPtr(_result, false);
}

#pragma implementation_key(1496)
inline enum VGCore::cdrReferencePoint VGCore::IVGDocument::GetReferencePoint ( ) {
    enum cdrReferencePoint _result;
    HRESULT _hr = get_ReferencePoint(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1497)
inline void VGCore::IVGDocument::PutReferencePoint ( enum cdrReferencePoint pRefPoint ) {
    HRESULT _hr = put_ReferencePoint(pRefPoint);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(1498)
inline VARIANT_BOOL VGCore::IVGDocument::GetApplyToDuplicate ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_ApplyToDuplicate(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1499)
inline void VGCore::IVGDocument::PutApplyToDuplicate ( VARIANT_BOOL ApplyToDuplicate ) {
    HRESULT _hr = put_ApplyToDuplicate(ApplyToDuplicate);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(1500)
inline VGCore::IVGPagePtr VGCore::IVGDocument::GetActivePage ( ) {
    struct IVGPage * _result = 0;
    HRESULT _hr = get_ActivePage(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGPagePtr(_result, false);
}

#pragma implementation_key(1501)
inline VGCore::IVGLayerPtr VGCore::IVGDocument::GetActiveLayer ( ) {
    struct IVGLayer * _result = 0;
    HRESULT _hr = get_ActiveLayer(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGLayerPtr(_result, false);
}

#pragma implementation_key(1502)
inline VGCore::IVGWindowsPtr VGCore::IVGDocument::GetWindows ( ) {
    struct IVGWindows * _result = 0;
    HRESULT _hr = get_Windows(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGWindowsPtr(_result, false);
}

#pragma implementation_key(1503)
inline VGCore::IVGWindowPtr VGCore::IVGDocument::GetActiveWindow ( ) {
    struct IVGWindow * _result = 0;
    HRESULT _hr = get_ActiveWindow(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGWindowPtr(_result, false);
}

#pragma implementation_key(1504)
inline HRESULT VGCore::IVGDocument::Close ( ) {
    HRESULT _hr = raw_Close();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(1505)
inline HRESULT VGCore::IVGDocument::Undo ( long Levels ) {
    HRESULT _hr = raw_Undo(Levels);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(1506)
inline HRESULT VGCore::IVGDocument::Redo ( long Levels ) {
    HRESULT _hr = raw_Redo(Levels);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(1507)
inline HRESULT VGCore::IVGDocument::Repeat ( ) {
    HRESULT _hr = raw_Repeat();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(1508)
inline HRESULT VGCore::IVGDocument::Activate ( ) {
    HRESULT _hr = raw_Activate();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(1509)
inline enum VGCore::cdrUnit VGCore::IVGDocument::GetUnit ( ) {
    enum cdrUnit _result;
    HRESULT _hr = get_Unit(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1510)
inline void VGCore::IVGDocument::PutUnit ( enum cdrUnit pnUnit ) {
    HRESULT _hr = put_Unit(pnUnit);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(1511)
inline double VGCore::IVGDocument::GetDrawingOriginX ( ) {
    double _result = 0;
    HRESULT _hr = get_DrawingOriginX(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1512)
inline void VGCore::IVGDocument::PutDrawingOriginX ( double plX ) {
    HRESULT _hr = put_DrawingOriginX(plX);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(1513)
inline double VGCore::IVGDocument::GetDrawingOriginY ( ) {
    double _result = 0;
    HRESULT _hr = get_DrawingOriginY(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1514)
inline void VGCore::IVGDocument::PutDrawingOriginY ( double plY ) {
    HRESULT _hr = put_DrawingOriginY(plY);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(1515)
inline VGCore::IVGPagePtr VGCore::IVGDocument::AddPages ( long NumberOfPages ) {
    struct IVGPage * _result = 0;
    HRESULT _hr = raw_AddPages(NumberOfPages, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGPagePtr(_result, false);
}

#pragma implementation_key(1516)
inline VGCore::IVGPagePtr VGCore::IVGDocument::InsertPages ( long NumberOfPages, VARIANT_BOOL BeforePage, long Page ) {
    struct IVGPage * _result = 0;
    HRESULT _hr = raw_InsertPages(NumberOfPages, BeforePage, Page, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGPagePtr(_result, false);
}

#pragma implementation_key(1517)
inline VGCore::IVGShapePtr VGCore::IVGDocument::Selection ( ) {
    struct IVGShape * _result = 0;
    HRESULT _hr = raw_Selection(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGShapePtr(_result, false);
}

#pragma implementation_key(1518)
inline HRESULT VGCore::IVGDocument::ClearSelection ( ) {
    HRESULT _hr = raw_ClearSelection();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(1519)
inline HRESULT VGCore::IVGDocument::Export ( _bstr_t FileName, enum cdrFilter Filter, enum cdrExportRange Range, struct IVGStructExportOptions * Options, struct IVGStructPaletteOptions * PaletteOptions ) {
    HRESULT _hr = raw_Export(FileName, Filter, Range, Options, PaletteOptions);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(1520)
inline HRESULT VGCore::IVGDocument::ResolveAllBitmapsLinks ( ) {
    HRESULT _hr = raw_ResolveAllBitmapsLinks();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(1521)
inline VARIANT_BOOL VGCore::IVGDocument::GetDirty ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_Dirty(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1522)
inline void VGCore::IVGDocument::PutDirty ( VARIANT_BOOL Dirty ) {
    HRESULT _hr = put_Dirty(Dirty);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(1523)
inline long VGCore::IVGDocument::GetUserClick ( double * x, double * y, long * ShiftState, long TimeOut, VARIANT_BOOL Snap, enum cdrCursorShape CursorShape ) {
    long _result = 0;
    HRESULT _hr = raw_GetUserClick(x, y, ShiftState, TimeOut, Snap, CursorShape, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1524)
inline long VGCore::IVGDocument::GetUserArea ( double * x1, double * y1, double * x2, double * y2, long * ShiftState, long TimeOut, VARIANT_BOOL Snap, enum cdrCursorShape CursorShape ) {
    long _result = 0;
    HRESULT _hr = raw_GetUserArea(x1, y1, x2, y2, ShiftState, TimeOut, Snap, CursorShape, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1525)
inline HRESULT VGCore::IVGDocument::BeginCommandGroup ( _bstr_t CommandName ) {
    HRESULT _hr = raw_BeginCommandGroup(CommandName);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(1526)
inline HRESULT VGCore::IVGDocument::EndCommandGroup ( ) {
    HRESULT _hr = raw_EndCommandGroup();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(1527)
inline _bstr_t VGCore::IVGDocument::GetFilePath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_FilePath(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(1528)
inline _bstr_t VGCore::IVGDocument::GetFileName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_FileName(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(1529)
inline _bstr_t VGCore::IVGDocument::GetFullFileName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_FullFileName(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(1530)
inline long VGCore::IVGDocument::GetResolution ( ) {
    long _result = 0;
    HRESULT _hr = get_Resolution(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1531)
inline void VGCore::IVGDocument::PutResolution ( long pResolution ) {
    HRESULT _hr = put_Resolution(pResolution);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(1532)
inline enum VGCore::cdrShapeEnumDirection VGCore::IVGDocument::GetShapeEnumDirection ( ) {
    enum cdrShapeEnumDirection _result;
    HRESULT _hr = get_ShapeEnumDirection(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1533)
inline void VGCore::IVGDocument::PutShapeEnumDirection ( enum cdrShapeEnumDirection peDirection ) {
    HRESULT _hr = put_ShapeEnumDirection(peDirection);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(1534)
inline VGCore::IVGShapeRangePtr VGCore::IVGDocument::GetSelectionRange ( ) {
    struct IVGShapeRange * _result = 0;
    HRESULT _hr = get_SelectionRange(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGShapeRangePtr(_result, false);
}

#pragma implementation_key(1535)
inline VGCore::IVGRulersPtr VGCore::IVGDocument::GetRulers ( ) {
    struct IVGRulers * _result = 0;
    HRESULT _hr = get_Rulers(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGRulersPtr(_result, false);
}

#pragma implementation_key(1536)
inline VGCore::IVGGridPtr VGCore::IVGDocument::GetGrid ( ) {
    struct IVGGrid * _result = 0;
    HRESULT _hr = get_Grid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGGridPtr(_result, false);
}

#pragma implementation_key(1537)
inline VGCore::IVGViewsPtr VGCore::IVGDocument::GetViews ( ) {
    struct IVGViews * _result = 0;
    HRESULT _hr = get_Views(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGViewsPtr(_result, false);
}

#pragma implementation_key(1538)
inline VGCore::IVGViewPtr VGCore::IVGDocument::CreateView ( _bstr_t Name, double OriginX, double OriginY, long Zoom, struct IVGPage * Page ) {
    struct IVGView * _result = 0;
    HRESULT _hr = raw_CreateView(Name, OriginX, OriginY, Zoom, Page, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGViewPtr(_result, false);
}

#pragma implementation_key(1539)
inline VGCore::IVGPowerClipPtr VGCore::IVGDocument::GetActivePowerClip ( ) {
    struct IVGPowerClip * _result = 0;
    HRESULT _hr = get_ActivePowerClip(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGPowerClipPtr(_result, false);
}

#pragma implementation_key(1540)
inline long VGCore::IVGDocument::AdviseEvents ( IDispatch * EventSink ) {
    long _result = 0;
    HRESULT _hr = raw_AdviseEvents(EventSink, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1541)
inline HRESULT VGCore::IVGDocument::UnadviseEvents ( long Cookie ) {
    HRESULT _hr = raw_UnadviseEvents(Cookie);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(1542)
inline double VGCore::IVGDocument::GetWorldScale ( ) {
    double _result = 0;
    HRESULT _hr = get_WorldScale(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1543)
inline void VGCore::IVGDocument::PutWorldScale ( double Scale ) {
    HRESULT _hr = put_WorldScale(Scale);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(1544)
inline HRESULT VGCore::IVGDocument::PrintOut ( ) {
    HRESULT _hr = raw_PrintOut();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(1545)
inline VGCore::IVGShapePtr VGCore::IVGDocument::GetActiveShape ( ) {
    struct IVGShape * _result = 0;
    HRESULT _hr = get_ActiveShape(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGShapePtr(_result, false);
}

#pragma implementation_key(1546)
inline long VGCore::IVGDocument::GetCurvePrecision ( ) {
    long _result = 0;
    HRESULT _hr = get_CurvePrecision(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1547)
inline VGCore::IVGPagePtr VGCore::IVGDocument::AddPagesEx ( long NumberOfPages, double Width, double Height ) {
    struct IVGPage * _result = 0;
    HRESULT _hr = raw_AddPagesEx(NumberOfPages, Width, Height, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGPagePtr(_result, false);
}

#pragma implementation_key(1548)
inline VGCore::IVGPagePtr VGCore::IVGDocument::InsertPagesEx ( long NumberOfPages, VARIANT_BOOL BeforePage, long Page, double Width, double Height ) {
    struct IVGPage * _result = 0;
    HRESULT _hr = raw_InsertPagesEx(NumberOfPages, BeforePage, Page, Width, Height, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGPagePtr(_result, false);
}

#pragma implementation_key(1549)
inline _bstr_t VGCore::IVGDocument::GetTitle ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Title(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(1550)
inline HRESULT VGCore::IVGDocument::SaveSettings ( _bstr_t Tag ) {
    HRESULT _hr = raw_SaveSettings(Tag);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(1551)
inline HRESULT VGCore::IVGDocument::RestoreSettings ( _bstr_t Tag ) {
    HRESULT _hr = raw_RestoreSettings(Tag);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(1552)
inline VARIANT_BOOL VGCore::IVGDocument::GetActive ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_Active(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1553)
inline long VGCore::IVGDocument::GetIndex ( ) {
    long _result = 0;
    HRESULT _hr = get_Index(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1554)
inline VGCore::ICorelExportFilterPtr VGCore::IVGDocument::ExportEx ( _bstr_t FileName, enum cdrFilter Filter, enum cdrExportRange Range, struct IVGStructExportOptions * Options, struct IVGStructPaletteOptions * PaletteOptions ) {
    struct ICorelExportFilter * _result = 0;
    HRESULT _hr = raw_ExportEx(FileName, Filter, Range, Options, PaletteOptions, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return ICorelExportFilterPtr(_result, false);
}

#pragma implementation_key(1555)
inline VGCore::ICorelExportFilterPtr VGCore::IVGDocument::ExportBitmap ( _bstr_t FileName, enum cdrFilter Filter, enum cdrExportRange Range, enum cdrImageType ImageType, long Width, long Height, long ResolutionX, long ResolutionY, enum cdrAntiAliasingType AntiAliasingType, VARIANT_BOOL Dithered, VARIANT_BOOL Transparent, VARIANT_BOOL UseColorProfile, VARIANT_BOOL MaintainLayers, enum cdrCompressionType Compression, struct IVGStructPaletteOptions * PaletteOptions, struct IVGRect * ExportArea ) {
    struct ICorelExportFilter * _result = 0;
    HRESULT _hr = raw_ExportBitmap(FileName, Filter, Range, ImageType, Width, Height, ResolutionX, ResolutionY, AntiAliasingType, Dithered, Transparent, UseColorProfile, MaintainLayers, Compression, PaletteOptions, ExportArea, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return ICorelExportFilterPtr(_result, false);
}

#pragma implementation_key(1556)
inline VARIANT_BOOL VGCore::IVGDocument::GetEditAcrossLayers ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_EditAcrossLayers(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1557)
inline void VGCore::IVGDocument::PutEditAcrossLayers ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_EditAcrossLayers(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(1558)
inline VGCore::IVGPropertiesPtr VGCore::IVGDocument::GetProperties ( ) {
    struct IVGProperties * _result = 0;
    HRESULT _hr = get_Properties(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGPropertiesPtr(_result, false);
}

#pragma implementation_key(1559)
inline void VGCore::IVGDocument::PutCurvePrecision ( long lpPrec ) {
    HRESULT _hr = put_CurvePrecision(lpPrec);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(1560)
inline VGCore::IPrnVBAPrintSettingsPtr VGCore::IVGDocument::GetPrintSettings ( ) {
    struct IPrnVBAPrintSettings * _result = 0;
    HRESULT _hr = get_PrintSettings(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IPrnVBAPrintSettingsPtr(_result, false);
}

#pragma implementation_key(1561)
inline _bstr_t VGCore::IVGDocument::GetKeywords ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Keywords(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(1562)
inline void VGCore::IVGDocument::PutKeywords ( _bstr_t pVal ) {
    HRESULT _hr = put_Keywords(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(1563)
inline _bstr_t VGCore::IVGDocument::GetNotes ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Notes(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(1564)
inline void VGCore::IVGDocument::PutNotes ( _bstr_t pVal ) {
    HRESULT _hr = put_Notes(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(1565)
inline VARIANT_BOOL VGCore::IVGDocument::GetPreserveSelection ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_PreserveSelection(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1566)
inline void VGCore::IVGDocument::PutPreserveSelection ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_PreserveSelection(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(1567)
inline HRESULT VGCore::IVGDocument::ResetSettings ( ) {
    HRESULT _hr = raw_ResetSettings();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(1568)
inline VGCore::IVGDataFieldsPtr VGCore::IVGDocument::GetDataFields ( ) {
    struct IVGDataFields * _result = 0;
    HRESULT _hr = get_DataFields(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGDataFieldsPtr(_result, false);
}

#pragma implementation_key(1569)
inline VGCore::IPDFVBASettingsPtr VGCore::IVGDocument::GetPDFSettings ( ) {
    struct IPDFVBASettings * _result = 0;
    HRESULT _hr = get_PDFSettings(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IPDFVBASettingsPtr(_result, false);
}

#pragma implementation_key(1570)
inline HRESULT VGCore::IVGDocument::PublishToPDF ( _bstr_t FileName ) {
    HRESULT _hr = raw_PublishToPDF(FileName);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(1571)
inline VGCore::IVGSelectionInformationPtr VGCore::IVGDocument::GetSelectionInfo ( ) {
    struct IVGSelectionInformation * _result = 0;
    HRESULT _hr = get_SelectionInfo(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGSelectionInformationPtr(_result, false);
}

#pragma implementation_key(1572)
inline VGCore::IVGPageSizesPtr VGCore::IVGDocument::GetPageSizes ( ) {
    struct IVGPageSizes * _result = 0;
    HRESULT _hr = get_PageSizes(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGPageSizesPtr(_result, false);
}

#pragma implementation_key(1573)
inline VGCore::IVGComponentsPtr VGCore::IVGDocument::GetComponents ( ) {
    struct IVGComponents * _result = 0;
    HRESULT _hr = get_Components(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGComponentsPtr(_result, false);
}

#pragma implementation_key(1574)
inline VGCore::IVGSymbolLibraryPtr VGCore::IVGDocument::GetSymbolLibrary ( ) {
    struct IVGSymbolLibrary * _result = 0;
    HRESULT _hr = get_SymbolLibrary(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGSymbolLibraryPtr(_result, false);
}

#pragma implementation_key(1575)
inline VGCore::IVGCurvePtr VGCore::IVGDocument::CreateCurve ( ) {
    struct IVGCurve * _result = 0;
    HRESULT _hr = raw_CreateCurve(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGCurvePtr(_result, false);
}

#pragma implementation_key(1576)
inline VGCore::IVGCurvePtr VGCore::IVGDocument::CreateCurveFromArray ( SAFEARRAY * * Source, long NumElements ) {
    struct IVGCurve * _result = 0;
    HRESULT _hr = raw_CreateCurveFromArray(Source, NumElements, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGCurvePtr(_result, false);
}

#pragma implementation_key(1577)
inline HRESULT VGCore::IVGDocument::LoadStyleSheet ( _bstr_t FileName ) {
    HRESULT _hr = raw_LoadStyleSheet(FileName);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(1578)
inline HRESULT VGCore::IVGDocument::SaveStyleSheet ( _bstr_t FileName ) {
    HRESULT _hr = raw_SaveStyleSheet(FileName);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(1579)
inline HRESULT VGCore::IVGDocument::SaveStyleSheetAsDefault ( ) {
    HRESULT _hr = raw_SaveStyleSheetAsDefault();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(1580)
inline HRESULT VGCore::IVGDocument::CreateSelection ( SAFEARRAY * * ShapeArray ) {
    HRESULT _hr = raw_CreateSelection(ShapeArray);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(1581)
inline HRESULT VGCore::IVGDocument::AddToSelection ( SAFEARRAY * * ShapeArray ) {
    HRESULT _hr = raw_AddToSelection(ShapeArray);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(1582)
inline HRESULT VGCore::IVGDocument::RemoveFromSelection ( SAFEARRAY * * ShapeArray ) {
    HRESULT _hr = raw_RemoveFromSelection(ShapeArray);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(1583)
inline VGCore::IVGShapesPtr VGCore::IVGDocument::GetSelectableShapes ( ) {
    struct IVGShapes * _result = 0;
    HRESULT _hr = get_SelectableShapes(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGShapesPtr(_result, false);
}

#pragma implementation_key(1584)
inline double VGCore::IVGDocument::ToUnits ( double Value, enum cdrUnit FromUnit ) {
    double _result = 0;
    HRESULT _hr = raw_ToUnits(Value, FromUnit, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1585)
inline double VGCore::IVGDocument::FromUnits ( double Value, enum cdrUnit ToUnit ) {
    double _result = 0;
    HRESULT _hr = raw_FromUnits(Value, ToUnit, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1586)
inline long VGCore::IVGDocument::GetResolutionX ( ) {
    long _result = 0;
    HRESULT _hr = get_ResolutionX(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1587)
inline void VGCore::IVGDocument::PutResolutionX ( long pResolution ) {
    HRESULT _hr = put_ResolutionX(pResolution);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(1588)
inline long VGCore::IVGDocument::GetResolutionY ( ) {
    long _result = 0;
    HRESULT _hr = get_ResolutionY(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1589)
inline void VGCore::IVGDocument::PutResolutionY ( long pResolution ) {
    HRESULT _hr = put_ResolutionY(pResolution);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(1590)
inline VGCore::IVGPagePtr VGCore::IVGDocument::GetMasterPage ( ) {
    struct IVGPage * _result = 0;
    HRESULT _hr = get_MasterPage(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGPagePtr(_result, false);
}

#pragma implementation_key(1591)
inline VARIANT_BOOL VGCore::IVGDocument::Revert ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_Revert(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1592)
inline _bstr_t VGCore::IVGDocument::GetCodeName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_CodeName(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(1593)
inline _bstr_t VGCore::IVGDocument::Get_CodeName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get__CodeName(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(1594)
inline void VGCore::IVGDocument::Put_CodeName ( _bstr_t pVal ) {
    HRESULT _hr = put__CodeName(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(1595)
inline void VGCore::IVGDocument::PutName ( _bstr_t pbstrName ) {
    HRESULT _hr = put_Name(pbstrName);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(1596)
inline void VGCore::IVGDocument::PutFullFileName ( _bstr_t pFullFileName ) {
    HRESULT _hr = put_FullFileName(pFullFileName);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(1597)
inline VGCore::IVGTreeNodePtr VGCore::IVGDocument::GetTreeRoot ( ) {
    struct IVGTreeNode * _result = 0;
    HRESULT _hr = get_TreeRoot(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGTreeNodePtr(_result, false);
}

#pragma implementation_key(1598)
inline VGCore::IVGTreeManagerPtr VGCore::IVGDocument::GetTreeManager ( ) {
    struct IVGTreeManager * _result = 0;
    HRESULT _hr = get_TreeManager(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGTreeManagerPtr(_result, false);
}

#pragma implementation_key(1599)
inline VGCore::IVGShapePtr VGCore::IVGDocument::LogCreateShape ( struct IVGShape * VirtualShape ) {
    struct IVGShape * _result = 0;
    HRESULT _hr = raw_LogCreateShape(VirtualShape, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGShapePtr(_result, false);
}

#pragma implementation_key(1600)
inline VGCore::IVGShapeRangePtr VGCore::IVGDocument::LogCreateShapeRange ( struct IVGShapeRange * VirtualShapeRange ) {
    struct IVGShapeRange * _result = 0;
    HRESULT _hr = raw_LogCreateShapeRange(VirtualShapeRange, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGShapeRangePtr(_result, false);
}

#pragma implementation_key(1601)
inline VGCore::IVGFillPtr VGCore::IVGDocument::CreateFill ( _bstr_t FillString ) {
    struct IVGFill * _result = 0;
    HRESULT _hr = raw_CreateFill(FillString, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGFillPtr(_result, false);
}

#pragma implementation_key(1602)
inline VGCore::IVGOutlinePtr VGCore::IVGDocument::CreateOutline ( _bstr_t OutlineString ) {
    struct IVGOutline * _result = 0;
    HRESULT _hr = raw_CreateOutline(OutlineString, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGOutlinePtr(_result, false);
}

#pragma implementation_key(1603)
inline VGCore::IVGHatchLibrariesPtr VGCore::IVGDocument::GetHatchLibraries ( ) {
    struct IVGHatchLibraries * _result = 0;
    HRESULT _hr = get_HatchLibraries(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGHatchLibrariesPtr(_result, false);
}

#pragma implementation_key(1604)
inline VGCore::IVGShapeRangePtr VGCore::IVGDocument::CreateShapeRangeFromArray ( SAFEARRAY * * ShapeArray ) {
    struct IVGShapeRange * _result = 0;
    HRESULT _hr = raw_CreateShapeRangeFromArray(ShapeArray, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGShapeRangePtr(_result, false);
}

#pragma implementation_key(1605)
inline HRESULT VGCore::IVGDocument::ClearUndoList ( ) {
    HRESULT _hr = raw_ClearUndoList();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(1606)
inline double VGCore::IVGDocument::GetSourcePlatformVersion ( ) {
    double _result = 0;
    HRESULT _hr = get_SourcePlatformVersion(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1607)
inline void VGCore::IVGDocument::PutSourcePlatformVersion ( double pVal ) {
    HRESULT _hr = put_SourcePlatformVersion(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(1608)
inline enum VGCore::cdrFilter VGCore::IVGDocument::GetSourceFormat ( ) {
    enum cdrFilter _result;
    HRESULT _hr = get_SourceFormat(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1609)
inline VARIANT_BOOL VGCore::IVGDocument::GetIsCurrentVersion ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsCurrentVersion(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1610)
inline enum VGCore::cdrFileVersion VGCore::IVGDocument::GetSourceFileVersion ( ) {
    enum cdrFileVersion _result;
    HRESULT _hr = get_SourceFileVersion(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1611)
inline void VGCore::IVGDocument::PutSourceFileVersion ( enum cdrFileVersion pVal ) {
    HRESULT _hr = put_SourceFileVersion(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(1612)
inline VGCore::IVGFillPtr VGCore::IVGDocument::CreateUniformFill ( struct IVGColor * Color ) {
    struct IVGFill * _result = 0;
    HRESULT _hr = raw_CreateUniformFill(Color, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGFillPtr(_result, false);
}

#pragma implementation_key(1613)
inline VGCore::IVGMetadataPtr VGCore::IVGDocument::GetMetadata ( ) {
    struct IVGMetadata * _result = 0;
    HRESULT _hr = get_Metadata(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGMetadataPtr(_result, false);
}

#pragma implementation_key(1614)
inline enum VGCore::cdrDocLayout VGCore::IVGDocument::GetLayout ( ) {
    enum cdrDocLayout _result;
    HRESULT _hr = get_Layout(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1615)
inline void VGCore::IVGDocument::PutLayout ( enum cdrDocLayout pVal ) {
    HRESULT _hr = put_Layout(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(1616)
inline VARIANT_BOOL VGCore::IVGDocument::GetFacingPages ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_FacingPages(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1617)
inline void VGCore::IVGDocument::PutFacingPages ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_FacingPages(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(1618)
inline VARIANT_BOOL VGCore::IVGDocument::GetFirstPageOnRightSide ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_FirstPageOnRightSide(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1619)
inline void VGCore::IVGDocument::PutFirstPageOnRightSide ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_FirstPageOnRightSide(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(1620)
inline HRESULT VGCore::IVGDocument::SetLayout ( enum cdrDocLayout Layout, VARIANT_BOOL FacingPages, VARIANT_BOOL StartOnRightSide ) {
    HRESULT _hr = raw_SetLayout(Layout, FacingPages, StartOnRightSide);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(1621)
inline VGCore::IVGSpreadsPtr VGCore::IVGDocument::GetSpreads ( ) {
    struct IVGSpreads * _result = 0;
    HRESULT _hr = get_Spreads(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGSpreadsPtr(_result, false);
}

#pragma implementation_key(1622)
inline VGCore::IVGSpreadPtr VGCore::IVGDocument::GetActiveSpread ( ) {
    struct IVGSpread * _result = 0;
    HRESULT _hr = get_ActiveSpread(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGSpreadPtr(_result, false);
}

#pragma implementation_key(1623)
inline VGCore::IVGArrowHeadPtr VGCore::IVGDocument::CreateArrowHead ( struct IVGCurve * Curve ) {
    struct IVGArrowHead * _result = 0;
    HRESULT _hr = raw_CreateArrowHead(Curve, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGArrowHeadPtr(_result, false);
}

#pragma implementation_key(1624)
inline VGCore::IVGArrowHeadPtr VGCore::IVGDocument::CreateArrowHeadEx ( struct IVGCurve * Curve, double CenterX, double CenterY, double OutlineWidthScale, double LineOffset ) {
    struct IVGArrowHead * _result = 0;
    HRESULT _hr = raw_CreateArrowHeadEx(Curve, CenterX, CenterY, OutlineWidthScale, LineOffset, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGArrowHeadPtr(_result, false);
}

#pragma implementation_key(1625)
inline VARIANT_BOOL VGCore::IVGDocument::DeletePages ( long StartPage, long NumPages ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_DeletePages(StartPage, NumPages, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1626)
inline VGCore::IVGArrowHeadPtr VGCore::IVGDocument::CreateArrowHead2 ( struct IVGCurve * Curve, _bstr_t Name ) {
    struct IVGArrowHead * _result = 0;
    HRESULT _hr = raw_CreateArrowHead2(Curve, Name, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGArrowHeadPtr(_result, false);
}

#pragma implementation_key(1627)
inline VGCore::IVGArrowHeadPtr VGCore::IVGDocument::CreateArrowHeadEx2 ( struct IVGCurve * Curve, _bstr_t Name, double CenterX, double CenterY, double OutlineWidthScale, double LineOffset ) {
    struct IVGArrowHead * _result = 0;
    HRESULT _hr = raw_CreateArrowHeadEx2(Curve, Name, CenterX, CenterY, OutlineWidthScale, LineOffset, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGArrowHeadPtr(_result, false);
}

#pragma implementation_key(1628)
inline VGCore::IVGArrowHeadOptionsPtr VGCore::IVGDocument::CreateArrowHeadOptions ( double Length, double Width, double OffsetX, double OffsetY, double RotationAngle, VARIANT_BOOL FlipHorizontal, VARIANT_BOOL FlipVertical ) {
    struct IVGArrowHeadOptions * _result = 0;
    HRESULT _hr = raw_CreateArrowHeadOptions(Length, Width, OffsetX, OffsetY, RotationAngle, FlipHorizontal, FlipVertical, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGArrowHeadOptionsPtr(_result, false);
}

#pragma implementation_key(1629)
inline HRESULT VGCore::IVGDocument::SaveAsCopy ( _bstr_t FileName, struct IVGStructSaveAsOptions * Options ) {
    HRESULT _hr = raw_SaveAsCopy(FileName, Options);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(1630)
inline VGCore::IVGSnapPointPtr VGCore::IVGDocument::CreateFreeSnapPoint ( double PositionX, double PositionY ) {
    struct IVGSnapPoint * _result = 0;
    HRESULT _hr = raw_CreateFreeSnapPoint(PositionX, PositionY, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGSnapPointPtr(_result, false);
}

#pragma implementation_key(1631)
inline VGCore::IVGBSplinePtr VGCore::IVGDocument::CreateBSpline ( long NumControlPoints, VARIANT_BOOL Closed ) {
    struct IVGBSpline * _result = 0;
    HRESULT _hr = raw_CreateBSpline(NumControlPoints, Closed, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGBSplinePtr(_result, false);
}

#pragma implementation_key(1632)
inline VGCore::IVGDocumentPtr VGCore::IVGDocument::Duplicate ( ) {
    struct IVGDocument * _result = 0;
    HRESULT _hr = raw_Duplicate(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGDocumentPtr(_result, false);
}

#pragma implementation_key(1633)
inline VGCore::IVGDocumentPtr VGCore::IVGDocument::Clone ( ) {
    struct IVGDocument * _result = 0;
    HRESULT _hr = raw_Clone(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGDocumentPtr(_result, false);
}

#pragma implementation_key(1634)
inline VARIANT_BOOL VGCore::IVGDocument::GetIsTemporary ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsTemporary(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1635)
inline VGCore::IVGColorContextPtr VGCore::IVGDocument::GetColorContext ( ) {
    struct IVGColorContext * _result = 0;
    HRESULT _hr = get_ColorContext(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGColorContextPtr(_result, false);
}

#pragma implementation_key(1636)
inline HRESULT VGCore::IVGDocument::AssignColorContext ( struct IVGColorContext * ColorContext ) {
    HRESULT _hr = raw_AssignColorContext(ColorContext);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(1637)
inline HRESULT VGCore::IVGDocument::ConvertToColorContext ( struct IVGColorContext * ColorContext ) {
    HRESULT _hr = raw_ConvertToColorContext(ColorContext);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(1638)
inline HRESULT VGCore::IVGDocument::PrintColorProof ( struct IVGProofColorSettings * ProofSettings ) {
    HRESULT _hr = raw_PrintColorProof(ProofSettings);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(1639)
inline VGCore::IVGPalettePtr VGCore::IVGDocument::GetPalette ( ) {
    struct IVGPalette * _result = 0;
    HRESULT _hr = get_Palette(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGPalettePtr(_result, false);
}

#pragma implementation_key(1640)
inline long VGCore::IVGDocument::GetTextFormatter ( ) {
    long _result = 0;
    HRESULT _hr = get_TextFormatter(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1641)
inline void VGCore::IVGDocument::PutTextFormatter ( long pVal ) {
    HRESULT _hr = put_TextFormatter(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(1642)
inline VGCore::IVGStyleSheetPtr VGCore::IVGDocument::GetStyleSheet ( ) {
    struct IVGStyleSheet * _result = 0;
    HRESULT _hr = get_StyleSheet(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGStyleSheetPtr(_result, false);
}

#pragma implementation_key(1643)
inline HRESULT VGCore::IVGDocument::InteractiveImport ( SAFEARRAY * * FileNames ) {
    HRESULT _hr = raw_InteractiveImport(FileNames);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(1644)
inline VARIANT_BOOL VGCore::IVGDocument::AddColorsToDocPalette ( VARIANT_BOOL SelectedOnly, long MaxColorsPerBitmap ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_AddColorsToDocPalette(SelectedOnly, MaxColorsPerBitmap, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1645)
inline long VGCore::IVGDocument::CreateColorStyles ( VARIANT_BOOL UseFills, VARIANT_BOOL UseOutlines, VARIANT_BOOL SelectedOnly, long NumberOfColorHarmonies, enum cdrColorType ConvertColorsTo ) {
    long _result = 0;
    HRESULT _hr = raw_CreateColorStyles(UseFills, UseOutlines, SelectedOnly, NumberOfColorHarmonies, ConvertColorsTo, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1646)
inline VGCore::IVGCurvePtr VGCore::IVGDocument::CreateCurveFitToPoints ( struct IVGPointRange * Points, VARIANT_BOOL UseCurrentViewForTolerance, double tolerance ) {
    struct IVGCurve * _result = 0;
    HRESULT _hr = raw_CreateCurveFitToPoints(Points, UseCurrentViewForTolerance, tolerance, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGCurvePtr(_result, false);
}

#pragma implementation_key(1647)
inline VGCore::IVGCurvePtr VGCore::IVGDocument::CreateCurveFitToPointsAndCusps ( struct IVGPointRange * Points, SAFEARRAY * * CuspIndexArray, VARIANT_BOOL UseCurrentViewForTolerance, double tolerance ) {
    struct IVGCurve * _result = 0;
    HRESULT _hr = raw_CreateCurveFitToPointsAndCusps(Points, CuspIndexArray, UseCurrentViewForTolerance, tolerance, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGCurvePtr(_result, false);
}

#pragma implementation_key(1648)
inline VGCore::IVGColorPtr VGCore::IVGDocument::SampleColorAtPoint ( double x, double y, enum cdrColorType ColorType ) {
    struct IVGColor * _result = 0;
    HRESULT _hr = raw_SampleColorAtPoint(x, y, ColorType, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGColorPtr(_result, false);
}

#pragma implementation_key(1649)
inline VGCore::IVGColorPtr VGCore::IVGDocument::SampleColorInArea ( double x1, double y1, double x2, double y2, long XSamples, long YSamples, enum cdrColorType ColorType ) {
    struct IVGColor * _result = 0;
    HRESULT _hr = raw_SampleColorInArea(x1, y1, x2, y2, XSamples, YSamples, ColorType, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGColorPtr(_result, false);
}

#pragma implementation_key(1650)
inline HRESULT VGCore::IVGDocument::ShowAllHiddenObjects ( ) {
    HRESULT _hr = raw_ShowAllHiddenObjects();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(1651)
inline HRESULT VGCore::IVGDocument::InteractiveImportWithContentIdentifier ( SAFEARRAY * * FileNames, SAFEARRAY * * ContentIdentifiers ) {
    HRESULT _hr = raw_InteractiveImportWithContentIdentifier(FileNames, ContentIdentifiers);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(1652)
inline HRESULT VGCore::IVGDocument::ReplaceContentByIdentifier ( SAFEARRAY * * ContentIdentifiers, SAFEARRAY * * FileNames ) {
    HRESULT _hr = raw_ReplaceContentByIdentifier(ContentIdentifiers, FileNames);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(1653)
inline SAFEARRAY * VGCore::IVGDocument::GetContentIdentifiers ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = get_ContentIdentifiers(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1654)
inline _variant_t VGCore::IVGDocument::CustomCommand ( _bstr_t ComponentID, _bstr_t CommandID, SAFEARRAY * * Parameters ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = raw_CustomCommand(ComponentID, CommandID, Parameters, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

#pragma implementation_key(1655)
inline VGCore::IVGMathUtilsPtr VGCore::IVGDocument::GetMath ( ) {
    struct IVGMathUtils * _result = 0;
    HRESULT _hr = get_Math(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGMathUtilsPtr(_result, false);
}

#pragma implementation_key(1656)
inline VGCore::IVGImagePtr VGCore::IVGDocument::CreateImage ( enum cdrImageType ImageType, long Width, long Height, struct IVGColor * FillColor ) {
    struct IVGImage * _result = 0;
    HRESULT _hr = raw_CreateImage(ImageType, Width, Height, FillColor, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGImagePtr(_result, false);
}

#pragma implementation_key(1657)
inline VGCore::IVGDocumentMarkupPtr VGCore::IVGDocument::GetMarkup ( ) {
    struct IVGDocumentMarkup * _result = 0;
    HRESULT _hr = get_Markup(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGDocumentMarkupPtr(_result, false);
}

//
// interface IVGRect wrapper method implementations
//

#pragma implementation_key(1658)
inline double VGCore::IVGRect::Getx ( ) {
    double _result = 0;
    HRESULT _hr = get_x(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1659)
inline void VGCore::IVGRect::Putx ( double pVal ) {
    HRESULT _hr = put_x(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(1660)
inline double VGCore::IVGRect::Gety ( ) {
    double _result = 0;
    HRESULT _hr = get_y(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1661)
inline void VGCore::IVGRect::Puty ( double pVal ) {
    HRESULT _hr = put_y(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(1662)
inline double VGCore::IVGRect::GetWidth ( ) {
    double _result = 0;
    HRESULT _hr = get_Width(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1663)
inline void VGCore::IVGRect::PutWidth ( double pVal ) {
    HRESULT _hr = put_Width(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(1664)
inline double VGCore::IVGRect::GetHeight ( ) {
    double _result = 0;
    HRESULT _hr = get_Height(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1665)
inline void VGCore::IVGRect::PutHeight ( double pVal ) {
    HRESULT _hr = put_Height(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(1666)
inline HRESULT VGCore::IVGRect::SetRect ( double x, double y, double Width, double Height ) {
    HRESULT _hr = raw_SetRect(x, y, Width, Height);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(1667)
inline HRESULT VGCore::IVGRect::GetRect ( double * x, double * y, double * Width, double * Height ) {
    HRESULT _hr = raw_GetRect(x, y, Width, Height);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(1668)
inline HRESULT VGCore::IVGRect::CopyAssign ( struct IVGRect * Source ) {
    HRESULT _hr = raw_CopyAssign(Source);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(1669)
inline VGCore::IVGRectPtr VGCore::IVGRect::GetCopy ( ) {
    struct IVGRect * _result = 0;
    HRESULT _hr = raw_GetCopy(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGRectPtr(_result, false);
}

#pragma implementation_key(1670)
inline VGCore::IVGRectPtr VGCore::IVGRect::Intersect ( struct IVGRect * Rect ) {
    struct IVGRect * _result = 0;
    HRESULT _hr = raw_Intersect(Rect, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGRectPtr(_result, false);
}

#pragma implementation_key(1671)
inline VARIANT_BOOL VGCore::IVGRect::GetIsEmpty ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsEmpty(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1672)
inline VGCore::IVGRectPtr VGCore::IVGRect::Union ( struct IVGRect * Rect ) {
    struct IVGRect * _result = 0;
    HRESULT _hr = raw_Union(Rect, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGRectPtr(_result, false);
}

#pragma implementation_key(1673)
inline HRESULT VGCore::IVGRect::Offset ( double OffsetX, double OffsetY ) {
    HRESULT _hr = raw_Offset(OffsetX, OffsetY);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(1674)
inline VARIANT_BOOL VGCore::IVGRect::Inflate ( double Left, double Top, double Right, double Bottom ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_Inflate(Left, Top, Right, Bottom, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1675)
inline VARIANT_BOOL VGCore::IVGRect::IsPointInside ( double x, double y ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_IsPointInside(x, y, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1676)
inline HRESULT VGCore::IVGRect::Clear ( ) {
    HRESULT _hr = raw_Clear();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(1677)
inline VGCore::IVGRectPtr VGCore::IVGRect::ChangeContext ( struct IVGDocument * SrcDoc, struct IVGDocument * DestDoc ) {
    struct IVGRect * _result = 0;
    HRESULT _hr = raw_ChangeContext(SrcDoc, DestDoc, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGRectPtr(_result, false);
}

#pragma implementation_key(1678)
inline double VGCore::IVGRect::GetLeft ( ) {
    double _result = 0;
    HRESULT _hr = get_Left(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1679)
inline double VGCore::IVGRect::GetRight ( ) {
    double _result = 0;
    HRESULT _hr = get_Right(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1680)
inline double VGCore::IVGRect::GetTop ( ) {
    double _result = 0;
    HRESULT _hr = get_Top(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1681)
inline double VGCore::IVGRect::GetBottom ( ) {
    double _result = 0;
    HRESULT _hr = get_Bottom(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1682)
inline double VGCore::IVGRect::GetCenterX ( ) {
    double _result = 0;
    HRESULT _hr = get_CenterX(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1683)
inline double VGCore::IVGRect::GetCenterY ( ) {
    double _result = 0;
    HRESULT _hr = get_CenterY(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface IVGApplication wrapper method implementations
//

#pragma implementation_key(1684)
inline VGCore::IVGApplicationPtr VGCore::IVGApplication::GetApplication ( ) {
    struct IVGApplication * _result = 0;
    HRESULT _hr = get_Application(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGApplicationPtr(_result, false);
}

#pragma implementation_key(1685)
inline VGCore::IVGApplicationPtr VGCore::IVGApplication::GetParent ( ) {
    struct IVGApplication * _result = 0;
    HRESULT _hr = get_Parent(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGApplicationPtr(_result, false);
}

#pragma implementation_key(1686)
inline VARIANT_BOOL VGCore::IVGApplication::GetVisible ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_Visible(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1687)
inline void VGCore::IVGApplication::PutVisible ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_Visible(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(1688)
inline VGCore::IVGDocumentsPtr VGCore::IVGApplication::GetDocuments ( ) {
    struct IVGDocuments * _result = 0;
    HRESULT _hr = get_Documents(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGDocumentsPtr(_result, false);
}

#pragma implementation_key(1689)
inline VGCore::IVGDocumentPtr VGCore::IVGApplication::GetActiveDocument ( ) {
    struct IVGDocument * _result = 0;
    HRESULT _hr = get_ActiveDocument(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGDocumentPtr(_result, false);
}

#pragma implementation_key(1690)
inline VGCore::IVGPagePtr VGCore::IVGApplication::GetActivePage ( ) {
    struct IVGPage * _result = 0;
    HRESULT _hr = get_ActivePage(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGPagePtr(_result, false);
}

#pragma implementation_key(1691)
inline VGCore::IVGWindowPtr VGCore::IVGApplication::GetActiveWindow ( ) {
    struct IVGWindow * _result = 0;
    HRESULT _hr = get_ActiveWindow(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGWindowPtr(_result, false);
}

#pragma implementation_key(1692)
inline VGCore::IVGWindowsPtr VGCore::IVGApplication::GetWindows ( ) {
    struct IVGWindows * _result = 0;
    HRESULT _hr = get_Windows(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGWindowsPtr(_result, false);
}

#pragma implementation_key(1693)
inline VGCore::ICorelScriptToolsPtr VGCore::IVGApplication::CorelScriptTools ( ) {
    struct ICorelScriptTools * _result = 0;
    HRESULT _hr = raw_CorelScriptTools(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return ICorelScriptToolsPtr(_result, false);
}

#pragma implementation_key(1694)
inline VGCore::IVGWorkspacePtr VGCore::IVGApplication::GetActiveWorkspace ( ) {
    struct IVGWorkspace * _result = 0;
    HRESULT _hr = get_ActiveWorkspace(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGWorkspacePtr(_result, false);
}

#pragma implementation_key(1695)
inline VGCore::IVGWorkspacesPtr VGCore::IVGApplication::GetWorkspaces ( ) {
    struct IVGWorkspaces * _result = 0;
    HRESULT _hr = get_Workspaces(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGWorkspacesPtr(_result, false);
}

#pragma implementation_key(1696)
inline VGCore::IVGPalettePtr VGCore::IVGApplication::GetActivePalette ( ) {
    struct IVGPalette * _result = 0;
    HRESULT _hr = get_ActivePalette(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGPalettePtr(_result, false);
}

#pragma implementation_key(1697)
inline VGCore::IVGPalettesPtr VGCore::IVGApplication::GetPalettes ( ) {
    struct IVGPalettes * _result = 0;
    HRESULT _hr = get_Palettes(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGPalettesPtr(_result, false);
}

#pragma implementation_key(1698)
inline HRESULT VGCore::IVGApplication::Quit ( ) {
    HRESULT _hr = raw_Quit();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(1699)
inline VGCore::IVGColorPtr VGCore::IVGApplication::CreateColor ( _bstr_t ColorString ) {
    struct IVGColor * _result = 0;
    HRESULT _hr = raw_CreateColor(ColorString, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGColorPtr(_result, false);
}

#pragma implementation_key(1700)
inline VGCore::IVGFontListPtr VGCore::IVGApplication::GetFontList ( ) {
    struct IVGFontList * _result = 0;
    HRESULT _hr = get_FontList(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGFontListPtr(_result, false);
}

#pragma implementation_key(1701)
inline VGCore::IVGAppWindowPtr VGCore::IVGApplication::GetAppWindow ( ) {
    struct IVGAppWindow * _result = 0;
    HRESULT _hr = get_AppWindow(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGAppWindowPtr(_result, false);
}

#pragma implementation_key(1702)
inline VGCore::IVGRecentFilesPtr VGCore::IVGApplication::GetRecentFiles ( ) {
    struct IVGRecentFiles * _result = 0;
    HRESULT _hr = get_RecentFiles(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGRecentFilesPtr(_result, false);
}

#pragma implementation_key(1703)
inline IDispatchPtr VGCore::IVGApplication::GetVBE ( ) {
    IDispatch * _result = 0;
    HRESULT _hr = get_VBE(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IDispatchPtr(_result, false);
}

#pragma implementation_key(1704)
inline double VGCore::IVGApplication::cdrMixedDouble ( ) {
    double _result = 0;
    HRESULT _hr = raw_cdrMixedDouble(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1705)
inline float VGCore::IVGApplication::cdrMixedSingle ( ) {
    float _result = 0;
    HRESULT _hr = raw_cdrMixedSingle(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1706)
inline long VGCore::IVGApplication::cdrMixedLong ( ) {
    long _result = 0;
    HRESULT _hr = raw_cdrMixedLong(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1707)
inline VARIANT_BOOL VGCore::IVGApplication::GetEventsEnabled ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_EventsEnabled(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1708)
inline void VGCore::IVGApplication::PutEventsEnabled ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_EventsEnabled(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(1709)
inline VGCore::IVGDocumentPtr VGCore::IVGApplication::OpenDocument ( _bstr_t FileName, long CodePage ) {
    struct IVGDocument * _result = 0;
    HRESULT _hr = raw_OpenDocument(FileName, CodePage, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGDocumentPtr(_result, false);
}

#pragma implementation_key(1710)
inline VGCore::IVGDocumentPtr VGCore::IVGApplication::CreateDocument ( ) {
    struct IVGDocument * _result = 0;
    HRESULT _hr = raw_CreateDocument(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGDocumentPtr(_result, false);
}

#pragma implementation_key(1711)
inline VGCore::IVGColorPtr VGCore::IVGApplication::CreateColorEx ( long ColorModel, long V1, long V2, long V3, long V4, long V5, long V6, long V7 ) {
    struct IVGColor * _result = 0;
    HRESULT _hr = raw_CreateColorEx(ColorModel, V1, V2, V3, V4, V5, V6, V7, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGColorPtr(_result, false);
}

#pragma implementation_key(1712)
inline VGCore::IVGArrowHeadsPtr VGCore::IVGApplication::GetArrowHeads ( ) {
    struct IVGArrowHeads * _result = 0;
    HRESULT _hr = get_ArrowHeads(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGArrowHeadsPtr(_result, false);
}

#pragma implementation_key(1713)
inline VGCore::IVGOutlineStylesPtr VGCore::IVGApplication::GetOutlineStyles ( ) {
    struct IVGOutlineStyles * _result = 0;
    HRESULT _hr = get_OutlineStyles(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGOutlineStylesPtr(_result, false);
}

#pragma implementation_key(1714)
inline _bstr_t VGCore::IVGApplication::GetVersion ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Version(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(1715)
inline long VGCore::IVGApplication::GetVersionMajor ( ) {
    long _result = 0;
    HRESULT _hr = get_VersionMajor(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1716)
inline long VGCore::IVGApplication::GetVersionMinor ( ) {
    long _result = 0;
    HRESULT _hr = get_VersionMinor(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1717)
inline long VGCore::IVGApplication::GetVersionBuild ( ) {
    long _result = 0;
    HRESULT _hr = get_VersionBuild(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1718)
inline _bstr_t VGCore::IVGApplication::GetPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Path(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(1719)
inline _bstr_t VGCore::IVGApplication::GetConfigPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_ConfigPath(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(1720)
inline _bstr_t VGCore::IVGApplication::GetSetupPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_SetupPath(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(1721)
inline VGCore::IVGLayerPtr VGCore::IVGApplication::GetActiveLayer ( ) {
    struct IVGLayer * _result = 0;
    HRESULT _hr = get_ActiveLayer(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGLayerPtr(_result, false);
}

#pragma implementation_key(1722)
inline VGCore::IVGShapePtr VGCore::IVGApplication::GetActiveSelection ( ) {
    struct IVGShape * _result = 0;
    HRESULT _hr = get_ActiveSelection(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGShapePtr(_result, false);
}

#pragma implementation_key(1723)
inline VGCore::IVGPatternCanvasesPtr VGCore::IVGApplication::GetPatternCanvases ( ) {
    struct IVGPatternCanvases * _result = 0;
    HRESULT _hr = get_PatternCanvases(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGPatternCanvasesPtr(_result, false);
}

#pragma implementation_key(1724)
inline VGCore::IVGClipboardPtr VGCore::IVGApplication::GetClipboard ( ) {
    struct IVGClipboard * _result = 0;
    HRESULT _hr = get_Clipboard(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGClipboardPtr(_result, false);
}

#pragma implementation_key(1725)
inline VGCore::IVGShapeRangePtr VGCore::IVGApplication::GetActiveSelectionRange ( ) {
    struct IVGShapeRange * _result = 0;
    HRESULT _hr = get_ActiveSelectionRange(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGShapeRangePtr(_result, false);
}

#pragma implementation_key(1726)
inline enum VGCore::cdrTools VGCore::IVGApplication::GetActiveTool ( ) {
    enum cdrTools _result;
    HRESULT _hr = get_ActiveTool(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1727)
inline void VGCore::IVGApplication::PutActiveTool ( enum cdrTools pTool ) {
    HRESULT _hr = put_ActiveTool(pTool);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(1728)
inline VGCore::IVGShapePtr VGCore::IVGApplication::GetActiveShape ( ) {
    struct IVGShape * _result = 0;
    HRESULT _hr = get_ActiveShape(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGShapePtr(_result, false);
}

#pragma implementation_key(1729)
inline VARIANT_BOOL VGCore::IVGApplication::GetOptimization ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_Optimization(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1730)
inline void VGCore::IVGApplication::PutOptimization ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_Optimization(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(1731)
inline enum VGCore::cdrPanoseMatchingType VGCore::IVGApplication::GetPanoseMatching ( ) {
    enum cdrPanoseMatchingType _result;
    HRESULT _hr = get_PanoseMatching(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1732)
inline void VGCore::IVGApplication::PutPanoseMatching ( enum cdrPanoseMatchingType pVal ) {
    HRESULT _hr = put_PanoseMatching(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(1733)
inline IDispatchPtr VGCore::IVGApplication::GetAddIns ( ) {
    IDispatch * _result = 0;
    HRESULT _hr = get_AddIns(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IDispatchPtr(_result, false);
}

#pragma implementation_key(1734)
inline VGCore::IVGColorPtr VGCore::IVGApplication::CreateRGBColor ( long Red, long Green, long Blue ) {
    struct IVGColor * _result = 0;
    HRESULT _hr = raw_CreateRGBColor(Red, Green, Blue, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGColorPtr(_result, false);
}

#pragma implementation_key(1735)
inline VGCore::IVGColorPtr VGCore::IVGApplication::CreateCMYColor ( long Cyan, long Magenta, long Yellow ) {
    struct IVGColor * _result = 0;
    HRESULT _hr = raw_CreateCMYColor(Cyan, Magenta, Yellow, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGColorPtr(_result, false);
}

#pragma implementation_key(1736)
inline VGCore::IVGColorPtr VGCore::IVGApplication::CreateCMYKColor ( long Cyan, long Magenta, long Yellow, long Black ) {
    struct IVGColor * _result = 0;
    HRESULT _hr = raw_CreateCMYKColor(Cyan, Magenta, Yellow, Black, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGColorPtr(_result, false);
}

#pragma implementation_key(1737)
inline VGCore::IVGColorPtr VGCore::IVGApplication::CreateGrayColor ( long GrayValue ) {
    struct IVGColor * _result = 0;
    HRESULT _hr = raw_CreateGrayColor(GrayValue, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGColorPtr(_result, false);
}

#pragma implementation_key(1738)
inline VGCore::IVGColorPtr VGCore::IVGApplication::CreateHLSColor ( long Hue, long Lightness, long Saturation ) {
    struct IVGColor * _result = 0;
    HRESULT _hr = raw_CreateHLSColor(Hue, Lightness, Saturation, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGColorPtr(_result, false);
}

#pragma implementation_key(1739)
inline VGCore::IVGColorPtr VGCore::IVGApplication::CreateHSBColor ( long Hue, long Saturation, long Brightness ) {
    struct IVGColor * _result = 0;
    HRESULT _hr = raw_CreateHSBColor(Hue, Saturation, Brightness, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGColorPtr(_result, false);
}

#pragma implementation_key(1740)
inline VGCore::IVGColorPtr VGCore::IVGApplication::CreateBWColor ( VARIANT_BOOL White ) {
    struct IVGColor * _result = 0;
    HRESULT _hr = raw_CreateBWColor(White, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGColorPtr(_result, false);
}

#pragma implementation_key(1741)
inline VGCore::IVGColorPtr VGCore::IVGApplication::CreateYIQColor ( long y, long I, long Q ) {
    struct IVGColor * _result = 0;
    HRESULT _hr = raw_CreateYIQColor(y, I, Q, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGColorPtr(_result, false);
}

#pragma implementation_key(1742)
inline VGCore::IVGColorPtr VGCore::IVGApplication::CreateLabColor ( long L, long A, long B ) {
    struct IVGColor * _result = 0;
    HRESULT _hr = raw_CreateLabColor(L, A, B, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGColorPtr(_result, false);
}

#pragma implementation_key(1743)
inline VGCore::IVGColorPtr VGCore::IVGApplication::CreateFixedColor ( enum cdrPaletteID PaletteID, long PaletteIndex, long Tint ) {
    struct IVGColor * _result = 0;
    HRESULT _hr = raw_CreateFixedColor(PaletteID, PaletteIndex, Tint, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGColorPtr(_result, false);
}

#pragma implementation_key(1744)
inline VGCore::IVGColorPtr VGCore::IVGApplication::CreateRegistrationColor ( ) {
    struct IVGColor * _result = 0;
    HRESULT _hr = raw_CreateRegistrationColor(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGColorPtr(_result, false);
}

#pragma implementation_key(1745)
inline VGCore::IVGSnapPointPtr VGCore::IVGApplication::CreateSnapPoint ( double PositionX, double PositionY ) {
    struct IVGSnapPoint * _result = 0;
    HRESULT _hr = raw_CreateSnapPoint(PositionX, PositionY, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGSnapPointPtr(_result, false);
}

#pragma implementation_key(1746)
inline VGCore::IVGDocumentPtr VGCore::IVGApplication::CreateDocumentFromTemplate ( _bstr_t Template, VARIANT_BOOL IncludeGraphics ) {
    struct IVGDocument * _result = 0;
    HRESULT _hr = raw_CreateDocumentFromTemplate(Template, IncludeGraphics, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGDocumentPtr(_result, false);
}

#pragma implementation_key(1747)
inline VGCore::IPrnVBAPrintersPtr VGCore::IVGApplication::GetPrinters ( ) {
    struct IPrnVBAPrinters * _result = 0;
    HRESULT _hr = get_Printers(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IPrnVBAPrintersPtr(_result, false);
}

#pragma implementation_key(1748)
inline VGCore::IPrnVBAPrintJobPtr VGCore::IVGApplication::GetPrintJob ( ) {
    struct IPrnVBAPrintJob * _result = 0;
    HRESULT _hr = get_PrintJob(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IPrnVBAPrintJobPtr(_result, false);
}

#pragma implementation_key(1749)
inline VGCore::ICUICommandBarsPtr VGCore::IVGApplication::GetCommandBars ( ) {
    struct ICUICommandBars * _result = 0;
    HRESULT _hr = get_CommandBars(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return ICUICommandBarsPtr(_result, false);
}

#pragma implementation_key(1750)
inline VGCore::ICUICommandBarPtr VGCore::IVGApplication::GetStatusBar ( ) {
    struct ICUICommandBar * _result = 0;
    HRESULT _hr = get_StatusBar(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return ICUICommandBarPtr(_result, false);
}

#pragma implementation_key(1751)
inline VGCore::ICUICommandBarPtr VGCore::IVGApplication::GetMainMenu ( ) {
    struct ICUICommandBar * _result = 0;
    HRESULT _hr = get_MainMenu(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return ICUICommandBarPtr(_result, false);
}

#pragma implementation_key(1752)
inline VGCore::IVGGMSManagerPtr VGCore::IVGApplication::GetGMSManager ( ) {
    struct IVGGMSManager * _result = 0;
    HRESULT _hr = get_GMSManager(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGGMSManagerPtr(_result, false);
}

#pragma implementation_key(1753)
inline HRESULT VGCore::IVGApplication::ImportWorkspace ( _bstr_t FileName ) {
    HRESULT _hr = raw_ImportWorkspace(FileName);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(1754)
inline HRESULT VGCore::IVGApplication::Refresh ( ) {
    HRESULT _hr = raw_Refresh();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(1755)
inline VGCore::IVGStructSaveAsOptionsPtr VGCore::IVGApplication::CreateStructSaveAsOptions ( ) {
    struct IVGStructSaveAsOptions * _result = 0;
    HRESULT _hr = raw_CreateStructSaveAsOptions(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGStructSaveAsOptionsPtr(_result, false);
}

#pragma implementation_key(1756)
inline VGCore::IVGStructExportOptionsPtr VGCore::IVGApplication::CreateStructExportOptions ( ) {
    struct IVGStructExportOptions * _result = 0;
    HRESULT _hr = raw_CreateStructExportOptions(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGStructExportOptionsPtr(_result, false);
}

#pragma implementation_key(1757)
inline VGCore::IVGStructImportOptionsPtr VGCore::IVGApplication::CreateStructImportOptions ( ) {
    struct IVGStructImportOptions * _result = 0;
    HRESULT _hr = raw_CreateStructImportOptions(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGStructImportOptionsPtr(_result, false);
}

#pragma implementation_key(1758)
inline VGCore::IVGStructPaletteOptionsPtr VGCore::IVGApplication::CreateStructPaletteOptions ( ) {
    struct IVGStructPaletteOptions * _result = 0;
    HRESULT _hr = raw_CreateStructPaletteOptions(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGStructPaletteOptionsPtr(_result, false);
}

#pragma implementation_key(1759)
inline VGCore::IVGNodeRangePtr VGCore::IVGApplication::CreateNodeRange ( ) {
    struct IVGNodeRange * _result = 0;
    HRESULT _hr = raw_CreateNodeRange(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGNodeRangePtr(_result, false);
}

#pragma implementation_key(1760)
inline VGCore::IVGSegmentRangePtr VGCore::IVGApplication::CreateSegmentRange ( ) {
    struct IVGSegmentRange * _result = 0;
    HRESULT _hr = raw_CreateSegmentRange(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGSegmentRangePtr(_result, false);
}

#pragma implementation_key(1761)
inline VGCore::IVGShapeRangePtr VGCore::IVGApplication::CreateShapeRange ( ) {
    struct IVGShapeRange * _result = 0;
    HRESULT _hr = raw_CreateShapeRange(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGShapeRangePtr(_result, false);
}

#pragma implementation_key(1762)
inline VGCore::IVGPatternCanvasPtr VGCore::IVGApplication::CreatePatternCanvas ( ) {
    struct IVGPatternCanvas * _result = 0;
    HRESULT _hr = raw_CreatePatternCanvas(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGPatternCanvasPtr(_result, false);
}

#pragma implementation_key(1763)
inline VGCore::IVGCurvePtr VGCore::IVGApplication::CreateCurve ( struct IVGDocument * Document ) {
    struct IVGCurve * _result = 0;
    HRESULT _hr = raw_CreateCurve(Document, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGCurvePtr(_result, false);
}

#pragma implementation_key(1764)
inline _bstr_t VGCore::IVGApplication::GetUserDataPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_UserDataPath(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(1765)
inline VARIANT_BOOL VGCore::IVGApplication::InitializeVBA ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_InitializeVBA(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1766)
inline _bstr_t VGCore::IVGApplication::GetHelpFile ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_HelpFile(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(1767)
inline VGCore::ICUIFrameWorkPtr VGCore::IVGApplication::GetFrameWork ( ) {
    struct ICUIFrameWork * _result = 0;
    HRESULT _hr = get_FrameWork(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return ICUIFrameWorkPtr(_result, false);
}

#pragma implementation_key(1768)
inline VGCore::IVGStructFontPropertiesPtr VGCore::IVGApplication::CreateStructFontProperties ( ) {
    struct IVGStructFontProperties * _result = 0;
    HRESULT _hr = raw_CreateStructFontProperties(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGStructFontPropertiesPtr(_result, false);
}

#pragma implementation_key(1769)
inline VGCore::IVGStructAlignPropertiesPtr VGCore::IVGApplication::CreateStructAlignProperties ( ) {
    struct IVGStructAlignProperties * _result = 0;
    HRESULT _hr = raw_CreateStructAlignProperties(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGStructAlignPropertiesPtr(_result, false);
}

#pragma implementation_key(1770)
inline VGCore::IVGStructSpacePropertiesPtr VGCore::IVGApplication::CreateStructSpaceProperties ( ) {
    struct IVGStructSpaceProperties * _result = 0;
    HRESULT _hr = raw_CreateStructSpaceProperties(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGStructSpacePropertiesPtr(_result, false);
}

#pragma implementation_key(1771)
inline VGCore::IVGStructHyphenationSettingsPtr VGCore::IVGApplication::CreateStructHyphenationSettings ( ) {
    struct IVGStructHyphenationSettings * _result = 0;
    HRESULT _hr = raw_CreateStructHyphenationSettings(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGStructHyphenationSettingsPtr(_result, false);
}

#pragma implementation_key(1772)
inline VGCore::IVGComponentsPtr VGCore::IVGApplication::GetComponents ( ) {
    struct IVGComponents * _result = 0;
    HRESULT _hr = get_Components(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGComponentsPtr(_result, false);
}

#pragma implementation_key(1773)
inline VGCore::IVGSymbolLibrariesPtr VGCore::IVGApplication::GetSymbolLibraries ( ) {
    struct IVGSymbolLibraries * _result = 0;
    HRESULT _hr = get_SymbolLibraries(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGSymbolLibrariesPtr(_result, false);
}

#pragma implementation_key(1774)
inline long VGCore::IVGApplication::AdviseEvents ( IDispatch * EventSink ) {
    long _result = 0;
    HRESULT _hr = raw_AdviseEvents(EventSink, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1775)
inline HRESULT VGCore::IVGApplication::UnadviseEvents ( long Cookie ) {
    HRESULT _hr = raw_UnadviseEvents(Cookie);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(1776)
inline enum VGCore::cdrApplicationID VGCore::IVGApplication::GetID ( ) {
    enum cdrApplicationID _result;
    HRESULT _hr = get_ID(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1777)
inline _bstr_t VGCore::IVGApplication::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(1778)
inline enum VGCore::cdrApplicationClass VGCore::IVGApplication::GetClass ( ) {
    enum cdrApplicationClass _result;
    HRESULT _hr = get_Class(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1779)
inline long VGCore::IVGApplication::GetPlatformVersionMajor ( ) {
    long _result = 0;
    HRESULT _hr = get_PlatformVersionMajor(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1780)
inline long VGCore::IVGApplication::GetPlatformVersionMinor ( ) {
    long _result = 0;
    HRESULT _hr = get_PlatformVersionMinor(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1781)
inline long VGCore::IVGApplication::CheckPlatformVersion ( long VersionMajor, long VersionMinor ) {
    long _result = 0;
    HRESULT _hr = raw_CheckPlatformVersion(VersionMajor, VersionMinor, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1782)
inline VGCore::IVGAppStatusPtr VGCore::IVGApplication::GetStatus ( ) {
    struct IVGAppStatus * _result = 0;
    HRESULT _hr = get_Status(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGAppStatusPtr(_result, false);
}

#pragma implementation_key(1783)
inline double VGCore::IVGApplication::ConvertUnits ( double Value, enum cdrUnit FromUnit, enum cdrUnit ToUnit ) {
    double _result = 0;
    HRESULT _hr = raw_ConvertUnits(Value, FromUnit, ToUnit, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1784)
inline enum VGCore::cdrTextLanguage VGCore::IVGApplication::GetUILanguage ( ) {
    enum cdrTextLanguage _result;
    HRESULT _hr = get_UILanguage(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1785)
inline VARIANT_BOOL VGCore::IVGApplication::IsUILanguageAvailable ( enum cdrTextLanguage Language ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_IsUILanguageAvailable(Language, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1786)
inline VGCore::IVGPageSizesPtr VGCore::IVGApplication::GetPageSizes ( ) {
    struct IVGPageSizes * _result = 0;
    HRESULT _hr = get_PageSizes(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGPageSizesPtr(_result, false);
}

#pragma implementation_key(1787)
inline enum VGCore::cdrUnit VGCore::IVGApplication::GetUnit ( ) {
    enum cdrUnit _result;
    HRESULT _hr = get_Unit(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1788)
inline void VGCore::IVGApplication::PutUnit ( enum cdrUnit pVal ) {
    HRESULT _hr = put_Unit(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(1789)
inline _bstr_t VGCore::IVGApplication::ConvertToUnicode ( _bstr_t String, long CodePage ) {
    BSTR _result = 0;
    HRESULT _hr = raw_ConvertToUnicode(String, CodePage, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(1790)
inline _bstr_t VGCore::IVGApplication::ConvertFromUnicode ( _bstr_t String, long CodePage ) {
    BSTR _result = 0;
    HRESULT _hr = raw_ConvertFromUnicode(String, CodePage, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(1791)
inline _bstr_t VGCore::IVGApplication::GetUserWorkspacePath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_UserWorkspacePath(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(1792)
inline _bstr_t VGCore::IVGApplication::GetLanguagePath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_LanguagePath(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(1793)
inline VGCore::IVGTreeManagerPtr VGCore::IVGApplication::GetActiveTreeManager ( ) {
    struct IVGTreeManager * _result = 0;
    HRESULT _hr = get_ActiveTreeManager(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGTreeManagerPtr(_result, false);
}

#pragma implementation_key(1794)
inline VGCore::IVGLayerPtr VGCore::IVGApplication::GetActiveVirtualLayer ( ) {
    struct IVGLayer * _result = 0;
    HRESULT _hr = get_ActiveVirtualLayer(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGLayerPtr(_result, false);
}

#pragma implementation_key(1795)
inline VGCore::IVGDuotonePtr VGCore::IVGApplication::CreateDuotone ( ) {
    struct IVGDuotone * _result = 0;
    HRESULT _hr = raw_CreateDuotone(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGDuotonePtr(_result, false);
}

#pragma implementation_key(1796)
inline VGCore::IVGColorManagerPtr VGCore::IVGApplication::GetColorManager ( ) {
    struct IVGColorManager * _result = 0;
    HRESULT _hr = get_ColorManager(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGColorManagerPtr(_result, false);
}

#pragma implementation_key(1797)
inline VGCore::IVGOutlineStylesPtr VGCore::IVGApplication::GetEnhancedOutlines ( ) {
    struct IVGOutlineStyles * _result = 0;
    HRESULT _hr = get_EnhancedOutlines(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGOutlineStylesPtr(_result, false);
}

#pragma implementation_key(1798)
inline VARIANT_BOOL VGCore::IVGApplication::AddPluginCommand ( _bstr_t CommandID, _bstr_t Caption, _bstr_t Tooltip ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_AddPluginCommand(CommandID, Caption, Tooltip, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1799)
inline VARIANT_BOOL VGCore::IVGApplication::RemovePluginCommand ( _bstr_t CommandID ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_RemovePluginCommand(CommandID, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1800)
inline VGCore::IVGOutlineStylePtr VGCore::IVGApplication::CreateOutlineStyle ( long DashDotCount, SAFEARRAY * * DashDotLengths ) {
    struct IVGOutlineStyle * _result = 0;
    HRESULT _hr = raw_CreateOutlineStyle(DashDotCount, DashDotLengths, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGOutlineStylePtr(_result, false);
}

#pragma implementation_key(1801)
inline enum VGCore::cdrAppStartupMode VGCore::IVGApplication::GetStartupMode ( ) {
    enum cdrAppStartupMode _result;
    HRESULT _hr = get_StartupMode(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1802)
inline void VGCore::IVGApplication::PutStartupMode ( enum cdrAppStartupMode pVal ) {
    HRESULT _hr = put_StartupMode(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(1803)
inline VGCore::IVGPropertiesPtr VGCore::IVGApplication::GetGlobalUserData ( ) {
    struct IVGProperties * _result = 0;
    HRESULT _hr = get_GlobalUserData(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGPropertiesPtr(_result, false);
}

#pragma implementation_key(1804)
inline VGCore::IVGPropertiesPtr VGCore::IVGApplication::GetSessionUserData ( ) {
    struct IVGProperties * _result = 0;
    HRESULT _hr = get_SessionUserData(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGPropertiesPtr(_result, false);
}

#pragma implementation_key(1805)
inline _variant_t VGCore::IVGApplication::Evaluate ( _bstr_t Expression ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = raw_Evaluate(Expression, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

#pragma implementation_key(1806)
inline VGCore::IVGRectPtr VGCore::IVGApplication::CreateRect ( double x, double y, double Width, double Height ) {
    struct IVGRect * _result = 0;
    HRESULT _hr = raw_CreateRect(x, y, Width, Height, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGRectPtr(_result, false);
}

#pragma implementation_key(1807)
inline HRESULT VGCore::IVGApplication::ForceUpdateFontTable ( ) {
    HRESULT _hr = raw_ForceUpdateFontTable();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(1808)
inline VGCore::IVGSpreadPtr VGCore::IVGApplication::GetActiveSpread ( ) {
    struct IVGSpread * _result = 0;
    HRESULT _hr = get_ActiveSpread(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGSpreadPtr(_result, false);
}

#pragma implementation_key(1809)
inline VGCore::IVGDocumentPtr VGCore::IVGApplication::OpenDocumentAsCopy ( _bstr_t FileName, struct IVGStructOpenOptions * Options ) {
    struct IVGDocument * _result = 0;
    HRESULT _hr = raw_OpenDocumentAsCopy(FileName, Options, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGDocumentPtr(_result, false);
}

#pragma implementation_key(1810)
inline VGCore::IVGColorContextPtr VGCore::IVGApplication::GetDefaultColorContext ( ) {
    struct IVGColorContext * _result = 0;
    HRESULT _hr = get_DefaultColorContext(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGColorContextPtr(_result, false);
}

#pragma implementation_key(1811)
inline VGCore::IVGColorContextPtr VGCore::IVGApplication::CreateColorContext ( struct IVGColorProfile * RGBProfile, struct IVGColorProfile * CMYKProfile, struct IVGColorProfile * GrayscaleProfile, enum clrRenderingIntent RenderingIntent, enum clrColorModel BlendingColorModel ) {
    struct IVGColorContext * _result = 0;
    HRESULT _hr = raw_CreateColorContext(RGBProfile, CMYKProfile, GrayscaleProfile, RenderingIntent, BlendingColorModel, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGColorContextPtr(_result, false);
}

#pragma implementation_key(1812)
inline VGCore::IVGColorContextPtr VGCore::IVGApplication::CreateColorContext2 ( _bstr_t ColorProfileList, enum clrRenderingIntent RenderingIntent, enum clrColorModel BlendingColorModel ) {
    struct IVGColorContext * _result = 0;
    HRESULT _hr = raw_CreateColorContext2(ColorProfileList, RenderingIntent, BlendingColorModel, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGColorContextPtr(_result, false);
}

#pragma implementation_key(1813)
inline VGCore::IVGDocumentPtr VGCore::IVGApplication::CreateDocumentEx ( struct IVGStructCreateOptions * Options ) {
    struct IVGDocument * _result = 0;
    HRESULT _hr = raw_CreateDocumentEx(Options, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGDocumentPtr(_result, false);
}

#pragma implementation_key(1814)
inline VGCore::IVGDocumentPtr VGCore::IVGApplication::OpenDocumentEx ( _bstr_t FileName, struct IVGStructOpenOptions * Options ) {
    struct IVGDocument * _result = 0;
    HRESULT _hr = raw_OpenDocumentEx(FileName, Options, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGDocumentPtr(_result, false);
}

#pragma implementation_key(1815)
inline VGCore::IVGStructOpenOptionsPtr VGCore::IVGApplication::CreateStructOpenOptions ( ) {
    struct IVGStructOpenOptions * _result = 0;
    HRESULT _hr = raw_CreateStructOpenOptions(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGStructOpenOptionsPtr(_result, false);
}

#pragma implementation_key(1816)
inline VGCore::IVGStructCreateOptionsPtr VGCore::IVGApplication::CreateStructCreateOptions ( ) {
    struct IVGStructCreateOptions * _result = 0;
    HRESULT _hr = raw_CreateStructCreateOptions(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGStructCreateOptionsPtr(_result, false);
}

#pragma implementation_key(1817)
inline VGCore::IVGStructPasteOptionsPtr VGCore::IVGApplication::CreateStructPasteOptions ( ) {
    struct IVGStructPasteOptions * _result = 0;
    HRESULT _hr = raw_CreateStructPasteOptions(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGStructPasteOptionsPtr(_result, false);
}

#pragma implementation_key(1818)
inline VGCore::IVGProofColorSettingsPtr VGCore::IVGApplication::CreateProofColorSettings ( _bstr_t ProfileName, enum clrRenderingIntent RenderingIntent, VARIANT_BOOL PreserveColorValues ) {
    struct IVGProofColorSettings * _result = 0;
    HRESULT _hr = raw_CreateProofColorSettings(ProfileName, RenderingIntent, PreserveColorValues, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGProofColorSettingsPtr(_result, false);
}

#pragma implementation_key(1819)
inline VGCore::IVGPaletteManagerPtr VGCore::IVGApplication::GetPaletteManager ( ) {
    struct IVGPaletteManager * _result = 0;
    HRESULT _hr = get_PaletteManager(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGPaletteManagerPtr(_result, false);
}

#pragma implementation_key(1820)
inline VGCore::IVGColorPtr VGCore::IVGApplication::CreateSpotColor ( _bstr_t PaletteIdentifier, long SpotColorID, long Tint ) {
    struct IVGColor * _result = 0;
    HRESULT _hr = raw_CreateSpotColor(PaletteIdentifier, SpotColorID, Tint, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGColorPtr(_result, false);
}

#pragma implementation_key(1821)
inline VGCore::IVGColorPtr VGCore::IVGApplication::CreateSpotColorByName ( _bstr_t PaletteIdentifier, _bstr_t SpotColorName, long Tint ) {
    struct IVGColor * _result = 0;
    HRESULT _hr = raw_CreateSpotColorByName(PaletteIdentifier, SpotColorName, Tint, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGColorPtr(_result, false);
}

#pragma implementation_key(1822)
inline VGCore::IVGColorPtr VGCore::IVGApplication::CreatePaletteColor ( _bstr_t PaletteIdentifier, long ColorIndex ) {
    struct IVGColor * _result = 0;
    HRESULT _hr = raw_CreatePaletteColor(PaletteIdentifier, ColorIndex, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGColorPtr(_result, false);
}

#pragma implementation_key(1823)
inline SAFEARRAY * VGCore::IVGApplication::GetSupportedOpenTypeFeatures ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_GetSupportedOpenTypeFeatures(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1824)
inline VGCore::IVGFillMetadataPtr VGCore::IVGApplication::CreateFillMetadata ( ) {
    struct IVGFillMetadata * _result = 0;
    HRESULT _hr = raw_CreateFillMetadata(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGFillMetadataPtr(_result, false);
}

#pragma implementation_key(1825)
inline _bstr_t VGCore::IVGApplication::GetAddonPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_AddonPath(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(1826)
inline _bstr_t VGCore::IVGApplication::GetProgramPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_ProgramPath(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(1827)
inline _bstr_t VGCore::IVGApplication::GetActiveToolStateGuid ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_ActiveToolStateGuid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(1828)
inline void VGCore::IVGApplication::PutActiveToolStateGuid ( _bstr_t pTool ) {
    HRESULT _hr = put_ActiveToolStateGuid(pTool);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(1829)
inline HRESULT VGCore::IVGApplication::RegisterToolState ( _bstr_t ToolStateGuid, _bstr_t ToolStateName, struct IVGToolState * ToolState ) {
    HRESULT _hr = raw_RegisterToolState(ToolStateGuid, ToolStateName, ToolState);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(1830)
inline VARIANT_BOOL VGCore::IVGApplication::UnregisterToolState ( _bstr_t ToolStateGuid ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_UnregisterToolState(ToolStateGuid, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1831)
inline VGCore::IVGOnScreenCurvePtr VGCore::IVGApplication::CreateOnScreenCurve ( ) {
    struct IVGOnScreenCurve * _result = 0;
    HRESULT _hr = raw_CreateOnScreenCurve(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGOnScreenCurvePtr(_result, false);
}

#pragma implementation_key(1832)
inline VGCore::IVGOnScreenHandlePtr VGCore::IVGApplication::CreateOnScreenHandle ( ) {
    struct IVGOnScreenHandle * _result = 0;
    HRESULT _hr = raw_CreateOnScreenHandle(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGOnScreenHandlePtr(_result, false);
}

#pragma implementation_key(1833)
inline VGCore::IVGOnScreenTextPtr VGCore::IVGApplication::CreateOnScreenText ( ) {
    struct IVGOnScreenText * _result = 0;
    HRESULT _hr = raw_CreateOnScreenText(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGOnScreenTextPtr(_result, false);
}

#pragma implementation_key(1834)
inline VGCore::IVGMathUtilsPtr VGCore::IVGApplication::GetMath ( ) {
    struct IVGMathUtils * _result = 0;
    HRESULT _hr = get_Math(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGMathUtilsPtr(_result, false);
}

#pragma implementation_key(1835)
inline HRESULT VGCore::IVGApplication::RegisterUserApplicationPreference ( _bstr_t GroupName, _bstr_t KeyName, const _variant_t & DefaultVal ) {
    HRESULT _hr = raw_RegisterUserApplicationPreference(GroupName, KeyName, DefaultVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(1836)
inline _variant_t VGCore::IVGApplication::GetApplicationPreferenceValue ( _bstr_t GroupName, _bstr_t KeyName ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = raw_GetApplicationPreferenceValue(GroupName, KeyName, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

#pragma implementation_key(1837)
inline HRESULT VGCore::IVGApplication::SetApplicationPreferenceValue ( _bstr_t GroupName, _bstr_t KeyName, const _variant_t & newVal ) {
    HRESULT _hr = raw_SetApplicationPreferenceValue(GroupName, KeyName, newVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(1838)
inline VGCore::IVGPropertiesPtr VGCore::IVGApplication::CreateProperties ( ) {
    struct IVGProperties * _result = 0;
    HRESULT _hr = raw_CreateProperties(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGPropertiesPtr(_result, false);
}

#pragma implementation_key(1839)
inline HRESULT VGCore::IVGApplication::RegisterToolShape ( _bstr_t ToolShapeGuid, struct IVGToolShapeAttributes * ToolShapeAttributes, struct IVGToolShape * ToolShape ) {
    HRESULT _hr = raw_RegisterToolShape(ToolShapeGuid, ToolShapeAttributes, ToolShape);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(1840)
inline VGCore::IVGToolShapeAttributesPtr VGCore::IVGApplication::CreateToolShapeAttributes ( ) {
    struct IVGToolShapeAttributes * _result = 0;
    HRESULT _hr = raw_CreateToolShapeAttributes(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGToolShapeAttributesPtr(_result, false);
}

#pragma implementation_key(1841)
inline _bstr_t VGCore::IVGApplication::GetUILanguageCode ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_UILanguageCode(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(1842)
inline HRESULT VGCore::IVGApplication::StartTemporaryToolState ( _bstr_t StateGuid ) {
    HRESULT _hr = raw_StartTemporaryToolState(StateGuid);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(1843)
inline HRESULT VGCore::IVGApplication::MarkupLogout ( ) {
    HRESULT _hr = raw_MarkupLogout();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(1844)
inline HRESULT VGCore::IVGApplication::MarkupLogin ( struct IVGCommentAuthor * Author ) {
    HRESULT _hr = raw_MarkupLogin(Author);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(1845)
inline VGCore::IVGCommentAuthorPtr VGCore::IVGApplication::CreateMarkupAuthor ( _bstr_t Name, _bstr_t Avatar, _bstr_t Email, enum cdrAuthorAuthentication Authentication ) {
    struct IVGCommentAuthor * _result = 0;
    HRESULT _hr = raw_CreateMarkupAuthor(Name, Avatar, Email, Authentication, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGCommentAuthorPtr(_result, false);
}

//
// interface IVGDocuments wrapper method implementations
//

#pragma implementation_key(1846)
inline VGCore::IVGApplicationPtr VGCore::IVGDocuments::GetApplication ( ) {
    struct IVGApplication * _result = 0;
    HRESULT _hr = get_Application(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGApplicationPtr(_result, false);
}

#pragma implementation_key(1847)
inline VGCore::IVGApplicationPtr VGCore::IVGDocuments::GetParent ( ) {
    struct IVGApplication * _result = 0;
    HRESULT _hr = get_Parent(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGApplicationPtr(_result, false);
}

#pragma implementation_key(1848)
inline VGCore::IVGDocumentPtr VGCore::IVGDocuments::GetItem ( long Index ) {
    struct IVGDocument * _result = 0;
    HRESULT _hr = get_Item(Index, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGDocumentPtr(_result, false);
}

#pragma implementation_key(1849)
inline IUnknownPtr VGCore::IVGDocuments::Get_NewEnum ( ) {
    IUnknown * _result = 0;
    HRESULT _hr = get__NewEnum(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IUnknownPtr(_result, false);
}

#pragma implementation_key(1850)
inline long VGCore::IVGDocuments::GetCount ( ) {
    long _result = 0;
    HRESULT _hr = get_Count(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface IVGOutlineStyles wrapper method implementations
//

#pragma implementation_key(1851)
inline VGCore::IVGApplicationPtr VGCore::IVGOutlineStyles::GetApplication ( ) {
    struct IVGApplication * _result = 0;
    HRESULT _hr = get_Application(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGApplicationPtr(_result, false);
}

#pragma implementation_key(1852)
inline VGCore::IVGApplicationPtr VGCore::IVGOutlineStyles::GetParent ( ) {
    struct IVGApplication * _result = 0;
    HRESULT _hr = get_Parent(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGApplicationPtr(_result, false);
}

#pragma implementation_key(1853)
inline VGCore::IVGOutlineStylePtr VGCore::IVGOutlineStyles::GetItem ( long Index ) {
    struct IVGOutlineStyle * _result = 0;
    HRESULT _hr = get_Item(Index, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGOutlineStylePtr(_result, false);
}

#pragma implementation_key(1854)
inline IUnknownPtr VGCore::IVGOutlineStyles::Get_NewEnum ( ) {
    IUnknown * _result = 0;
    HRESULT _hr = get__NewEnum(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IUnknownPtr(_result, false);
}

#pragma implementation_key(1855)
inline long VGCore::IVGOutlineStyles::GetCount ( ) {
    long _result = 0;
    HRESULT _hr = get_Count(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1856)
inline VGCore::IVGOutlineStylePtr VGCore::IVGOutlineStyles::Add ( ) {
    struct IVGOutlineStyle * _result = 0;
    HRESULT _hr = raw_Add(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGOutlineStylePtr(_result, false);
}

#pragma implementation_key(1857)
inline HRESULT VGCore::IVGOutlineStyles::Remove ( long Index ) {
    HRESULT _hr = raw_Remove(Index);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(1858)
inline HRESULT VGCore::IVGOutlineStyles::Save ( ) {
    HRESULT _hr = raw_Save();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(1859)
inline VGCore::IVGOutlineStylePtr VGCore::IVGOutlineStyles::AddStyle ( struct IVGOutlineStyle * Style ) {
    struct IVGOutlineStyle * _result = 0;
    HRESULT _hr = raw_AddStyle(Style, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGOutlineStylePtr(_result, false);
}

//
// interface IVGRulers wrapper method implementations
//

#pragma implementation_key(1860)
inline VGCore::IVGApplicationPtr VGCore::IVGRulers::GetApplication ( ) {
    struct IVGApplication * _result = 0;
    HRESULT _hr = get_Application(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGApplicationPtr(_result, false);
}

#pragma implementation_key(1861)
inline VGCore::IVGDocumentPtr VGCore::IVGRulers::GetParent ( ) {
    struct IVGDocument * _result = 0;
    HRESULT _hr = get_Parent(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGDocumentPtr(_result, false);
}

#pragma implementation_key(1862)
inline enum VGCore::cdrUnit VGCore::IVGRulers::GetVUnits ( ) {
    enum cdrUnit _result;
    HRESULT _hr = get_VUnits(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1863)
inline void VGCore::IVGRulers::PutVUnits ( enum cdrUnit pVal ) {
    HRESULT _hr = put_VUnits(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(1864)
inline enum VGCore::cdrUnit VGCore::IVGRulers::GetHUnits ( ) {
    enum cdrUnit _result;
    HRESULT _hr = get_HUnits(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1865)
inline void VGCore::IVGRulers::PutHUnits ( enum cdrUnit pVal ) {
    HRESULT _hr = put_HUnits(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IVGGrid wrapper method implementations
//

#pragma implementation_key(1866)
inline VGCore::IVGApplicationPtr VGCore::IVGGrid::GetApplication ( ) {
    struct IVGApplication * _result = 0;
    HRESULT _hr = get_Application(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGApplicationPtr(_result, false);
}

#pragma implementation_key(1867)
inline VGCore::IVGDocumentPtr VGCore::IVGGrid::GetParent ( ) {
    struct IVGDocument * _result = 0;
    HRESULT _hr = get_Parent(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGDocumentPtr(_result, false);
}

#pragma implementation_key(1868)
inline VARIANT_BOOL VGCore::IVGGrid::GetVisible ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_Visible(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1869)
inline void VGCore::IVGGrid::PutVisible ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_Visible(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(1870)
inline enum VGCore::cdrGridType VGCore::IVGGrid::GetType ( ) {
    enum cdrGridType _result;
    HRESULT _hr = get_Type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1871)
inline void VGCore::IVGGrid::PutType ( enum cdrGridType pVal ) {
    HRESULT _hr = put_Type(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(1872)
inline VARIANT_BOOL VGCore::IVGGrid::GetSnap ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_Snap(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1873)
inline void VGCore::IVGGrid::PutSnap ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_Snap(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(1874)
inline HRESULT VGCore::IVGGrid::SetFrequency ( double GridX, double GridY ) {
    HRESULT _hr = raw_SetFrequency(GridX, GridY);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(1875)
inline double VGCore::IVGGrid::GetSpacingX ( ) {
    double _result = 0;
    HRESULT _hr = get_SpacingX(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1876)
inline void VGCore::IVGGrid::PutSpacingX ( double pVal ) {
    HRESULT _hr = put_SpacingX(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(1877)
inline double VGCore::IVGGrid::GetSpacingY ( ) {
    double _result = 0;
    HRESULT _hr = get_SpacingY(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1878)
inline void VGCore::IVGGrid::PutSpacingY ( double pVal ) {
    HRESULT _hr = put_SpacingY(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IVGAppPlugin wrapper method implementations
//

#pragma implementation_key(1879)
inline HRESULT VGCore::IVGAppPlugin::OnLoad ( struct IVGApplication * Application ) {
    HRESULT _hr = raw_OnLoad(Application);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(1880)
inline HRESULT VGCore::IVGAppPlugin::StartSession ( ) {
    HRESULT _hr = raw_StartSession();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(1881)
inline HRESULT VGCore::IVGAppPlugin::StopSession ( ) {
    HRESULT _hr = raw_StopSession();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(1882)
inline HRESULT VGCore::IVGAppPlugin::OnUnload ( ) {
    HRESULT _hr = raw_OnUnload();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface IVGPage wrapper method implementations
//

#pragma implementation_key(1883)
inline _bstr_t VGCore::IVGPage::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(1884)
inline void VGCore::IVGPage::PutName ( _bstr_t pVal ) {
    HRESULT _hr = put_Name(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(1885)
inline VGCore::IVGApplicationPtr VGCore::IVGPage::GetApplication ( ) {
    struct IVGApplication * _result = 0;
    HRESULT _hr = get_Application(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGApplicationPtr(_result, false);
}

#pragma implementation_key(1886)
inline VGCore::IVGPagesPtr VGCore::IVGPage::GetParent ( ) {
    struct IVGPages * _result = 0;
    HRESULT _hr = get_Parent(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGPagesPtr(_result, false);
}

#pragma implementation_key(1887)
inline VGCore::IVGLayersPtr VGCore::IVGPage::GetLayers ( ) {
    struct IVGLayers * _result = 0;
    HRESULT _hr = get_Layers(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGLayersPtr(_result, false);
}

#pragma implementation_key(1888)
inline VGCore::IVGShapesPtr VGCore::IVGPage::GetShapes ( ) {
    struct IVGShapes * _result = 0;
    HRESULT _hr = get_Shapes(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGShapesPtr(_result, false);
}

#pragma implementation_key(1889)
inline VGCore::IVGLayerPtr VGCore::IVGPage::GetActiveLayer ( ) {
    struct IVGLayer * _result = 0;
    HRESULT _hr = get_ActiveLayer(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGLayerPtr(_result, false);
}

#pragma implementation_key(1890)
inline _bstr_t VGCore::IVGPage::GetPaper ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Paper(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(1891)
inline double VGCore::IVGPage::GetSizeWidth ( ) {
    double _result = 0;
    HRESULT _hr = get_SizeWidth(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1892)
inline void VGCore::IVGPage::PutSizeWidth ( double pVal ) {
    HRESULT _hr = put_SizeWidth(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(1893)
inline double VGCore::IVGPage::GetSizeHeight ( ) {
    double _result = 0;
    HRESULT _hr = get_SizeHeight(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1894)
inline void VGCore::IVGPage::PutSizeHeight ( double pVal ) {
    HRESULT _hr = put_SizeHeight(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(1895)
inline long VGCore::IVGPage::GetResolution ( ) {
    long _result = 0;
    HRESULT _hr = get_Resolution(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1896)
inline void VGCore::IVGPage::PutResolution ( long pVal ) {
    HRESULT _hr = put_Resolution(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(1897)
inline double VGCore::IVGPage::GetBleed ( ) {
    double _result = 0;
    HRESULT _hr = get_Bleed(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1898)
inline void VGCore::IVGPage::PutBleed ( double pVal ) {
    HRESULT _hr = put_Bleed(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(1899)
inline enum VGCore::cdrPageOrientation VGCore::IVGPage::GetOrientation ( ) {
    enum cdrPageOrientation _result;
    HRESULT _hr = get_Orientation(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1900)
inline void VGCore::IVGPage::PutOrientation ( enum cdrPageOrientation pVal ) {
    HRESULT _hr = put_Orientation(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(1901)
inline long VGCore::IVGPage::GetIndex ( ) {
    long _result = 0;
    HRESULT _hr = get_Index(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1902)
inline HRESULT VGCore::IVGPage::Activate ( ) {
    HRESULT _hr = raw_Activate();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(1903)
inline HRESULT VGCore::IVGPage::Delete ( ) {
    HRESULT _hr = raw_Delete();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(1904)
inline VGCore::IVGLayerPtr VGCore::IVGPage::CreateLayer ( _bstr_t LayerName ) {
    struct IVGLayer * _result = 0;
    HRESULT _hr = raw_CreateLayer(LayerName, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGLayerPtr(_result, false);
}

#pragma implementation_key(1905)
inline VGCore::IVGShapePtr VGCore::IVGPage::TextFind ( _bstr_t Text, VARIANT_BOOL CaseSensitive ) {
    struct IVGShape * _result = 0;
    HRESULT _hr = raw_TextFind(Text, CaseSensitive, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGShapePtr(_result, false);
}

#pragma implementation_key(1906)
inline HRESULT VGCore::IVGPage::TextReplace ( _bstr_t OldText, _bstr_t NewText, VARIANT_BOOL CaseSensitive, VARIANT_BOOL ReplaceSelectedOnly ) {
    HRESULT _hr = raw_TextReplace(OldText, NewText, CaseSensitive, ReplaceSelectedOnly);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(1907)
inline VGCore::IVGShapePtr VGCore::IVGPage::SelectShapesAtPoint ( double x, double y, VARIANT_BOOL SelectUnfilled, double HotArea ) {
    struct IVGShape * _result = 0;
    HRESULT _hr = raw_SelectShapesAtPoint(x, y, SelectUnfilled, HotArea, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGShapePtr(_result, false);
}

#pragma implementation_key(1908)
inline VGCore::IVGShapePtr VGCore::IVGPage::SelectShapesFromRectangle ( double x1, double y1, double x2, double y2, VARIANT_BOOL Touch ) {
    struct IVGShape * _result = 0;
    HRESULT _hr = raw_SelectShapesFromRectangle(x1, y1, x2, y2, Touch, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGShapePtr(_result, false);
}

#pragma implementation_key(1909)
inline enum VGCore::cdrPageBackground VGCore::IVGPage::GetBackground ( ) {
    enum cdrPageBackground _result;
    HRESULT _hr = get_Background(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1910)
inline void VGCore::IVGPage::PutBackground ( enum cdrPageBackground pVal ) {
    HRESULT _hr = put_Background(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(1911)
inline VGCore::IVGColorPtr VGCore::IVGPage::GetColor ( ) {
    struct IVGColor * _result = 0;
    HRESULT _hr = get_Color(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGColorPtr(_result, false);
}

#pragma implementation_key(1912)
inline void VGCore::IVGPage::PutColor ( struct IVGColor * pVal ) {
    HRESULT _hr = put_Color(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(1913)
inline VARIANT_BOOL VGCore::IVGPage::GetPrintExportBackground ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_PrintExportBackground(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1914)
inline void VGCore::IVGPage::PutPrintExportBackground ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_PrintExportBackground(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(1915)
inline VGCore::IVGShapeRangePtr VGCore::IVGPage::GetGuides ( enum cdrGuideType Type ) {
    struct IVGShapeRange * _result = 0;
    HRESULT _hr = get_Guides(Type, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGShapeRangePtr(_result, false);
}

#pragma implementation_key(1916)
inline VGCore::IVGShapePtr VGCore::IVGPage::FindShape ( _bstr_t Name, enum cdrShapeType Type, long StaticID, VARIANT_BOOL Recursive ) {
    struct IVGShape * _result = 0;
    HRESULT _hr = raw_FindShape(Name, Type, StaticID, Recursive, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGShapePtr(_result, false);
}

#pragma implementation_key(1917)
inline VGCore::IVGShapeRangePtr VGCore::IVGPage::FindShapes ( _bstr_t Name, enum cdrShapeType Type, VARIANT_BOOL Recursive ) {
    struct IVGShapeRange * _result = 0;
    HRESULT _hr = raw_FindShapes(Name, Type, Recursive, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGShapeRangePtr(_result, false);
}

#pragma implementation_key(1918)
inline HRESULT VGCore::IVGPage::MoveTo ( long Index ) {
    HRESULT _hr = raw_MoveTo(Index);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(1919)
inline HRESULT VGCore::IVGPage::UnlockAllShapes ( ) {
    HRESULT _hr = raw_UnlockAllShapes();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(1920)
inline VGCore::IVGPropertiesPtr VGCore::IVGPage::GetProperties ( ) {
    struct IVGProperties * _result = 0;
    HRESULT _hr = get_Properties(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGPropertiesPtr(_result, false);
}

#pragma implementation_key(1921)
inline HRESULT VGCore::IVGPage::GetSize ( double * Width, double * Height ) {
    HRESULT _hr = raw_GetSize(Width, Height);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(1922)
inline HRESULT VGCore::IVGPage::SetSize ( double Width, double Height ) {
    HRESULT _hr = raw_SetSize(Width, Height);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(1923)
inline double VGCore::IVGPage::GetCenterX ( ) {
    double _result = 0;
    HRESULT _hr = get_CenterX(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1924)
inline double VGCore::IVGPage::GetCenterY ( ) {
    double _result = 0;
    HRESULT _hr = get_CenterY(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1925)
inline _variant_t VGCore::IVGPage::CustomCommand ( _bstr_t ComponentID, _bstr_t CommandID, SAFEARRAY * * Parameters ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = raw_CustomCommand(ComponentID, CommandID, Parameters, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

#pragma implementation_key(1926)
inline VGCore::IVGPagePtr VGCore::IVGPage::GetPrevious ( ) {
    struct IVGPage * _result = 0;
    HRESULT _hr = get_Previous(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGPagePtr(_result, false);
}

#pragma implementation_key(1927)
inline VGCore::IVGPagePtr VGCore::IVGPage::GetNext ( ) {
    struct IVGPage * _result = 0;
    HRESULT _hr = get_Next(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGPagePtr(_result, false);
}

#pragma implementation_key(1928)
inline VGCore::IVGShapesPtr VGCore::IVGPage::GetSelectableShapes ( ) {
    struct IVGShapes * _result = 0;
    HRESULT _hr = get_SelectableShapes(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGShapesPtr(_result, false);
}

#pragma implementation_key(1929)
inline VGCore::IVGTreeNodePtr VGCore::IVGPage::GetTreeNode ( ) {
    struct IVGTreeNode * _result = 0;
    HRESULT _hr = get_TreeNode(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGTreeNodePtr(_result, false);
}

#pragma implementation_key(1930)
inline HRESULT VGCore::IVGPage::GetCenterPosition ( double * CenterX, double * CenterY ) {
    HRESULT _hr = raw_GetCenterPosition(CenterX, CenterY);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(1931)
inline HRESULT VGCore::IVGPage::SelectSize ( _bstr_t PageSizeName, VARIANT_BOOL Landscape ) {
    HRESULT _hr = raw_SelectSize(PageSizeName, Landscape);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(1932)
inline VGCore::IVGLayerPtr VGCore::IVGPage::GetGuidesLayer ( ) {
    struct IVGLayer * _result = 0;
    HRESULT _hr = get_GuidesLayer(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGLayerPtr(_result, false);
}

#pragma implementation_key(1933)
inline VGCore::IVGLayerPtr VGCore::IVGPage::GetDesktopLayer ( ) {
    struct IVGLayer * _result = 0;
    HRESULT _hr = get_DesktopLayer(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGLayerPtr(_result, false);
}

#pragma implementation_key(1934)
inline VGCore::IVGLayerPtr VGCore::IVGPage::GetGridLayer ( ) {
    struct IVGLayer * _result = 0;
    HRESULT _hr = get_GridLayer(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGLayerPtr(_result, false);
}

#pragma implementation_key(1935)
inline HRESULT VGCore::IVGPage::GetBoundingBox ( double * x, double * y, double * Width, double * Height ) {
    HRESULT _hr = raw_GetBoundingBox(x, y, Width, Height);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(1936)
inline double VGCore::IVGPage::GetLeftX ( ) {
    double _result = 0;
    HRESULT _hr = get_LeftX(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1937)
inline double VGCore::IVGPage::GetRightX ( ) {
    double _result = 0;
    HRESULT _hr = get_RightX(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1938)
inline double VGCore::IVGPage::GetBottomY ( ) {
    double _result = 0;
    HRESULT _hr = get_BottomY(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1939)
inline double VGCore::IVGPage::GetTopY ( ) {
    double _result = 0;
    HRESULT _hr = get_TopY(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1940)
inline VGCore::IVGLayersPtr VGCore::IVGPage::GetAllLayers ( ) {
    struct IVGLayers * _result = 0;
    HRESULT _hr = get_AllLayers(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGLayersPtr(_result, false);
}

#pragma implementation_key(1941)
inline VGCore::IVGRectPtr VGCore::IVGPage::GetBoundingBox ( ) {
    struct IVGRect * _result = 0;
    HRESULT _hr = get_BoundingBox(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGRectPtr(_result, false);
}

#pragma implementation_key(1942)
inline VGCore::IVGSpreadPtr VGCore::IVGPage::GetSpread ( ) {
    struct IVGSpread * _result = 0;
    HRESULT _hr = get_Spread(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGSpreadPtr(_result, false);
}

#pragma implementation_key(1943)
inline VGCore::IVGSnapPointPtr VGCore::IVGPage::FindClosestSnapPoint ( enum cdrPointType TypeSet, double PositionX, double PositionY, double HotArea ) {
    struct IVGSnapPoint * _result = 0;
    HRESULT _hr = raw_FindClosestSnapPoint(TypeSet, PositionX, PositionY, HotArea, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGSnapPointPtr(_result, false);
}

#pragma implementation_key(1944)
inline VGCore::IVGRectPtr VGCore::IVGPage::GetObjectsBoundingBox ( VARIANT_BOOL SelectedOnly, VARIANT_BOOL IncludeNonPrintable ) {
    struct IVGRect * _result = 0;
    HRESULT _hr = raw_GetObjectsBoundingBox(SelectedOnly, IncludeNonPrintable, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGRectPtr(_result, false);
}

#pragma implementation_key(1945)
inline VGCore::IVGShapePtr VGCore::IVGPage::FindShapeAtPoint ( double x, double y, VARIANT_BOOL TreatAsFilled ) {
    struct IVGShape * _result = 0;
    HRESULT _hr = raw_FindShapeAtPoint(x, y, TreatAsFilled, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGShapePtr(_result, false);
}

#pragma implementation_key(1946)
inline VGCore::IVGPageMarkupPtr VGCore::IVGPage::GetMarkup ( ) {
    struct IVGPageMarkup * _result = 0;
    HRESULT _hr = get_Markup(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGPageMarkupPtr(_result, false);
}

//
// interface IVGPages wrapper method implementations
//

#pragma implementation_key(1947)
inline VGCore::IVGApplicationPtr VGCore::IVGPages::GetApplication ( ) {
    struct IVGApplication * _result = 0;
    HRESULT _hr = get_Application(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGApplicationPtr(_result, false);
}

#pragma implementation_key(1948)
inline VGCore::IVGDocumentPtr VGCore::IVGPages::GetParent ( ) {
    struct IVGDocument * _result = 0;
    HRESULT _hr = get_Parent(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGDocumentPtr(_result, false);
}

#pragma implementation_key(1949)
inline VGCore::IVGPagePtr VGCore::IVGPages::GetItem ( long Index ) {
    struct IVGPage * _result = 0;
    HRESULT _hr = get_Item(Index, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGPagePtr(_result, false);
}

#pragma implementation_key(1950)
inline IUnknownPtr VGCore::IVGPages::Get_NewEnum ( ) {
    IUnknown * _result = 0;
    HRESULT _hr = get__NewEnum(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IUnknownPtr(_result, false);
}

#pragma implementation_key(1951)
inline long VGCore::IVGPages::GetCount ( ) {
    long _result = 0;
    HRESULT _hr = get_Count(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1952)
inline VGCore::IVGPagePtr VGCore::IVGPages::GetFirst ( ) {
    struct IVGPage * _result = 0;
    HRESULT _hr = get_First(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGPagePtr(_result, false);
}

#pragma implementation_key(1953)
inline VGCore::IVGPagePtr VGCore::IVGPages::GetLast ( ) {
    struct IVGPage * _result = 0;
    HRESULT _hr = get_Last(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGPagePtr(_result, false);
}

//
// interface IVGLayers wrapper method implementations
//

#pragma implementation_key(1954)
inline VGCore::IVGApplicationPtr VGCore::IVGLayers::GetApplication ( ) {
    struct IVGApplication * _result = 0;
    HRESULT _hr = get_Application(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGApplicationPtr(_result, false);
}

#pragma implementation_key(1955)
inline VGCore::IVGPagePtr VGCore::IVGLayers::GetParent ( ) {
    struct IVGPage * _result = 0;
    HRESULT _hr = get_Parent(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGPagePtr(_result, false);
}

#pragma implementation_key(1956)
inline VGCore::IVGLayerPtr VGCore::IVGLayers::GetItem ( const _variant_t & IndexOrName ) {
    struct IVGLayer * _result = 0;
    HRESULT _hr = get_Item(IndexOrName, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGLayerPtr(_result, false);
}

#pragma implementation_key(1957)
inline IUnknownPtr VGCore::IVGLayers::Get_NewEnum ( ) {
    IUnknown * _result = 0;
    HRESULT _hr = get__NewEnum(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IUnknownPtr(_result, false);
}

#pragma implementation_key(1958)
inline long VGCore::IVGLayers::GetCount ( ) {
    long _result = 0;
    HRESULT _hr = get_Count(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1959)
inline VGCore::IVGLayerPtr VGCore::IVGLayers::Find ( _bstr_t LayerName ) {
    struct IVGLayer * _result = 0;
    HRESULT _hr = raw_Find(LayerName, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGLayerPtr(_result, false);
}

#pragma implementation_key(1960)
inline VGCore::IVGLayerPtr VGCore::IVGLayers::GetTop ( ) {
    struct IVGLayer * _result = 0;
    HRESULT _hr = get_Top(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGLayerPtr(_result, false);
}

#pragma implementation_key(1961)
inline VGCore::IVGLayerPtr VGCore::IVGLayers::GetBottom ( ) {
    struct IVGLayer * _result = 0;
    HRESULT _hr = get_Bottom(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGLayerPtr(_result, false);
}

//
// interface IVGLayer wrapper method implementations
//

#pragma implementation_key(1962)
inline VGCore::IVGApplicationPtr VGCore::IVGLayer::GetApplication ( ) {
    struct IVGApplication * _result = 0;
    HRESULT _hr = get_Application(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGApplicationPtr(_result, false);
}

#pragma implementation_key(1963)
inline VGCore::IVGLayersPtr VGCore::IVGLayer::GetParent ( ) {
    struct IVGLayers * _result = 0;
    HRESULT _hr = get_Parent(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGLayersPtr(_result, false);
}

#pragma implementation_key(1964)
inline _bstr_t VGCore::IVGLayer::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(1965)
inline void VGCore::IVGLayer::PutName ( _bstr_t pVal ) {
    HRESULT _hr = put_Name(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(1966)
inline VGCore::IVGShapesPtr VGCore::IVGLayer::GetShapes ( ) {
    struct IVGShapes * _result = 0;
    HRESULT _hr = get_Shapes(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGShapesPtr(_result, false);
}

#pragma implementation_key(1967)
inline HRESULT VGCore::IVGLayer::Activate ( ) {
    HRESULT _hr = raw_Activate();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(1968)
inline VARIANT_BOOL VGCore::IVGLayer::GetVisible ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_Visible(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1969)
inline void VGCore::IVGLayer::PutVisible ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_Visible(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(1970)
inline VARIANT_BOOL VGCore::IVGLayer::GetPrintable ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_Printable(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1971)
inline void VGCore::IVGLayer::PutPrintable ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_Printable(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(1972)
inline VARIANT_BOOL VGCore::IVGLayer::GetEditable ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_Editable(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1973)
inline void VGCore::IVGLayer::PutEditable ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_Editable(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(1974)
inline VARIANT_BOOL VGCore::IVGLayer::GetMaster ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_Master(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1975)
inline void VGCore::IVGLayer::PutMaster ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_Master(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(1976)
inline VARIANT_BOOL VGCore::IVGLayer::GetOverrideColor ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_OverrideColor(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1977)
inline void VGCore::IVGLayer::PutOverrideColor ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_OverrideColor(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(1978)
inline VGCore::IVGColorPtr VGCore::IVGLayer::GetColor ( ) {
    struct IVGColor * _result = 0;
    HRESULT _hr = get_Color(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGColorPtr(_result, false);
}

#pragma implementation_key(1979)
inline void VGCore::IVGLayer::PutColor ( struct IVGColor * pVal ) {
    HRESULT _hr = put_Color(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(1980)
inline HRESULT VGCore::IVGLayer::Delete ( ) {
    HRESULT _hr = raw_Delete();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(1981)
inline HRESULT VGCore::IVGLayer::MoveAbove ( struct IVGLayer * Layer ) {
    HRESULT _hr = raw_MoveAbove(Layer);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(1982)
inline HRESULT VGCore::IVGLayer::MoveBelow ( struct IVGLayer * Layer ) {
    HRESULT _hr = raw_MoveBelow(Layer);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(1983)
inline HRESULT VGCore::IVGLayer::Import ( _bstr_t FileName, enum cdrFilter Filter, struct IVGStructImportOptions * Options ) {
    HRESULT _hr = raw_Import(FileName, Filter, Options);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(1984)
inline VGCore::IVGShapePtr VGCore::IVGLayer::CreateRectangle ( double Left, double Top, double Right, double Bottom, long CornerUL, long CornerUR, long CornerLR, long CornerLL ) {
    struct IVGShape * _result = 0;
    HRESULT _hr = raw_CreateRectangle(Left, Top, Right, Bottom, CornerUL, CornerUR, CornerLR, CornerLL, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGShapePtr(_result, false);
}

#pragma implementation_key(1985)
inline VGCore::IVGShapePtr VGCore::IVGLayer::CreateEllipse ( double Left, double Top, double Right, double Bottom, double StartAngle, double EndAngle, VARIANT_BOOL Pie ) {
    struct IVGShape * _result = 0;
    HRESULT _hr = raw_CreateEllipse(Left, Top, Right, Bottom, StartAngle, EndAngle, Pie, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGShapePtr(_result, false);
}

#pragma implementation_key(1986)
inline VGCore::IVGShapePtr VGCore::IVGLayer::CreatePolygon ( double Left, double Top, double Right, double Bottom, long Sides, long SubPaths, long Complexity, VARIANT_BOOL Star, long StarComplexity, long MaxComplexity ) {
    struct IVGShape * _result = 0;
    HRESULT _hr = raw_CreatePolygon(Left, Top, Right, Bottom, Sides, SubPaths, Complexity, Star, StarComplexity, MaxComplexity, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGShapePtr(_result, false);
}

#pragma implementation_key(1987)
inline VGCore::IVGShapePtr VGCore::IVGLayer::CreateGridBoxes ( double Left, double Top, double Right, double Bottom, long Wide, long High ) {
    struct IVGShape * _result = 0;
    HRESULT _hr = raw_CreateGridBoxes(Left, Top, Right, Bottom, Wide, High, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGShapePtr(_result, false);
}

#pragma implementation_key(1988)
inline VGCore::IVGShapePtr VGCore::IVGLayer::CreateSpiral ( double Left, double Top, double Right, double Bottom, long NumRevolutions, enum cdrSpiralType SpiralType, long GrowthRate ) {
    struct IVGShape * _result = 0;
    HRESULT _hr = raw_CreateSpiral(Left, Top, Right, Bottom, NumRevolutions, SpiralType, GrowthRate, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGShapePtr(_result, false);
}

#pragma implementation_key(1989)
inline VGCore::IVGShapePtr VGCore::IVGLayer::CreateArtisticText ( double Left, double Bottom, _bstr_t Text, enum cdrTextLanguage LanguageID, enum cdrTextCharSet CharSet, _bstr_t Font, float Size, enum cdrTriState Bold, enum cdrTriState Italic, enum cdrFontLine Underline, enum cdrAlignment Alignment ) {
    struct IVGShape * _result = 0;
    HRESULT _hr = raw_CreateArtisticText(Left, Bottom, Text, LanguageID, CharSet, Font, Size, Bold, Italic, Underline, Alignment, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGShapePtr(_result, false);
}

#pragma implementation_key(1990)
inline VGCore::IVGShapePtr VGCore::IVGLayer::CreateParagraphText ( double Left, double Top, double Right, double Bottom, _bstr_t Text, enum cdrTextLanguage LanguageID, enum cdrTextCharSet CharSet, _bstr_t Font, float Size, enum cdrTriState Bold, enum cdrTriState Italic, enum cdrFontLine Underline, enum cdrAlignment Alignment ) {
    struct IVGShape * _result = 0;
    HRESULT _hr = raw_CreateParagraphText(Left, Top, Right, Bottom, Text, LanguageID, CharSet, Font, Size, Bold, Italic, Underline, Alignment, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGShapePtr(_result, false);
}

#pragma implementation_key(1991)
inline VGCore::IVGShapePtr VGCore::IVGLayer::CreateCurveSegment ( double StartX, double StartY, double EndX, double EndY, double StartingControlPointLength, double StartingControlPointAngle, double EndingControlPointLength, double EndingControlPointAngle ) {
    struct IVGShape * _result = 0;
    HRESULT _hr = raw_CreateCurveSegment(StartX, StartY, EndX, EndY, StartingControlPointLength, StartingControlPointAngle, EndingControlPointLength, EndingControlPointAngle, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGShapePtr(_result, false);
}

#pragma implementation_key(1992)
inline VGCore::IVGShapePtr VGCore::IVGLayer::CreateLineSegment ( double StartX, double StartY, double EndX, double EndY ) {
    struct IVGShape * _result = 0;
    HRESULT _hr = raw_CreateLineSegment(StartX, StartY, EndX, EndY, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGShapePtr(_result, false);
}

#pragma implementation_key(1993)
inline VGCore::IVGShapePtr VGCore::IVGLayer::CreateConnector ( struct IVGSnapPoint * Start, struct IVGSnapPoint * End ) {
    struct IVGShape * _result = 0;
    HRESULT _hr = raw_CreateConnector(Start, End, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGShapePtr(_result, false);
}

#pragma implementation_key(1994)
inline VGCore::IVGShapePtr VGCore::IVGLayer::CreateCurve ( struct IVGCurve * Source ) {
    struct IVGShape * _result = 0;
    HRESULT _hr = raw_CreateCurve(Source, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGShapePtr(_result, false);
}

#pragma implementation_key(1995)
inline VGCore::IVGShapePtr VGCore::IVGLayer::Paste ( ) {
    struct IVGShape * _result = 0;
    HRESULT _hr = raw_Paste(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGShapePtr(_result, false);
}

#pragma implementation_key(1996)
inline VGCore::IVGShapePtr VGCore::IVGLayer::CreateGuideAngle ( double x, double y, double Angle ) {
    struct IVGShape * _result = 0;
    HRESULT _hr = raw_CreateGuideAngle(x, y, Angle, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGShapePtr(_result, false);
}

#pragma implementation_key(1997)
inline VGCore::IVGShapePtr VGCore::IVGLayer::CreateGuide ( double x1, double y1, double x2, double y2 ) {
    struct IVGShape * _result = 0;
    HRESULT _hr = raw_CreateGuide(x1, y1, x2, y2, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGShapePtr(_result, false);
}

#pragma implementation_key(1998)
inline VGCore::IVGShapePtr VGCore::IVGLayer::CreateEllipse2 ( double CenterX, double CenterY, double Radius1, double Radius2, double StartAngle, double EndAngle, VARIANT_BOOL Pie ) {
    struct IVGShape * _result = 0;
    HRESULT _hr = raw_CreateEllipse2(CenterX, CenterY, Radius1, Radius2, StartAngle, EndAngle, Pie, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGShapePtr(_result, false);
}

#pragma implementation_key(1999)
inline VGCore::IVGShapePtr VGCore::IVGLayer::FindShape ( _bstr_t Name, enum cdrShapeType Type, long StaticID, VARIANT_BOOL Recursive ) {
    struct IVGShape * _result = 0;
    HRESULT _hr = raw_FindShape(Name, Type, StaticID, Recursive, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGShapePtr(_result, false);
}

#pragma implementation_key(2000)
inline VGCore::IVGShapeRangePtr VGCore::IVGLayer::FindShapes ( _bstr_t Name, enum cdrShapeType Type, VARIANT_BOOL Recursive ) {
    struct IVGShapeRange * _result = 0;
    HRESULT _hr = raw_FindShapes(Name, Type, Recursive, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGShapeRangePtr(_result, false);
}

#pragma implementation_key(2001)
inline VGCore::IVGShapePtr VGCore::IVGLayer::CreateRectangle2 ( double x, double y, double Width, double Height, double RadiusUL, double RadiusUR, double RadiusLR, double RadiusLL ) {
    struct IVGShape * _result = 0;
    HRESULT _hr = raw_CreateRectangle2(x, y, Width, Height, RadiusUL, RadiusUR, RadiusLR, RadiusLL, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGShapePtr(_result, false);
}

#pragma implementation_key(2002)
inline VGCore::IVGShapePtr VGCore::IVGLayer::CreateFreeConnector ( double x1, double y1, double x2, double y2 ) {
    struct IVGShape * _result = 0;
    HRESULT _hr = raw_CreateFreeConnector(x1, y1, x2, y2, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGShapePtr(_result, false);
}

#pragma implementation_key(2003)
inline VGCore::IVGPropertiesPtr VGCore::IVGLayer::GetProperties ( ) {
    struct IVGProperties * _result = 0;
    HRESULT _hr = get_Properties(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGPropertiesPtr(_result, false);
}

#pragma implementation_key(2004)
inline VGCore::IVGPropertiesPtr VGCore::IVGLayer::GetMasterProperties ( ) {
    struct IVGProperties * _result = 0;
    HRESULT _hr = get_MasterProperties(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGPropertiesPtr(_result, false);
}

#pragma implementation_key(2005)
inline long VGCore::IVGLayer::GetIndex ( ) {
    long _result = 0;
    HRESULT _hr = get_Index(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2006)
inline VGCore::IVGShapePtr VGCore::IVGLayer::CreateCurveSegment2 ( double x1, double y1, double StartingControlPointX, double StartingControlPointY, double EndingControlPointX, double EndingControlPointY, double x2, double y2 ) {
    struct IVGShape * _result = 0;
    HRESULT _hr = raw_CreateCurveSegment2(x1, y1, StartingControlPointX, StartingControlPointY, EndingControlPointX, EndingControlPointY, x2, y2, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGShapePtr(_result, false);
}

#pragma implementation_key(2007)
inline VGCore::ICorelImportFilterPtr VGCore::IVGLayer::ImportEx ( _bstr_t FileName, enum cdrFilter Filter, struct IVGStructImportOptions * Options ) {
    struct ICorelImportFilter * _result = 0;
    HRESULT _hr = raw_ImportEx(FileName, Filter, Options, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return ICorelImportFilterPtr(_result, false);
}

#pragma implementation_key(2008)
inline VGCore::IVGShapePtr VGCore::IVGLayer::CreateArtisticTextWide ( double Left, double Bottom, _bstr_t Text, enum cdrTextLanguage LanguageID, enum cdrTextCharSet CharSet, _bstr_t Font, float Size, enum cdrTriState Bold, enum cdrTriState Italic, enum cdrFontLine Underline, enum cdrAlignment Alignment ) {
    struct IVGShape * _result = 0;
    HRESULT _hr = raw_CreateArtisticTextWide(Left, Bottom, Text, LanguageID, CharSet, Font, Size, Bold, Italic, Underline, Alignment, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGShapePtr(_result, false);
}

#pragma implementation_key(2009)
inline VGCore::IVGShapePtr VGCore::IVGLayer::CreateParagraphTextWide ( double Left, double Top, double Right, double Bottom, _bstr_t Text, enum cdrTextLanguage LanguageID, enum cdrTextCharSet CharSet, _bstr_t Font, float Size, enum cdrTriState Bold, enum cdrTriState Italic, enum cdrFontLine Underline, enum cdrAlignment Alignment ) {
    struct IVGShape * _result = 0;
    HRESULT _hr = raw_CreateParagraphTextWide(Left, Top, Right, Bottom, Text, LanguageID, CharSet, Font, Size, Bold, Italic, Underline, Alignment, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGShapePtr(_result, false);
}

#pragma implementation_key(2010)
inline _variant_t VGCore::IVGLayer::CustomCommand ( _bstr_t ComponentID, _bstr_t CommandID, SAFEARRAY * * Parameters ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = raw_CustomCommand(ComponentID, CommandID, Parameters, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

#pragma implementation_key(2011)
inline VGCore::IVGShapePtr VGCore::IVGLayer::CreateCustomShape ( _bstr_t TypeID, SAFEARRAY * * Parameters ) {
    struct IVGShape * _result = 0;
    HRESULT _hr = raw_CreateCustomShape(TypeID, Parameters, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGShapePtr(_result, false);
}

#pragma implementation_key(2012)
inline VGCore::IVGShapePtr VGCore::IVGLayer::CreateLinearDimension ( enum cdrLinearDimensionType Type, struct IVGSnapPoint * Point1, struct IVGSnapPoint * Point2, VARIANT_BOOL TextCentered, double TextX, double TextY, enum cdrDimensionStyle Style, long Precision, VARIANT_BOOL ShowUnits, enum cdrDimensionLinearUnits Units, enum cdrDimensionPlacement Placement, VARIANT_BOOL HorizontalText, VARIANT_BOOL BoxedText, VARIANT_BOOL LeadingZero, _bstr_t Prefix, _bstr_t Suffix, double OutlineWidth, struct IVGArrowHead * Arrows, struct IVGColor * OutlineColor, _bstr_t TextFont, double TextSize, struct IVGColor * TextColor ) {
    struct IVGShape * _result = 0;
    HRESULT _hr = raw_CreateLinearDimension(Type, Point1, Point2, TextCentered, TextX, TextY, Style, Precision, ShowUnits, Units, Placement, HorizontalText, BoxedText, LeadingZero, Prefix, Suffix, OutlineWidth, Arrows, OutlineColor, TextFont, TextSize, TextColor, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGShapePtr(_result, false);
}

#pragma implementation_key(2013)
inline VGCore::IVGShapePtr VGCore::IVGLayer::CreateAngularDimension ( struct IVGSnapPoint * Center, struct IVGSnapPoint * Point1, struct IVGSnapPoint * Point2, double TextX, double TextY, long Precision, VARIANT_BOOL ShowUnits, enum cdrDimensionAngularUnits Units, VARIANT_BOOL BoxedText, VARIANT_BOOL LeadingZero, _bstr_t Prefix, _bstr_t Suffix, double OutlineWidth, struct IVGArrowHead * Arrows, struct IVGColor * OutlineColor, _bstr_t TextFont, double TextSize, struct IVGColor * TextColor ) {
    struct IVGShape * _result = 0;
    HRESULT _hr = raw_CreateAngularDimension(Center, Point1, Point2, TextX, TextY, Precision, ShowUnits, Units, BoxedText, LeadingZero, Prefix, Suffix, OutlineWidth, Arrows, OutlineColor, TextFont, TextSize, TextColor, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGShapePtr(_result, false);
}

#pragma implementation_key(2014)
inline VGCore::IVGShapePtr VGCore::IVGLayer::CreateSymbol ( double x, double y, _bstr_t SymbolName, struct IVGSymbolLibrary * Library ) {
    struct IVGShape * _result = 0;
    HRESULT _hr = raw_CreateSymbol(x, y, SymbolName, Library, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGShapePtr(_result, false);
}

#pragma implementation_key(2015)
inline VGCore::IVGShapePtr VGCore::IVGLayer::CreatePolygon2 ( double CenterX, double CenterY, double Radius, long Sides, double Angle, double InnerRadius, VARIANT_BOOL Star, long Sharpness ) {
    struct IVGShape * _result = 0;
    HRESULT _hr = raw_CreatePolygon2(CenterX, CenterY, Radius, Sides, Angle, InnerRadius, Star, Sharpness, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGShapePtr(_result, false);
}

#pragma implementation_key(2016)
inline VARIANT_BOOL VGCore::IVGLayer::PasteSpecial ( _bstr_t FormatName, VARIANT_BOOL PasteLink, VARIANT_BOOL DisplayAsIcon, _bstr_t Caption, const _variant_t & Icon ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_PasteSpecial(FormatName, PasteLink, DisplayAsIcon, Caption, Icon, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2017)
inline VGCore::IVGShapePtr VGCore::IVGLayer::CreateOLEObject ( _bstr_t ObjectID, VARIANT_BOOL DisplayAsIcon, _bstr_t Caption, const _variant_t & Icon ) {
    struct IVGShape * _result = 0;
    HRESULT _hr = raw_CreateOLEObject(ObjectID, DisplayAsIcon, Caption, Icon, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGShapePtr(_result, false);
}

#pragma implementation_key(2018)
inline VGCore::IVGShapePtr VGCore::IVGLayer::CreateOLEObjectFromFile ( _bstr_t FileName, VARIANT_BOOL Link, VARIANT_BOOL DisplayAsIcon, _bstr_t Caption, const _variant_t & Icon ) {
    struct IVGShape * _result = 0;
    HRESULT _hr = raw_CreateOLEObjectFromFile(FileName, Link, DisplayAsIcon, Caption, Icon, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGShapePtr(_result, false);
}

#pragma implementation_key(2019)
inline VGCore::IVGShapesPtr VGCore::IVGLayer::GetSelectableShapes ( ) {
    struct IVGShapes * _result = 0;
    HRESULT _hr = get_SelectableShapes(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGShapesPtr(_result, false);
}

#pragma implementation_key(2020)
inline VGCore::IVGTreeNodePtr VGCore::IVGLayer::GetTreeNode ( ) {
    struct IVGTreeNode * _result = 0;
    HRESULT _hr = get_TreeNode(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGTreeNodePtr(_result, false);
}

#pragma implementation_key(2021)
inline VARIANT_BOOL VGCore::IVGLayer::GetIsGuidesLayer ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsGuidesLayer(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2022)
inline VARIANT_BOOL VGCore::IVGLayer::GetIsDesktopLayer ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsDesktopLayer(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2023)
inline VARIANT_BOOL VGCore::IVGLayer::GetIsGridLayer ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsGridLayer(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2024)
inline VARIANT_BOOL VGCore::IVGLayer::GetIsSpecialLayer ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsSpecialLayer(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2025)
inline VGCore::IVGLayerPtr VGCore::IVGLayer::GetMasterLayer ( ) {
    struct IVGLayer * _result = 0;
    HRESULT _hr = get_MasterLayer(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGLayerPtr(_result, false);
}

#pragma implementation_key(2026)
inline long VGCore::IVGLayer::GetAbsoluteIndex ( ) {
    long _result = 0;
    HRESULT _hr = get_AbsoluteIndex(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2027)
inline VGCore::IVGPagePtr VGCore::IVGLayer::GetPage ( ) {
    struct IVGPage * _result = 0;
    HRESULT _hr = get_Page(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGPagePtr(_result, false);
}

#pragma implementation_key(2028)
inline VGCore::IVGLayerPtr VGCore::IVGLayer::GetAbove ( VARIANT_BOOL IgnoreMasters ) {
    struct IVGLayer * _result = 0;
    HRESULT _hr = get_Above(IgnoreMasters, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGLayerPtr(_result, false);
}

#pragma implementation_key(2029)
inline VGCore::IVGLayerPtr VGCore::IVGLayer::GetBelow ( VARIANT_BOOL IgnoreMasters ) {
    struct IVGLayer * _result = 0;
    HRESULT _hr = get_Below(IgnoreMasters, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGLayerPtr(_result, false);
}

#pragma implementation_key(2030)
inline VGCore::IVGShapePtr VGCore::IVGLayer::CreateRectangleRect ( struct IVGRect * Rect, double RadiusUL, double RadiusUR, double RadiusLR, double RadiusLL ) {
    struct IVGShape * _result = 0;
    HRESULT _hr = raw_CreateRectangleRect(Rect, RadiusUL, RadiusUR, RadiusLR, RadiusLL, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGShapePtr(_result, false);
}

#pragma implementation_key(2031)
inline VGCore::IVGShapePtr VGCore::IVGLayer::CreateEllipseRect ( struct IVGRect * Rect, double StartAngle, double EndAngle, VARIANT_BOOL Pie ) {
    struct IVGShape * _result = 0;
    HRESULT _hr = raw_CreateEllipseRect(Rect, StartAngle, EndAngle, Pie, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGShapePtr(_result, false);
}

#pragma implementation_key(2032)
inline VGCore::IVGShapePtr VGCore::IVGLayer::CreateConnectorEx ( enum cdrConnectorType Type, struct IVGSnapPoint * Start, struct IVGSnapPoint * End ) {
    struct IVGShape * _result = 0;
    HRESULT _hr = raw_CreateConnectorEx(Type, Start, End, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGShapePtr(_result, false);
}

#pragma implementation_key(2033)
inline VGCore::IVGShapePtr VGCore::IVGLayer::CreateRightAngleConnector ( struct IVGSnapPoint * Start, struct IVGSnapPoint * End, double CornerRadius ) {
    struct IVGShape * _result = 0;
    HRESULT _hr = raw_CreateRightAngleConnector(Start, End, CornerRadius, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGShapePtr(_result, false);
}

#pragma implementation_key(2034)
inline VGCore::IVGShapePtr VGCore::IVGLayer::CreateBSpline ( struct IVGBSpline * Source ) {
    struct IVGShape * _result = 0;
    HRESULT _hr = raw_CreateBSpline(Source, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGShapePtr(_result, false);
}

#pragma implementation_key(2035)
inline VGCore::IVGShapeRangePtr VGCore::IVGLayer::PasteEx ( struct IVGStructPasteOptions * Options ) {
    struct IVGShapeRange * _result = 0;
    HRESULT _hr = raw_PasteEx(Options, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGShapeRangePtr(_result, false);
}

#pragma implementation_key(2036)
inline VGCore::IVGShapePtr VGCore::IVGLayer::CreateToolShape ( _bstr_t ToolShapeGuid, struct IVGProperties * ShapeProperties ) {
    struct IVGShape * _result = 0;
    HRESULT _hr = raw_CreateToolShape(ToolShapeGuid, ShapeProperties, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGShapePtr(_result, false);
}

#pragma implementation_key(2037)
inline VGCore::IVGShapePtr VGCore::IVGLayer::CreateBitmap ( double Left, double Top, double Right, double Bottom, struct IVGImage * Image, struct IVGImage * ImageAlpha ) {
    struct IVGShape * _result = 0;
    HRESULT _hr = raw_CreateBitmap(Left, Top, Right, Bottom, Image, ImageAlpha, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGShapePtr(_result, false);
}

#pragma implementation_key(2038)
inline VGCore::IVGShapePtr VGCore::IVGLayer::CreateBitmap2 ( double x, double y, double Width, double Height, struct IVGImage * Image, struct IVGImage * ImageAlpha ) {
    struct IVGShape * _result = 0;
    HRESULT _hr = raw_CreateBitmap2(x, y, Width, Height, Image, ImageAlpha, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGShapePtr(_result, false);
}

#pragma implementation_key(2039)
inline VGCore::IVGShapePtr VGCore::IVGLayer::CreateBitmapRect ( struct IVGRect * Rect, struct IVGImage * Image, struct IVGImage * ImageAlpha ) {
    struct IVGShape * _result = 0;
    HRESULT _hr = raw_CreateBitmapRect(Rect, Image, ImageAlpha, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGShapePtr(_result, false);
}

//
// interface IVGShapes wrapper method implementations
//

#pragma implementation_key(2040)
inline VGCore::IVGApplicationPtr VGCore::IVGShapes::GetApplication ( ) {
    struct IVGApplication * _result = 0;
    HRESULT _hr = get_Application(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGApplicationPtr(_result, false);
}

#pragma implementation_key(2041)
inline IDispatchPtr VGCore::IVGShapes::GetParent ( ) {
    IDispatch * _result = 0;
    HRESULT _hr = get_Parent(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IDispatchPtr(_result, false);
}

#pragma implementation_key(2042)
inline VGCore::IVGShapePtr VGCore::IVGShapes::GetItem ( const _variant_t & IndexOrName ) {
    struct IVGShape * _result = 0;
    HRESULT _hr = get_Item(IndexOrName, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGShapePtr(_result, false);
}

#pragma implementation_key(2043)
inline IUnknownPtr VGCore::IVGShapes::Get_NewEnum ( ) {
    IUnknown * _result = 0;
    HRESULT _hr = get__NewEnum(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IUnknownPtr(_result, false);
}

#pragma implementation_key(2044)
inline long VGCore::IVGShapes::GetCount ( ) {
    long _result = 0;
    HRESULT _hr = get_Count(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2045)
inline VGCore::IVGShapeRangePtr VGCore::IVGShapes::Range ( SAFEARRAY * * IndexArray ) {
    struct IVGShapeRange * _result = 0;
    HRESULT _hr = raw_Range(IndexArray, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGShapeRangePtr(_result, false);
}

#pragma implementation_key(2046)
inline VGCore::IVGShapeRangePtr VGCore::IVGShapes::All ( ) {
    struct IVGShapeRange * _result = 0;
    HRESULT _hr = raw_All(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGShapeRangePtr(_result, false);
}

#pragma implementation_key(2047)
inline VGCore::IVGShapeRangePtr VGCore::IVGShapes::AllExcluding ( SAFEARRAY * * IndexArray ) {
    struct IVGShapeRange * _result = 0;
    HRESULT _hr = raw_AllExcluding(IndexArray, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGShapeRangePtr(_result, false);
}

#pragma implementation_key(2048)
inline VGCore::IVGShapePtr VGCore::IVGShapes::FindShape ( _bstr_t Name, enum cdrShapeType Type, long StaticID, VARIANT_BOOL Recursive, _bstr_t Query ) {
    struct IVGShape * _result = 0;
    HRESULT _hr = raw_FindShape(Name, Type, StaticID, Recursive, Query, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGShapePtr(_result, false);
}

#pragma implementation_key(2049)
inline VGCore::IVGShapeRangePtr VGCore::IVGShapes::FindShapes ( _bstr_t Name, enum cdrShapeType Type, VARIANT_BOOL Recursive, _bstr_t Query ) {
    struct IVGShapeRange * _result = 0;
    HRESULT _hr = raw_FindShapes(Name, Type, Recursive, Query, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGShapeRangePtr(_result, false);
}

#pragma implementation_key(2050)
inline VGCore::IVGShapePtr VGCore::IVGShapes::GetFirst ( ) {
    struct IVGShape * _result = 0;
    HRESULT _hr = get_First(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGShapePtr(_result, false);
}

#pragma implementation_key(2051)
inline VGCore::IVGShapePtr VGCore::IVGShapes::GetLast ( ) {
    struct IVGShape * _result = 0;
    HRESULT _hr = get_Last(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGShapePtr(_result, false);
}

//
// interface IVGShape wrapper method implementations
//

#pragma implementation_key(2052)
inline VGCore::IVGApplicationPtr VGCore::IVGShape::GetApplication ( ) {
    struct IVGApplication * _result = 0;
    HRESULT _hr = get_Application(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGApplicationPtr(_result, false);
}

#pragma implementation_key(2053)
inline IDispatchPtr VGCore::IVGShape::GetParent ( ) {
    IDispatch * _result = 0;
    HRESULT _hr = get_Parent(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IDispatchPtr(_result, false);
}

#pragma implementation_key(2054)
inline long VGCore::IVGShape::GetStaticID ( ) {
    long _result = 0;
    HRESULT _hr = get_StaticID(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2055)
inline HRESULT VGCore::IVGShape::ConvertToCurves ( ) {
    HRESULT _hr = raw_ConvertToCurves();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(2056)
inline _bstr_t VGCore::IVGShape::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(2057)
inline void VGCore::IVGShape::PutName ( _bstr_t pVal ) {
    HRESULT _hr = put_Name(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(2058)
inline VGCore::IVGShapesPtr VGCore::IVGShape::GetShapes ( ) {
    struct IVGShapes * _result = 0;
    HRESULT _hr = get_Shapes(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGShapesPtr(_result, false);
}

#pragma implementation_key(2059)
inline VGCore::IVGRectanglePtr VGCore::IVGShape::GetRectangle ( ) {
    struct IVGRectangle * _result = 0;
    HRESULT _hr = get_Rectangle(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGRectanglePtr(_result, false);
}

#pragma implementation_key(2060)
inline double VGCore::IVGShape::GetPositionX ( ) {
    double _result = 0;
    HRESULT _hr = get_PositionX(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2061)
inline void VGCore::IVGShape::PutPositionX ( double pVal ) {
    HRESULT _hr = put_PositionX(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(2062)
inline double VGCore::IVGShape::GetPositionY ( ) {
    double _result = 0;
    HRESULT _hr = get_PositionY(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2063)
inline void VGCore::IVGShape::PutPositionY ( double pVal ) {
    HRESULT _hr = put_PositionY(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(2064)
inline double VGCore::IVGShape::GetSizeWidth ( ) {
    double _result = 0;
    HRESULT _hr = get_SizeWidth(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2065)
inline void VGCore::IVGShape::PutSizeWidth ( double pVal ) {
    HRESULT _hr = put_SizeWidth(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(2066)
inline double VGCore::IVGShape::GetSizeHeight ( ) {
    double _result = 0;
    HRESULT _hr = get_SizeHeight(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2067)
inline void VGCore::IVGShape::PutSizeHeight ( double pVal ) {
    HRESULT _hr = put_SizeHeight(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(2068)
inline VGCore::IVGEllipsePtr VGCore::IVGShape::GetEllipse ( ) {
    struct IVGEllipse * _result = 0;
    HRESULT _hr = get_Ellipse(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGEllipsePtr(_result, false);
}

#pragma implementation_key(2069)
inline VGCore::IVGPolygonPtr VGCore::IVGShape::GetPolygon ( ) {
    struct IVGPolygon * _result = 0;
    HRESULT _hr = get_Polygon(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGPolygonPtr(_result, false);
}

#pragma implementation_key(2070)
inline VGCore::IVGCurvePtr VGCore::IVGShape::GetCurve ( ) {
    struct IVGCurve * _result = 0;
    HRESULT _hr = get_Curve(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGCurvePtr(_result, false);
}

#pragma implementation_key(2071)
inline VGCore::IVGBitmapPtr VGCore::IVGShape::GetBitmap ( ) {
    struct IVGBitmap * _result = 0;
    HRESULT _hr = get_Bitmap(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGBitmapPtr(_result, false);
}

#pragma implementation_key(2072)
inline enum VGCore::cdrShapeType VGCore::IVGShape::GetType ( ) {
    enum cdrShapeType _result;
    HRESULT _hr = get_Type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2073)
inline VGCore::IVGOutlinePtr VGCore::IVGShape::GetOutline ( ) {
    struct IVGOutline * _result = 0;
    HRESULT _hr = get_Outline(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGOutlinePtr(_result, false);
}

#pragma implementation_key(2074)
inline VGCore::IVGFillPtr VGCore::IVGShape::GetFill ( ) {
    struct IVGFill * _result = 0;
    HRESULT _hr = get_Fill(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGFillPtr(_result, false);
}

#pragma implementation_key(2075)
inline VGCore::IVGTextPtr VGCore::IVGShape::GetText ( ) {
    struct IVGText * _result = 0;
    HRESULT _hr = get_Text(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGTextPtr(_result, false);
}

#pragma implementation_key(2076)
inline HRESULT VGCore::IVGShape::Delete ( ) {
    HRESULT _hr = raw_Delete();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(2077)
inline VGCore::IVGShapePtr VGCore::IVGShape::Duplicate ( double OffsetX, double OffsetY ) {
    struct IVGShape * _result = 0;
    HRESULT _hr = raw_Duplicate(OffsetX, OffsetY, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGShapePtr(_result, false);
}

#pragma implementation_key(2078)
inline HRESULT VGCore::IVGShape::Skew ( double AngleX, double AngleY ) {
    HRESULT _hr = raw_Skew(AngleX, AngleY);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(2079)
inline HRESULT VGCore::IVGShape::Move ( double DeltaX, double DeltaY ) {
    HRESULT _hr = raw_Move(DeltaX, DeltaY);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(2080)
inline double VGCore::IVGShape::GetRotationAngle ( ) {
    double _result = 0;
    HRESULT _hr = get_RotationAngle(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2081)
inline void VGCore::IVGShape::PutRotationAngle ( double pVal ) {
    HRESULT _hr = put_RotationAngle(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(2082)
inline double VGCore::IVGShape::GetRotationCenterX ( ) {
    double _result = 0;
    HRESULT _hr = get_RotationCenterX(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2083)
inline void VGCore::IVGShape::PutRotationCenterX ( double pVal ) {
    HRESULT _hr = put_RotationCenterX(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(2084)
inline double VGCore::IVGShape::GetRotationCenterY ( ) {
    double _result = 0;
    HRESULT _hr = get_RotationCenterY(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2085)
inline void VGCore::IVGShape::PutRotationCenterY ( double pVal ) {
    HRESULT _hr = put_RotationCenterY(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(2086)
inline HRESULT VGCore::IVGShape::Rotate ( double Angle ) {
    HRESULT _hr = raw_Rotate(Angle);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(2087)
inline VGCore::IVGShapePtr VGCore::IVGShape::ConvertToBitmap ( long BitDepth, VARIANT_BOOL Grayscale, VARIANT_BOOL Dithered, VARIANT_BOOL TransparentBG, long Resolution, enum cdrAntiAliasingType AntiAliasing, VARIANT_BOOL UseColorProfile, VARIANT_BOOL MultiChannel, VARIANT_BOOL AlwaysOverprintBlack, long OverprintBlackLimit ) {
    struct IVGShape * _result = 0;
    HRESULT _hr = raw_ConvertToBitmap(BitDepth, Grayscale, Dithered, TransparentBG, Resolution, AntiAliasing, UseColorProfile, MultiChannel, AlwaysOverprintBlack, OverprintBlackLimit, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGShapePtr(_result, false);
}

#pragma implementation_key(2088)
inline VGCore::IVGShapePtr VGCore::IVGShape::Group ( ) {
    struct IVGShape * _result = 0;
    HRESULT _hr = raw_Group(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGShapePtr(_result, false);
}

#pragma implementation_key(2089)
inline HRESULT VGCore::IVGShape::Ungroup ( ) {
    HRESULT _hr = raw_Ungroup();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(2090)
inline HRESULT VGCore::IVGShape::UngroupAll ( ) {
    HRESULT _hr = raw_UngroupAll();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(2091)
inline HRESULT VGCore::IVGShape::OrderToFront ( ) {
    HRESULT _hr = raw_OrderToFront();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(2092)
inline HRESULT VGCore::IVGShape::OrderToBack ( ) {
    HRESULT _hr = raw_OrderToBack();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(2093)
inline HRESULT VGCore::IVGShape::OrderForwardOne ( ) {
    HRESULT _hr = raw_OrderForwardOne();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(2094)
inline HRESULT VGCore::IVGShape::OrderBackOne ( ) {
    HRESULT _hr = raw_OrderBackOne();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(2095)
inline HRESULT VGCore::IVGShape::OrderFrontOf ( struct IVGShape * Shape ) {
    HRESULT _hr = raw_OrderFrontOf(Shape);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(2096)
inline HRESULT VGCore::IVGShape::OrderBackOf ( struct IVGShape * Shape ) {
    HRESULT _hr = raw_OrderBackOf(Shape);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(2097)
inline VARIANT_BOOL VGCore::IVGShape::OrderIsInFrontOf ( struct IVGShape * Shape ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_OrderIsInFrontOf(Shape, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2098)
inline HRESULT VGCore::IVGShape::AddToSelection ( ) {
    HRESULT _hr = raw_AddToSelection();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(2099)
inline HRESULT VGCore::IVGShape::RemoveFromSelection ( ) {
    HRESULT _hr = raw_RemoveFromSelection();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(2100)
inline HRESULT VGCore::IVGShape::Separate ( ) {
    HRESULT _hr = raw_Separate();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(2101)
inline VGCore::IVGLayerPtr VGCore::IVGShape::GetLayer ( ) {
    struct IVGLayer * _result = 0;
    HRESULT _hr = get_Layer(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGLayerPtr(_result, false);
}

#pragma implementation_key(2102)
inline void VGCore::IVGShape::PutLayer ( struct IVGLayer * ppVal ) {
    HRESULT _hr = put_Layer(ppVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(2103)
inline VGCore::IVGSnapPointsPtr VGCore::IVGShape::GetSnapPoints ( ) {
    struct IVGSnapPoints * _result = 0;
    HRESULT _hr = get_SnapPoints(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGSnapPointsPtr(_result, false);
}

#pragma implementation_key(2104)
inline VGCore::IVGConnectorPtr VGCore::IVGShape::GetConnector ( ) {
    struct IVGConnector * _result = 0;
    HRESULT _hr = get_Connector(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGConnectorPtr(_result, false);
}

#pragma implementation_key(2105)
inline enum VGCore::cdrPositionOfPointOverShape VGCore::IVGShape::IsOnShape ( double x, double y, double HotArea ) {
    enum cdrPositionOfPointOverShape _result;
    HRESULT _hr = raw_IsOnShape(x, y, HotArea, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2106)
inline VGCore::IVGArrowHeadPtr VGCore::IVGShape::CreateArrowHead ( ) {
    struct IVGArrowHead * _result = 0;
    HRESULT _hr = raw_CreateArrowHead(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGArrowHeadPtr(_result, false);
}

#pragma implementation_key(2107)
inline HRESULT VGCore::IVGShape::Copy ( ) {
    HRESULT _hr = raw_Copy();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(2108)
inline HRESULT VGCore::IVGShape::Cut ( ) {
    HRESULT _hr = raw_Cut();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(2109)
inline VGCore::IVGShapePtr VGCore::IVGShape::Clone ( double OffsetX, double OffsetY ) {
    struct IVGShape * _result = 0;
    HRESULT _hr = raw_Clone(OffsetX, OffsetY, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGShapePtr(_result, false);
}

#pragma implementation_key(2110)
inline HRESULT VGCore::IVGShape::Stretch ( double StretchX, double StretchY, VARIANT_BOOL StretchCharactersSize ) {
    HRESULT _hr = raw_Stretch(StretchX, StretchY, StretchCharactersSize);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(2111)
inline HRESULT VGCore::IVGShape::SetPosition ( double PositionX, double PositionY ) {
    HRESULT _hr = raw_SetPosition(PositionX, PositionY);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(2112)
inline HRESULT VGCore::IVGShape::SetSize ( double Width, double Height ) {
    HRESULT _hr = raw_SetSize(Width, Height);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(2113)
inline HRESULT VGCore::IVGShape::GetPosition ( double * PositionX, double * PositionY ) {
    HRESULT _hr = raw_GetPosition(PositionX, PositionY);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(2114)
inline HRESULT VGCore::IVGShape::GetSize ( double * Width, double * Height ) {
    HRESULT _hr = raw_GetSize(Width, Height);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(2115)
inline VGCore::IVGPropertiesPtr VGCore::IVGShape::GetProperties ( ) {
    struct IVGProperties * _result = 0;
    HRESULT _hr = get_Properties(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGPropertiesPtr(_result, false);
}

#pragma implementation_key(2116)
inline HRESULT VGCore::IVGShape::OrderReverse ( ) {
    HRESULT _hr = raw_OrderReverse();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(2117)
inline VGCore::IVGShapePtr VGCore::IVGShape::Combine ( ) {
    struct IVGShape * _result = 0;
    HRESULT _hr = raw_Combine(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGShapePtr(_result, false);
}

#pragma implementation_key(2118)
inline HRESULT VGCore::IVGShape::BreakApart ( ) {
    HRESULT _hr = raw_BreakApart();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(2119)
inline void VGCore::IVGShape::PutFill ( struct IVGFill * ppVal ) {
    HRESULT _hr = put_Fill(ppVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(2120)
inline VGCore::IVGShapePtr VGCore::IVGShape::Weld ( struct IVGShape * TargetShape, VARIANT_BOOL LeaveSource, VARIANT_BOOL LeaveTarget ) {
    struct IVGShape * _result = 0;
    HRESULT _hr = raw_Weld(TargetShape, LeaveSource, LeaveTarget, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGShapePtr(_result, false);
}

#pragma implementation_key(2121)
inline VGCore::IVGShapePtr VGCore::IVGShape::Trim ( struct IVGShape * TargetShape, VARIANT_BOOL LeaveSource, VARIANT_BOOL LeaveTarget ) {
    struct IVGShape * _result = 0;
    HRESULT _hr = raw_Trim(TargetShape, LeaveSource, LeaveTarget, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGShapePtr(_result, false);
}

#pragma implementation_key(2122)
inline VGCore::IVGShapePtr VGCore::IVGShape::Intersect ( struct IVGShape * TargetShape, VARIANT_BOOL LeaveSource, VARIANT_BOOL LeaveTarget ) {
    struct IVGShape * _result = 0;
    HRESULT _hr = raw_Intersect(TargetShape, LeaveSource, LeaveTarget, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGShapePtr(_result, false);
}

#pragma implementation_key(2123)
inline VGCore::IVGEffectsPtr VGCore::IVGShape::GetEffects ( ) {
    struct IVGEffects * _result = 0;
    HRESULT _hr = get_Effects(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGEffectsPtr(_result, false);
}

#pragma implementation_key(2124)
inline VGCore::IVGEffectPtr VGCore::IVGShape::GetEffect ( ) {
    struct IVGEffect * _result = 0;
    HRESULT _hr = get_Effect(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGEffectPtr(_result, false);
}

#pragma implementation_key(2125)
inline VGCore::IVGEffectPtr VGCore::IVGShape::CreateDropShadow ( enum cdrDropShadowType Type, long Opacity, long Feather, double OffsetX, double OffsetY, struct IVGColor * Color, enum cdrFeatherType FeatherType, enum cdrEdgeType FeatherEdge, double PerspectiveAngle, double PerspectiveStretch, long Fade, enum cdrMergeMode MergeMode ) {
    struct IVGEffect * _result = 0;
    HRESULT _hr = raw_CreateDropShadow(Type, Opacity, Feather, OffsetX, OffsetY, Color, FeatherType, FeatherEdge, PerspectiveAngle, PerspectiveStretch, Fade, MergeMode, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGEffectPtr(_result, false);
}

#pragma implementation_key(2126)
inline VGCore::IVGEffectPtr VGCore::IVGShape::CreateBlend ( struct IVGShape * Shape, int Steps, enum cdrFountainFillBlendType ColorBlendType, enum cdrBlendMode Mode, double Spacing, double Angle, VARIANT_BOOL Loop, struct IVGShape * Path, VARIANT_BOOL RotateShapes, long SpacingAccel, long ColorAccel, VARIANT_BOOL AccelSize ) {
    struct IVGEffect * _result = 0;
    HRESULT _hr = raw_CreateBlend(Shape, Steps, ColorBlendType, Mode, Spacing, Angle, Loop, Path, RotateShapes, SpacingAccel, ColorAccel, AccelSize, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGEffectPtr(_result, false);
}

#pragma implementation_key(2127)
inline VGCore::IVGEffectPtr VGCore::IVGShape::CreateExtrude ( enum cdrExtrudeType Type, enum cdrExtrudeVPType VPType, double VPX, double VPY, double Depth, enum cdrExtrudeShading Shading, struct IVGColor * BaseColor, struct IVGColor * ShadingColor, double BevelDepth, double BevelAngle, struct IVGColor * BevelColor, VARIANT_BOOL BevelOnly ) {
    struct IVGEffect * _result = 0;
    HRESULT _hr = raw_CreateExtrude(Type, VPType, VPX, VPY, Depth, Shading, BaseColor, ShadingColor, BevelDepth, BevelAngle, BevelColor, BevelOnly, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGEffectPtr(_result, false);
}

#pragma implementation_key(2128)
inline VGCore::IVGEffectPtr VGCore::IVGShape::CreateEnvelope ( long PresetIndex, enum cdrEnvelopeMode Mode, VARIANT_BOOL KeepLines ) {
    struct IVGEffect * _result = 0;
    HRESULT _hr = raw_CreateEnvelope(PresetIndex, Mode, KeepLines, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGEffectPtr(_result, false);
}

#pragma implementation_key(2129)
inline HRESULT VGCore::IVGShape::Flip ( enum cdrFlipAxes Axes ) {
    HRESULT _hr = raw_Flip(Axes);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(2130)
inline VARIANT_BOOL VGCore::IVGShape::GetLocked ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_Locked(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2131)
inline void VGCore::IVGShape::PutLocked ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_Locked(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(2132)
inline double VGCore::IVGShape::GetOriginalWidth ( ) {
    double _result = 0;
    HRESULT _hr = get_OriginalWidth(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2133)
inline double VGCore::IVGShape::GetOriginalHeight ( ) {
    double _result = 0;
    HRESULT _hr = get_OriginalHeight(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2134)
inline VARIANT_BOOL VGCore::IVGShape::GetSelected ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_Selected(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2135)
inline void VGCore::IVGShape::PutSelected ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_Selected(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(2136)
inline VGCore::IVGEffectPtr VGCore::IVGShape::CreateLens ( enum cdrLensType Type, double RateOrMagnification, struct IVGColor * Color1, struct IVGColor * Color2, enum cdrFountainFillBlendType ColorMapPalette ) {
    struct IVGEffect * _result = 0;
    HRESULT _hr = raw_CreateLens(Type, RateOrMagnification, Color1, Color2, ColorMapPalette, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGEffectPtr(_result, false);
}

#pragma implementation_key(2137)
inline VGCore::IVGEffectPtr VGCore::IVGShape::CreatePerspective ( const _variant_t & HorizVanishPointX, const _variant_t & HorizVanishPointY, const _variant_t & VertVanishPointX, const _variant_t & VertVanishPointY ) {
    struct IVGEffect * _result = 0;
    HRESULT _hr = raw_CreatePerspective(HorizVanishPointX, HorizVanishPointY, VertVanishPointX, VertVanishPointY, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGEffectPtr(_result, false);
}

#pragma implementation_key(2138)
inline VGCore::IVGEffectPtr VGCore::IVGShape::CreateContour ( enum cdrContourDirection Direction, double Offset, long Steps, enum cdrFountainFillBlendType BlendType, struct IVGColor * OutlineColor, struct IVGColor * FillColor, struct IVGColor * FillColor2, long SpacingAccel, long ColorAccel, enum cdrContourEndCapType EndCapType, enum cdrContourCornerType CornerType, double MiterLimit ) {
    struct IVGEffect * _result = 0;
    HRESULT _hr = raw_CreateContour(Direction, Offset, Steps, BlendType, OutlineColor, FillColor, FillColor2, SpacingAccel, ColorAccel, EndCapType, CornerType, MiterLimit, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGEffectPtr(_result, false);
}

#pragma implementation_key(2139)
inline VGCore::IVGEffectPtr VGCore::IVGShape::CreatePushPullDistortion ( double OriginX, double OriginY, long Amplitude ) {
    struct IVGEffect * _result = 0;
    HRESULT _hr = raw_CreatePushPullDistortion(OriginX, OriginY, Amplitude, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGEffectPtr(_result, false);
}

#pragma implementation_key(2140)
inline VGCore::IVGEffectPtr VGCore::IVGShape::CreateZipperDistortion ( double OriginX, double OriginY, long Amplitude, long Frequency, VARIANT_BOOL Random, VARIANT_BOOL Smooth, VARIANT_BOOL Local ) {
    struct IVGEffect * _result = 0;
    HRESULT _hr = raw_CreateZipperDistortion(OriginX, OriginY, Amplitude, Frequency, Random, Smooth, Local, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGEffectPtr(_result, false);
}

#pragma implementation_key(2141)
inline VGCore::IVGEffectPtr VGCore::IVGShape::CreateTwisterDistortion ( double OriginX, double OriginY, double Angle ) {
    struct IVGEffect * _result = 0;
    HRESULT _hr = raw_CreateTwisterDistortion(OriginX, OriginY, Angle, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGEffectPtr(_result, false);
}

#pragma implementation_key(2142)
inline VGCore::IVGGuidePtr VGCore::IVGShape::GetGuide ( ) {
    struct IVGGuide * _result = 0;
    HRESULT _hr = get_Guide(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGGuidePtr(_result, false);
}

#pragma implementation_key(2143)
inline HRESULT VGCore::IVGShape::AddToPowerClip ( struct IVGShape * Shape, enum cdrTriState CenterInContainer ) {
    HRESULT _hr = raw_AddToPowerClip(Shape, CenterInContainer);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(2144)
inline HRESULT VGCore::IVGShape::RemoveFromContainer ( long Level ) {
    HRESULT _hr = raw_RemoveFromContainer(Level);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(2145)
inline VGCore::IVGPowerClipPtr VGCore::IVGShape::GetPowerClip ( ) {
    struct IVGPowerClip * _result = 0;
    HRESULT _hr = get_PowerClip(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGPowerClipPtr(_result, false);
}

#pragma implementation_key(2146)
inline VGCore::IVGShapePtr VGCore::IVGShape::GetPowerClipParent ( ) {
    struct IVGShape * _result = 0;
    HRESULT _hr = get_PowerClipParent(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGShapePtr(_result, false);
}

#pragma implementation_key(2147)
inline VARIANT_BOOL VGCore::IVGShape::GetDrapeFill ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_DrapeFill(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2148)
inline void VGCore::IVGShape::PutDrapeFill ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_DrapeFill(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(2149)
inline VARIANT_BOOL VGCore::IVGShape::GetOverprintFill ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_OverprintFill(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2150)
inline void VGCore::IVGShape::PutOverprintFill ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_OverprintFill(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(2151)
inline VARIANT_BOOL VGCore::IVGShape::GetOverprintOutline ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_OverprintOutline(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2152)
inline void VGCore::IVGShape::PutOverprintOutline ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_OverprintOutline(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(2153)
inline VGCore::IVGURLPtr VGCore::IVGShape::GetURL ( ) {
    struct IVGURL * _result = 0;
    HRESULT _hr = get_URL(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGURLPtr(_result, false);
}

#pragma implementation_key(2154)
inline VGCore::IVGDataItemsPtr VGCore::IVGShape::GetObjectData ( ) {
    struct IVGDataItems * _result = 0;
    HRESULT _hr = get_ObjectData(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGDataItemsPtr(_result, false);
}

#pragma implementation_key(2155)
inline VGCore::IVGCloneLinkPtr VGCore::IVGShape::GetCloneLink ( ) {
    struct IVGCloneLink * _result = 0;
    HRESULT _hr = get_CloneLink(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGCloneLinkPtr(_result, false);
}

#pragma implementation_key(2156)
inline VGCore::IVGShapeRangePtr VGCore::IVGShape::GetClones ( ) {
    struct IVGShapeRange * _result = 0;
    HRESULT _hr = get_Clones(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGShapeRangePtr(_result, false);
}

#pragma implementation_key(2157)
inline double VGCore::IVGShape::GetAbsoluteHScale ( ) {
    double _result = 0;
    HRESULT _hr = get_AbsoluteHScale(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2158)
inline double VGCore::IVGShape::GetAbsoluteVScale ( ) {
    double _result = 0;
    HRESULT _hr = get_AbsoluteVScale(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2159)
inline double VGCore::IVGShape::GetAbsoluteSkew ( ) {
    double _result = 0;
    HRESULT _hr = get_AbsoluteSkew(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2160)
inline VGCore::IVGTransparencyPtr VGCore::IVGShape::GetTransparency ( ) {
    struct IVGTransparency * _result = 0;
    HRESULT _hr = get_Transparency(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGTransparencyPtr(_result, false);
}

#pragma implementation_key(2161)
inline HRESULT VGCore::IVGShape::GetMatrix ( double * d11, double * d12, double * d21, double * d22, double * tx, double * ty ) {
    HRESULT _hr = raw_GetMatrix(d11, d12, d21, d22, tx, ty);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(2162)
inline HRESULT VGCore::IVGShape::SetMatrix ( double d11, double d12, double d21, double d22, double tx, double ty ) {
    HRESULT _hr = raw_SetMatrix(d11, d12, d21, d22, tx, ty);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(2163)
inline VGCore::IVGShapePtr VGCore::IVGShape::ConvertToBitmapEx ( enum cdrImageType Mode, VARIANT_BOOL Dithered, VARIANT_BOOL Transparent, long Resolution, enum cdrAntiAliasingType AntiAliasing, VARIANT_BOOL UseColorProfile, VARIANT_BOOL AlwaysOverprintBlack, long OverprintBlackLimit ) {
    struct IVGShape * _result = 0;
    HRESULT _hr = raw_ConvertToBitmapEx(Mode, Dithered, Transparent, Resolution, AntiAliasing, UseColorProfile, AlwaysOverprintBlack, OverprintBlackLimit, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGShapePtr(_result, false);
}

#pragma implementation_key(2164)
inline HRESULT VGCore::IVGShape::SkewEx ( double AngleX, double AngleY, double CenterX, double CenterY ) {
    HRESULT _hr = raw_SkewEx(AngleX, AngleY, CenterX, CenterY);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(2165)
inline HRESULT VGCore::IVGShape::RotateEx ( double Angle, double CenterX, double CenterY ) {
    HRESULT _hr = raw_RotateEx(Angle, CenterX, CenterY);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(2166)
inline VGCore::IVGShapePtr VGCore::IVGShape::GetParentGroup ( ) {
    struct IVGShape * _result = 0;
    HRESULT _hr = get_ParentGroup(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGShapePtr(_result, false);
}

#pragma implementation_key(2167)
inline HRESULT VGCore::IVGShape::SetBoundingBox ( double x, double y, double Width, double Height, VARIANT_BOOL KeepAspect, enum cdrReferencePoint ReferencePoint ) {
    HRESULT _hr = raw_SetBoundingBox(x, y, Width, Height, KeepAspect, ReferencePoint);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(2168)
inline HRESULT VGCore::IVGShape::CreateSelection ( ) {
    HRESULT _hr = raw_CreateSelection();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(2169)
inline HRESULT VGCore::IVGShape::SetRotationCenter ( double x, double y ) {
    HRESULT _hr = raw_SetRotationCenter(x, y);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(2170)
inline HRESULT VGCore::IVGShape::ClearEffect ( enum cdrEffectType Type ) {
    HRESULT _hr = raw_ClearEffect(Type);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(2171)
inline VGCore::IVGShapePtr VGCore::IVGShape::GetNext ( enum cdrShapeLevel Level, VARIANT_BOOL EnterGroups, VARIANT_BOOL Loop ) {
    struct IVGShape * _result = 0;
    HRESULT _hr = get_Next(Level, EnterGroups, Loop, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGShapePtr(_result, false);
}

#pragma implementation_key(2172)
inline VGCore::IVGShapePtr VGCore::IVGShape::GetPrevious ( enum cdrShapeLevel Level, VARIANT_BOOL EnterGroups, VARIANT_BOOL Loop ) {
    struct IVGShape * _result = 0;
    HRESULT _hr = get_Previous(Level, EnterGroups, Loop, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGShapePtr(_result, false);
}

#pragma implementation_key(2173)
inline HRESULT VGCore::IVGShape::StretchEx ( double CenterX, double CenterY, double StretchX, double StretchY, VARIANT_BOOL StretchCharactersSize ) {
    HRESULT _hr = raw_StretchEx(CenterX, CenterY, StretchX, StretchY, StretchCharactersSize);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(2174)
inline HRESULT VGCore::IVGShape::SetSizeEx ( double CenterX, double CenterY, double Width, double Height ) {
    HRESULT _hr = raw_SetSizeEx(CenterX, CenterY, Width, Height);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(2175)
inline HRESULT VGCore::IVGShape::GetBoundingBox ( double * x, double * y, double * Width, double * Height, VARIANT_BOOL UseOutline ) {
    HRESULT _hr = raw_GetBoundingBox(x, y, Width, Height, UseOutline);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(2176)
inline VGCore::IVGShapeRangePtr VGCore::IVGShape::UngroupEx ( ) {
    struct IVGShapeRange * _result = 0;
    HRESULT _hr = raw_UngroupEx(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGShapeRangePtr(_result, false);
}

#pragma implementation_key(2177)
inline VGCore::IVGShapeRangePtr VGCore::IVGShape::UngroupAllEx ( ) {
    struct IVGShapeRange * _result = 0;
    HRESULT _hr = raw_UngroupAllEx(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGShapeRangePtr(_result, false);
}

#pragma implementation_key(2178)
inline VGCore::IVGShapeRangePtr VGCore::IVGShape::BreakApartEx ( ) {
    struct IVGShapeRange * _result = 0;
    HRESULT _hr = raw_BreakApartEx(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGShapeRangePtr(_result, false);
}

#pragma implementation_key(2179)
inline HRESULT VGCore::IVGShape::ApplyStyle ( _bstr_t StyleName ) {
    HRESULT _hr = raw_ApplyStyle(StyleName);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(2180)
inline enum VGCore::cdrWrapStyle VGCore::IVGShape::GetWrapText ( ) {
    enum cdrWrapStyle _result;
    HRESULT _hr = get_WrapText(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2181)
inline void VGCore::IVGShape::PutWrapText ( enum cdrWrapStyle pVal ) {
    HRESULT _hr = put_WrapText(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(2182)
inline double VGCore::IVGShape::GetTextWrapOffset ( ) {
    double _result = 0;
    HRESULT _hr = get_TextWrapOffset(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2183)
inline void VGCore::IVGShape::PutTextWrapOffset ( double pVal ) {
    HRESULT _hr = put_TextWrapOffset(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(2184)
inline VGCore::IVGShapePtr VGCore::IVGShape::PlaceTextInside ( struct IVGShape * TextShape ) {
    struct IVGShape * _result = 0;
    HRESULT _hr = raw_PlaceTextInside(TextShape, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGShapePtr(_result, false);
}

#pragma implementation_key(2185)
inline VGCore::IVGCurvePtr VGCore::IVGShape::GetDisplayCurve ( ) {
    struct IVGCurve * _result = 0;
    HRESULT _hr = get_DisplayCurve(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGCurvePtr(_result, false);
}

#pragma implementation_key(2186)
inline _variant_t VGCore::IVGShape::CustomCommand ( _bstr_t ComponentID, _bstr_t CommandID, SAFEARRAY * * Parameters ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = raw_CustomCommand(ComponentID, CommandID, Parameters, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

#pragma implementation_key(2187)
inline VGCore::IVGCustomShapePtr VGCore::IVGShape::GetCustom ( ) {
    struct IVGCustomShape * _result = 0;
    HRESULT _hr = get_Custom(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGCustomShapePtr(_result, false);
}

#pragma implementation_key(2188)
inline VGCore::IVGEffectPtr VGCore::IVGShape::CreateCustomEffect ( _bstr_t EffectID, SAFEARRAY * * Parameters ) {
    struct IVGEffect * _result = 0;
    HRESULT _hr = raw_CreateCustomEffect(EffectID, Parameters, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGEffectPtr(_result, false);
}

#pragma implementation_key(2189)
inline VGCore::IVGEffectPtr VGCore::IVGShape::CreateCustomDistortion ( _bstr_t DistortionID, SAFEARRAY * * Parameters ) {
    struct IVGEffect * _result = 0;
    HRESULT _hr = raw_CreateCustomDistortion(DistortionID, Parameters, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGEffectPtr(_result, false);
}

#pragma implementation_key(2190)
inline HRESULT VGCore::IVGShape::AlignToShape ( enum cdrAlignType Type, struct IVGShape * Shape, enum cdrTextAlignOrigin TextAlignOrigin ) {
    HRESULT _hr = raw_AlignToShape(Type, Shape, TextAlignOrigin);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(2191)
inline HRESULT VGCore::IVGShape::AlignToShapeRange ( enum cdrAlignType Type, struct IVGShapeRange * ShapeRange, enum cdrTextAlignOrigin TextAlignOrigin ) {
    HRESULT _hr = raw_AlignToShapeRange(Type, ShapeRange, TextAlignOrigin);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(2192)
inline HRESULT VGCore::IVGShape::AlignToPage ( enum cdrAlignType Type, enum cdrTextAlignOrigin TextAlignOrigin ) {
    HRESULT _hr = raw_AlignToPage(Type, TextAlignOrigin);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(2193)
inline HRESULT VGCore::IVGShape::AlignToPageCenter ( enum cdrAlignType Type, enum cdrTextAlignOrigin TextAlignOrigin ) {
    HRESULT _hr = raw_AlignToPageCenter(Type, TextAlignOrigin);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(2194)
inline HRESULT VGCore::IVGShape::AlignToGrid ( enum cdrAlignType Type, enum cdrTextAlignOrigin TextAlignOrigin ) {
    HRESULT _hr = raw_AlignToGrid(Type, TextAlignOrigin);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(2195)
inline HRESULT VGCore::IVGShape::AlignToPoint ( enum cdrAlignType Type, double x, double y, enum cdrTextAlignOrigin TextAlignOrigin ) {
    HRESULT _hr = raw_AlignToPoint(Type, x, y, TextAlignOrigin);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(2196)
inline VGCore::IVGDimensionPtr VGCore::IVGShape::GetDimension ( ) {
    struct IVGDimension * _result = 0;
    HRESULT _hr = get_Dimension(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGDimensionPtr(_result, false);
}

#pragma implementation_key(2197)
inline VGCore::IVGSymbolPtr VGCore::IVGShape::GetSymbol ( ) {
    struct IVGSymbol * _result = 0;
    HRESULT _hr = get_Symbol(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGSymbolPtr(_result, false);
}

#pragma implementation_key(2198)
inline VGCore::IVGShapePtr VGCore::IVGShape::ConvertToSymbol ( _bstr_t Name ) {
    struct IVGShape * _result = 0;
    HRESULT _hr = raw_ConvertToSymbol(Name, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGShapePtr(_result, false);
}

#pragma implementation_key(2199)
inline VGCore::IVGOLEPtr VGCore::IVGShape::GetOLE ( ) {
    struct IVGOLE * _result = 0;
    HRESULT _hr = get_OLE(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGOLEPtr(_result, false);
}

#pragma implementation_key(2200)
inline VGCore::IVGShapeRangePtr VGCore::IVGShape::DuplicateAsRange ( double OffsetX, double OffsetY ) {
    struct IVGShapeRange * _result = 0;
    HRESULT _hr = raw_DuplicateAsRange(OffsetX, OffsetY, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGShapeRangePtr(_result, false);
}

#pragma implementation_key(2201)
inline VGCore::IVGShapeRangePtr VGCore::IVGShape::CloneAsRange ( double OffsetX, double OffsetY ) {
    struct IVGShapeRange * _result = 0;
    HRESULT _hr = raw_CloneAsRange(OffsetX, OffsetY, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGShapeRangePtr(_result, false);
}

#pragma implementation_key(2202)
inline HRESULT VGCore::IVGShape::MoveToLayer ( struct IVGLayer * Layer ) {
    HRESULT _hr = raw_MoveToLayer(Layer);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(2203)
inline VGCore::IVGShapePtr VGCore::IVGShape::CopyToLayer ( struct IVGLayer * Layer ) {
    struct IVGShape * _result = 0;
    HRESULT _hr = raw_CopyToLayer(Layer, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGShapePtr(_result, false);
}

#pragma implementation_key(2204)
inline VGCore::IVGShapeRangePtr VGCore::IVGShape::CopyToLayerAsRange ( struct IVGLayer * Layer ) {
    struct IVGShapeRange * _result = 0;
    HRESULT _hr = raw_CopyToLayerAsRange(Layer, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGShapeRangePtr(_result, false);
}

#pragma implementation_key(2205)
inline HRESULT VGCore::IVGShape::ClearTransformations ( ) {
    HRESULT _hr = raw_ClearTransformations();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(2206)
inline HRESULT VGCore::IVGShape::Distribute ( enum cdrDistributeType Type, VARIANT_BOOL PageExtent ) {
    HRESULT _hr = raw_Distribute(Type, PageExtent);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(2207)
inline VARIANT_BOOL VGCore::IVGShape::CompareTo ( struct IVGShape * Shape, enum cdrCompareType CompareType, enum cdrCompareCondition Condition ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_CompareTo(Shape, CompareType, Condition, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2208)
inline VARIANT_BOOL VGCore::IVGShape::GetSelectable ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_Selectable(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2209)
inline HRESULT VGCore::IVGShape::ApplyEffectInvert ( ) {
    HRESULT _hr = raw_ApplyEffectInvert();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(2210)
inline HRESULT VGCore::IVGShape::ApplyEffectPosterize ( long Level ) {
    HRESULT _hr = raw_ApplyEffectPosterize(Level);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(2211)
inline HRESULT VGCore::IVGShape::ApplyEffectBCI ( long Brighness, long Contrast, long Intensity ) {
    HRESULT _hr = raw_ApplyEffectBCI(Brighness, Contrast, Intensity);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(2212)
inline HRESULT VGCore::IVGShape::ApplyEffectColorBalance ( long CyanRed, long MagentaGreen, long YellowBlue, VARIANT_BOOL ApplyToShadows, VARIANT_BOOL ApplyToMidtones, VARIANT_BOOL ApplyToHighlights, VARIANT_BOOL PreserveLuminance ) {
    HRESULT _hr = raw_ApplyEffectColorBalance(CyanRed, MagentaGreen, YellowBlue, ApplyToShadows, ApplyToMidtones, ApplyToHighlights, PreserveLuminance);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(2213)
inline HRESULT VGCore::IVGShape::ApplyEffectGamma ( double Gamma ) {
    HRESULT _hr = raw_ApplyEffectGamma(Gamma);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(2214)
inline HRESULT VGCore::IVGShape::ApplyEffectHSL ( const _variant_t & Hue, const _variant_t & Saturation, const _variant_t & Lightness ) {
    HRESULT _hr = raw_ApplyEffectHSL(Hue, Saturation, Lightness);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(2215)
inline HRESULT VGCore::IVGShape::TransformMatrix ( double d11, double d12, double d21, double d22, double tx, double ty ) {
    HRESULT _hr = raw_TransformMatrix(d11, d12, d21, d22, tx, ty);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(2216)
inline HRESULT VGCore::IVGShape::AffineTransform ( double d11, double d12, double d21, double d22, double CenterX, double CenterY ) {
    HRESULT _hr = raw_AffineTransform(d11, d12, d21, d22, CenterX, CenterY);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(2217)
inline VGCore::IVGTreeNodePtr VGCore::IVGShape::GetTreeNode ( ) {
    struct IVGTreeNode * _result = 0;
    HRESULT _hr = get_TreeNode(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGTreeNodePtr(_result, false);
}

#pragma implementation_key(2218)
inline HRESULT VGCore::IVGShape::ReplaceWith ( struct IVGShape * VirtualShape ) {
    HRESULT _hr = raw_ReplaceWith(VirtualShape);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(2219)
inline VARIANT_BOOL VGCore::IVGShape::GetVirtual ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_Virtual(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2220)
inline VARIANT_BOOL VGCore::IVGShape::GetCanHaveFill ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_CanHaveFill(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2221)
inline VARIANT_BOOL VGCore::IVGShape::GetCanHaveOutline ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_CanHaveOutline(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2222)
inline VARIANT_BOOL VGCore::IVGShape::GetIsSimpleShape ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsSimpleShape(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2223)
inline HRESULT VGCore::IVGShape::Fillet ( double Radius, VARIANT_BOOL CombineSmoothSegments ) {
    HRESULT _hr = raw_Fillet(Radius, CombineSmoothSegments);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(2224)
inline HRESULT VGCore::IVGShape::Chamfer ( double DistanceA, double DistanceB, VARIANT_BOOL CombineSmoothSegments ) {
    HRESULT _hr = raw_Chamfer(DistanceA, DistanceB, CombineSmoothSegments);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(2225)
inline HRESULT VGCore::IVGShape::Scallop ( double Radius, VARIANT_BOOL CombineSmoothSegments ) {
    HRESULT _hr = raw_Scallop(Radius, CombineSmoothSegments);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(2226)
inline enum VGCore::cdrFillMode VGCore::IVGShape::GetFillMode ( ) {
    enum cdrFillMode _result;
    HRESULT _hr = get_FillMode(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2227)
inline void VGCore::IVGShape::PutFillMode ( enum cdrFillMode pVal ) {
    HRESULT _hr = put_FillMode(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(2228)
inline double VGCore::IVGShape::GetLeftX ( ) {
    double _result = 0;
    HRESULT _hr = get_LeftX(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2229)
inline double VGCore::IVGShape::GetRightX ( ) {
    double _result = 0;
    HRESULT _hr = get_RightX(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2230)
inline double VGCore::IVGShape::GetTopY ( ) {
    double _result = 0;
    HRESULT _hr = get_TopY(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2231)
inline double VGCore::IVGShape::GetBottomY ( ) {
    double _result = 0;
    HRESULT _hr = get_BottomY(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2232)
inline VGCore::IVGShapeRangePtr VGCore::IVGShape::StepAndRepeat ( long NumCopies, double DistanceX, double DistanceY, enum cdrDistanceMode ModeX, enum cdrDirection DirectionX, enum cdrDistanceMode ModeY, enum cdrDirection DirectionY ) {
    struct IVGShapeRange * _result = 0;
    HRESULT _hr = raw_StepAndRepeat(NumCopies, DistanceX, DistanceY, ModeX, DirectionX, ModeY, DirectionY, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGShapeRangePtr(_result, false);
}

#pragma implementation_key(2233)
inline VARIANT_BOOL VGCore::IVGShape::GetOverprintBitmap ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_OverprintBitmap(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2234)
inline void VGCore::IVGShape::PutOverprintBitmap ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_OverprintBitmap(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(2235)
inline VARIANT_BOOL VGCore::IVGShape::IsTypeAnyOf ( SAFEARRAY * * TypeList ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_IsTypeAnyOf(TypeList, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2236)
inline VGCore::IVGShapeRangePtr VGCore::IVGShape::GetLinkedShapes ( enum cdrShapeLinkType LinkType ) {
    struct IVGShapeRange * _result = 0;
    HRESULT _hr = raw_GetLinkedShapes(LinkType, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGShapeRangePtr(_result, false);
}

#pragma implementation_key(2237)
inline VGCore::IVGEffectPtr VGCore::IVGShape::CreateEnvelopeFromShape ( struct IVGShape * Source, enum cdrEnvelopeMode Mode, VARIANT_BOOL KeepLines, enum cdrEnvelopeCopyMode CopyMode, const _variant_t & CornerIndices ) {
    struct IVGEffect * _result = 0;
    HRESULT _hr = raw_CreateEnvelopeFromShape(Source, Mode, KeepLines, CopyMode, CornerIndices, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGEffectPtr(_result, false);
}

#pragma implementation_key(2238)
inline VGCore::IVGEffectPtr VGCore::IVGShape::CreateEnvelopeFromCurve ( struct IVGCurve * Source, enum cdrEnvelopeMode Mode, VARIANT_BOOL KeepLines, enum cdrEnvelopeCopyMode CopyMode, const _variant_t & CornerIndices ) {
    struct IVGEffect * _result = 0;
    HRESULT _hr = raw_CreateEnvelopeFromCurve(Source, Mode, KeepLines, CopyMode, CornerIndices, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGEffectPtr(_result, false);
}

#pragma implementation_key(2239)
inline VGCore::IVGEPSPtr VGCore::IVGShape::GetEPS ( ) {
    struct IVGEPS * _result = 0;
    HRESULT _hr = get_EPS(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGEPSPtr(_result, false);
}

#pragma implementation_key(2240)
inline _variant_t VGCore::IVGShape::Evaluate ( _bstr_t Expression ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = raw_Evaluate(Expression, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

#pragma implementation_key(2241)
inline VGCore::IVGRectPtr VGCore::IVGShape::GetBoundingBox ( ) {
    struct IVGRect * _result = 0;
    HRESULT _hr = get_BoundingBox(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGRectPtr(_result, false);
}

#pragma implementation_key(2242)
inline HRESULT VGCore::IVGShape::GetPositionEx ( enum cdrReferencePoint ReferencePoint, double * x, double * y ) {
    HRESULT _hr = raw_GetPositionEx(ReferencePoint, x, y);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(2243)
inline HRESULT VGCore::IVGShape::SetPositionEx ( enum cdrReferencePoint ReferencePoint, double x, double y ) {
    HRESULT _hr = raw_SetPositionEx(ReferencePoint, x, y);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(2244)
inline double VGCore::IVGShape::GetCenterX ( ) {
    double _result = 0;
    HRESULT _hr = get_CenterX(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2245)
inline void VGCore::IVGShape::PutCenterX ( double pVal ) {
    HRESULT _hr = put_CenterX(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(2246)
inline double VGCore::IVGShape::GetCenterY ( ) {
    double _result = 0;
    HRESULT _hr = get_CenterY(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2247)
inline void VGCore::IVGShape::PutCenterY ( double pVal ) {
    HRESULT _hr = put_CenterY(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(2248)
inline void VGCore::IVGShape::PutLeftX ( double pVal ) {
    HRESULT _hr = put_LeftX(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(2249)
inline void VGCore::IVGShape::PutRightX ( double pVal ) {
    HRESULT _hr = put_RightX(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(2250)
inline void VGCore::IVGShape::PutTopY ( double pVal ) {
    HRESULT _hr = put_TopY(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(2251)
inline void VGCore::IVGShape::PutBottomY ( double pVal ) {
    HRESULT _hr = put_BottomY(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(2252)
inline long VGCore::IVGShape::GetZOrder ( ) {
    long _result = 0;
    HRESULT _hr = get_ZOrder(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2253)
inline VARIANT_BOOL VGCore::IVGShape::CompareToEx ( struct IVGShape * Shape2, _bstr_t Condition, const _variant_t & Data ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_CompareToEx(Shape2, Condition, Data, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2254)
inline VARIANT_BOOL VGCore::IVGShape::CopyPropertiesFrom ( struct IVGShape * Source, enum cdrCopyProperties Properties ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_CopyPropertiesFrom(Source, Properties, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2255)
inline enum VGCore::cdrOverprintState VGCore::IVGShape::GetOverprintFillState ( ) {
    enum cdrOverprintState _result;
    HRESULT _hr = raw_GetOverprintFillState(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2256)
inline enum VGCore::cdrOverprintState VGCore::IVGShape::GetOverprintOutlineState ( ) {
    enum cdrOverprintState _result;
    HRESULT _hr = raw_GetOverprintOutlineState(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2257)
inline VGCore::IVGPagePtr VGCore::IVGShape::GetPage ( ) {
    struct IVGPage * _result = 0;
    HRESULT _hr = get_Page(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGPagePtr(_result, false);
}

#pragma implementation_key(2258)
inline VGCore::IVGSnapPointsPtr VGCore::IVGShape::SnapPointsOfType ( enum cdrPointType TypeSet ) {
    struct IVGSnapPoints * _result = 0;
    HRESULT _hr = raw_SnapPointsOfType(TypeSet, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGSnapPointsPtr(_result, false);
}

#pragma implementation_key(2259)
inline VGCore::IVGSnapPointPtr VGCore::IVGShape::FindSnapPoint ( _bstr_t ReferenceData ) {
    struct IVGSnapPoint * _result = 0;
    HRESULT _hr = raw_FindSnapPoint(ReferenceData, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGSnapPointPtr(_result, false);
}

#pragma implementation_key(2260)
inline VGCore::IVGSpreadPtr VGCore::IVGShape::GetSpread ( ) {
    struct IVGSpread * _result = 0;
    HRESULT _hr = get_Spread(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGSpreadPtr(_result, false);
}

#pragma implementation_key(2261)
inline VARIANT_BOOL VGCore::IVGShape::GetPixelAlignedRendering ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_PixelAlignedRendering(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2262)
inline void VGCore::IVGShape::PutPixelAlignedRendering ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_PixelAlignedRendering(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(2263)
inline VGCore::IVGBSplinePtr VGCore::IVGShape::GetBSpline ( ) {
    struct IVGBSpline * _result = 0;
    HRESULT _hr = get_BSpline(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGBSplinePtr(_result, false);
}

#pragma implementation_key(2264)
inline VGCore::IVGDocumentPtr VGCore::IVGShape::CreateDocumentFrom ( VARIANT_BOOL TemporaryDocument ) {
    struct IVGDocument * _result = 0;
    HRESULT _hr = raw_CreateDocumentFrom(TemporaryDocument, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGDocumentPtr(_result, false);
}

#pragma implementation_key(2265)
inline HRESULT VGCore::IVGShape::AlignAndDistribute ( enum cdrAlignDistributeH MethodH, enum cdrAlignDistributeV MethodV, enum cdrAlignShapesTo AlignTo, enum cdrDistributeArea DistributeArea, VARIANT_BOOL UseOutline, enum cdrTextAlignOrigin TextAlignOrigin, double PointX, double PointY, struct IVGRect * DistributeRect ) {
    HRESULT _hr = raw_AlignAndDistribute(MethodH, MethodV, AlignTo, DistributeArea, UseOutline, TextAlignOrigin, PointX, PointY, DistributeRect);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(2266)
inline VGCore::IVGStylePtr VGCore::IVGShape::GetStyle ( ) {
    struct IVGStyle * _result = 0;
    HRESULT _hr = get_Style(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGStylePtr(_result, false);
}

#pragma implementation_key(2267)
inline VGCore::IVGShapePtr VGCore::IVGShape::CreateBoundary ( double x, double y, VARIANT_BOOL PlaceOnTop, VARIANT_BOOL DeleteSource ) {
    struct IVGShape * _result = 0;
    HRESULT _hr = raw_CreateBoundary(x, y, PlaceOnTop, DeleteSource, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGShapePtr(_result, false);
}

#pragma implementation_key(2268)
inline VGCore::IVGShapeRangePtr VGCore::IVGShape::EqualDivide ( long Divisions, double Gap, VARIANT_BOOL Group, VARIANT_BOOL Combine, VARIANT_BOOL DeleteSource ) {
    struct IVGShapeRange * _result = 0;
    HRESULT _hr = raw_EqualDivide(Divisions, Gap, Group, Combine, DeleteSource, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGShapeRangePtr(_result, false);
}

#pragma implementation_key(2269)
inline VGCore::IVGShapePtr VGCore::IVGShape::Project ( enum cdrProjectPlane Plane, enum cdrReferencePoint ReferencePoint, VARIANT_BOOL ApplyToDuplicate ) {
    struct IVGShape * _result = 0;
    HRESULT _hr = raw_Project(Plane, ReferencePoint, ApplyToDuplicate, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGShapePtr(_result, false);
}

#pragma implementation_key(2270)
inline VGCore::IVGShapePtr VGCore::IVGShape::Unproject ( enum cdrProjectPlane Plane, enum cdrReferencePoint ReferencePoint, VARIANT_BOOL ApplyToDuplicate ) {
    struct IVGShape * _result = 0;
    HRESULT _hr = raw_Unproject(Plane, ReferencePoint, ApplyToDuplicate, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGShapePtr(_result, false);
}

#pragma implementation_key(2271)
inline VGCore::IVGTransformMatrixPtr VGCore::IVGShape::GetTransformationMatrix ( ) {
    struct IVGTransformMatrix * _result = 0;
    HRESULT _hr = get_TransformationMatrix(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGTransformMatrixPtr(_result, false);
}

#pragma implementation_key(2272)
inline void VGCore::IVGShape::PutTransformationMatrix ( struct IVGTransformMatrix * TransformMatrix ) {
    HRESULT _hr = put_TransformationMatrix(TransformMatrix);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(2273)
inline HRESULT VGCore::IVGShape::ApplyTransformMatrix ( struct IVGTransformMatrix * TransformMatrix ) {
    HRESULT _hr = raw_ApplyTransformMatrix(TransformMatrix);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(2274)
inline VARIANT_BOOL VGCore::IVGShape::GetVisible ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_Visible(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2275)
inline void VGCore::IVGShape::PutVisible ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_Visible(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(2276)
inline HRESULT VGCore::IVGShape::ModifyToolShapeProperties ( struct IVGProperties * ShapePropertiesToModify ) {
    HRESULT _hr = raw_ModifyToolShapeProperties(ShapePropertiesToModify);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(2277)
inline _bstr_t VGCore::IVGShape::GetToolShapeGuid ( ) {
    BSTR _result = 0;
    HRESULT _hr = raw_GetToolShapeGuid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(2278)
inline VGCore::IVGShapeRangePtr VGCore::IVGShape::CreateParallelCurves ( long Count, double distanceBetweenCurves ) {
    struct IVGShapeRange * _result = 0;
    HRESULT _hr = raw_CreateParallelCurves(Count, distanceBetweenCurves, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGShapeRangePtr(_result, false);
}

#pragma implementation_key(2279)
inline VGCore::IVGShapePtr VGCore::IVGShape::FindShapeAtPoint ( double x, double y, VARIANT_BOOL TreatAsFilled ) {
    struct IVGShape * _result = 0;
    HRESULT _hr = raw_FindShapeAtPoint(x, y, TreatAsFilled, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGShapePtr(_result, false);
}

#pragma implementation_key(2280)
inline SAFEARRAY * VGCore::IVGShape::GetColorTypes ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_GetColorTypes(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2281)
inline SAFEARRAY * VGCore::IVGShape::GetColors ( long MaxBitmapColors ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_GetColors(MaxBitmapColors, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2282)
inline HRESULT VGCore::IVGShape::FlattenEffects ( ) {
    HRESULT _hr = raw_FlattenEffects();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(2283)
inline VGCore::IVGEffectPtr VGCore::IVGShape::CreateInnerShadow ( long Opacity, long Feather, double OffsetX, double OffsetY, struct IVGColor * Color, enum cdrFeatherType FeatherType, enum cdrEdgeType FeatherEdge, enum cdrMergeMode MergeMode, double Depth ) {
    struct IVGEffect * _result = 0;
    HRESULT _hr = raw_CreateInnerShadow(Opacity, Feather, OffsetX, OffsetY, Color, FeatherType, FeatherEdge, MergeMode, Depth, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGEffectPtr(_result, false);
}

//
// interface IVGCustomEffect wrapper method implementations
//

#pragma implementation_key(2284)
inline _bstr_t VGCore::IVGCustomEffect::GetEffectID ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_EffectID(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(2285)
inline VGCore::IVGShapePtr VGCore::IVGCustomEffect::GetEffectGroup ( ) {
    struct IVGShape * _result = 0;
    HRESULT _hr = get_EffectGroup(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGShapePtr(_result, false);
}

//
// interface IVGCloneLink wrapper method implementations
//

#pragma implementation_key(2286)
inline VGCore::IVGApplicationPtr VGCore::IVGCloneLink::GetApplication ( ) {
    struct IVGApplication * _result = 0;
    HRESULT _hr = get_Application(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGApplicationPtr(_result, false);
}

#pragma implementation_key(2287)
inline VGCore::IVGShapePtr VGCore::IVGCloneLink::GetParent ( ) {
    struct IVGShape * _result = 0;
    HRESULT _hr = get_Parent(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGShapePtr(_result, false);
}

#pragma implementation_key(2288)
inline VGCore::IVGShapePtr VGCore::IVGCloneLink::GetCloneParent ( ) {
    struct IVGShape * _result = 0;
    HRESULT _hr = get_CloneParent(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGShapePtr(_result, false);
}

#pragma implementation_key(2289)
inline VARIANT_BOOL VGCore::IVGCloneLink::GetFillLinked ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_FillLinked(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2290)
inline void VGCore::IVGCloneLink::PutFillLinked ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_FillLinked(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(2291)
inline VARIANT_BOOL VGCore::IVGCloneLink::GetOutlineLinked ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_OutlineLinked(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2292)
inline void VGCore::IVGCloneLink::PutOutlineLinked ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_OutlineLinked(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(2293)
inline VARIANT_BOOL VGCore::IVGCloneLink::GetShapeLinked ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_ShapeLinked(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2294)
inline void VGCore::IVGCloneLink::PutShapeLinked ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_ShapeLinked(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(2295)
inline VARIANT_BOOL VGCore::IVGCloneLink::GetTransformLinked ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_TransformLinked(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2296)
inline void VGCore::IVGCloneLink::PutTransformLinked ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_TransformLinked(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(2297)
inline VARIANT_BOOL VGCore::IVGCloneLink::GetBitmapColorMaskLinked ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_BitmapColorMaskLinked(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2298)
inline void VGCore::IVGCloneLink::PutBitmapColorMaskLinked ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_BitmapColorMaskLinked(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(2299)
inline HRESULT VGCore::IVGCloneLink::RestoreAllLinks ( ) {
    HRESULT _hr = raw_RestoreAllLinks();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface IVGCommentTarget wrapper method implementations
//

#pragma implementation_key(2300)
inline VGCore::IVGShapePtr VGCore::IVGCommentTarget::GetShape ( ) {
    struct IVGShape * _result = 0;
    HRESULT _hr = get_Shape(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGShapePtr(_result, false);
}

#pragma implementation_key(2301)
inline void VGCore::IVGCommentTarget::PutRefShape ( struct IVGShape * * pRet ) {
    HRESULT _hr = putref_Shape(pRet);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(2302)
inline _bstr_t VGCore::IVGCommentTarget::GetGuid ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Guid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(2303)
inline void VGCore::IVGCommentTarget::PutGuid ( _bstr_t pRet ) {
    HRESULT _hr = put_Guid(pRet);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IVGSelectionInformation wrapper method implementations
//

#pragma implementation_key(2304)
inline VGCore::IVGApplicationPtr VGCore::IVGSelectionInformation::GetApplication ( ) {
    struct IVGApplication * _result = 0;
    HRESULT _hr = get_Application(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGApplicationPtr(_result, false);
}

#pragma implementation_key(2305)
inline VGCore::IVGDocumentPtr VGCore::IVGSelectionInformation::GetParent ( ) {
    struct IVGDocument * _result = 0;
    HRESULT _hr = get_Parent(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGDocumentPtr(_result, false);
}

#pragma implementation_key(2306)
inline long VGCore::IVGSelectionInformation::GetCount ( ) {
    long _result = 0;
    HRESULT _hr = get_Count(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2307)
inline VGCore::IVGShapePtr VGCore::IVGSelectionInformation::GetFirstShape ( ) {
    struct IVGShape * _result = 0;
    HRESULT _hr = get_FirstShape(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGShapePtr(_result, false);
}

#pragma implementation_key(2308)
inline VGCore::IVGShapePtr VGCore::IVGSelectionInformation::GetSecondShape ( ) {
    struct IVGShape * _result = 0;
    HRESULT _hr = get_SecondShape(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGShapePtr(_result, false);
}

#pragma implementation_key(2309)
inline VGCore::IVGShapePtr VGCore::IVGSelectionInformation::GetBlendTopShape ( ) {
    struct IVGShape * _result = 0;
    HRESULT _hr = get_BlendTopShape(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGShapePtr(_result, false);
}

#pragma implementation_key(2310)
inline VGCore::IVGShapePtr VGCore::IVGSelectionInformation::GetBlendBottomShape ( ) {
    struct IVGShape * _result = 0;
    HRESULT _hr = get_BlendBottomShape(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGShapePtr(_result, false);
}

#pragma implementation_key(2311)
inline VGCore::IVGShapePtr VGCore::IVGSelectionInformation::GetBlendPath ( ) {
    struct IVGShape * _result = 0;
    HRESULT _hr = get_BlendPath(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGShapePtr(_result, false);
}

#pragma implementation_key(2312)
inline VARIANT_BOOL VGCore::IVGSelectionInformation::GetCanCreateBlend ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_CanCreateBlend(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2313)
inline VGCore::IVGShapePtr VGCore::IVGSelectionInformation::GetDistortionShape ( ) {
    struct IVGShape * _result = 0;
    HRESULT _hr = get_DistortionShape(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGShapePtr(_result, false);
}

#pragma implementation_key(2314)
inline enum VGCore::cdrDistortionType VGCore::IVGSelectionInformation::GetDistortionType ( ) {
    enum cdrDistortionType _result;
    HRESULT _hr = get_DistortionType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2315)
inline VGCore::IVGShapePtr VGCore::IVGSelectionInformation::GetExtrudeFaceShape ( ) {
    struct IVGShape * _result = 0;
    HRESULT _hr = get_ExtrudeFaceShape(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGShapePtr(_result, false);
}

#pragma implementation_key(2316)
inline VGCore::IVGShapePtr VGCore::IVGSelectionInformation::GetExtrudeGroup ( ) {
    struct IVGShape * _result = 0;
    HRESULT _hr = get_ExtrudeGroup(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGShapePtr(_result, false);
}

#pragma implementation_key(2317)
inline VGCore::IVGShapePtr VGCore::IVGSelectionInformation::GetExtrudeBevelGroup ( ) {
    struct IVGShape * _result = 0;
    HRESULT _hr = get_ExtrudeBevelGroup(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGShapePtr(_result, false);
}

#pragma implementation_key(2318)
inline VGCore::IVGShapePtr VGCore::IVGSelectionInformation::GetContourControlShape ( ) {
    struct IVGShape * _result = 0;
    HRESULT _hr = get_ContourControlShape(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGShapePtr(_result, false);
}

#pragma implementation_key(2319)
inline VGCore::IVGShapePtr VGCore::IVGSelectionInformation::GetContourGroup ( ) {
    struct IVGShape * _result = 0;
    HRESULT _hr = get_ContourGroup(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGShapePtr(_result, false);
}

#pragma implementation_key(2320)
inline VGCore::IVGShapePtr VGCore::IVGSelectionInformation::GetDropShadowControlShape ( ) {
    struct IVGShape * _result = 0;
    HRESULT _hr = get_DropShadowControlShape(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGShapePtr(_result, false);
}

#pragma implementation_key(2321)
inline VGCore::IVGShapePtr VGCore::IVGSelectionInformation::GetDropShadowGroup ( ) {
    struct IVGShape * _result = 0;
    HRESULT _hr = get_DropShadowGroup(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGShapePtr(_result, false);
}

#pragma implementation_key(2322)
inline VGCore::IVGShapePtr VGCore::IVGSelectionInformation::GetDimensionControlShape ( ) {
    struct IVGShape * _result = 0;
    HRESULT _hr = get_DimensionControlShape(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGShapePtr(_result, false);
}

#pragma implementation_key(2323)
inline VGCore::IVGShapePtr VGCore::IVGSelectionInformation::GetDimensionGroup ( ) {
    struct IVGShape * _result = 0;
    HRESULT _hr = get_DimensionGroup(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGShapePtr(_result, false);
}

#pragma implementation_key(2324)
inline VGCore::IVGShapePtr VGCore::IVGSelectionInformation::GetConnectorLines ( ) {
    struct IVGShape * _result = 0;
    HRESULT _hr = get_ConnectorLines(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGShapePtr(_result, false);
}

#pragma implementation_key(2325)
inline VGCore::IVGShapePtr VGCore::IVGSelectionInformation::GetFittedTextControlShape ( ) {
    struct IVGShape * _result = 0;
    HRESULT _hr = get_FittedTextControlShape(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGShapePtr(_result, false);
}

#pragma implementation_key(2326)
inline VGCore::IVGShapePtr VGCore::IVGSelectionInformation::GetFittedText ( ) {
    struct IVGShape * _result = 0;
    HRESULT _hr = get_FittedText(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGShapePtr(_result, false);
}

#pragma implementation_key(2327)
inline VGCore::IVGShapePtr VGCore::IVGSelectionInformation::GetFirstShapeWithOutline ( ) {
    struct IVGShape * _result = 0;
    HRESULT _hr = get_FirstShapeWithOutline(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGShapePtr(_result, false);
}

#pragma implementation_key(2328)
inline VGCore::IVGShapePtr VGCore::IVGSelectionInformation::GetFirstShapeWithFill ( ) {
    struct IVGShape * _result = 0;
    HRESULT _hr = get_FirstShapeWithFill(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGShapePtr(_result, false);
}

#pragma implementation_key(2329)
inline VGCore::IVGShapePtr VGCore::IVGSelectionInformation::GetNaturalMediaControlShape ( ) {
    struct IVGShape * _result = 0;
    HRESULT _hr = get_NaturalMediaControlShape(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGShapePtr(_result, false);
}

#pragma implementation_key(2330)
inline VGCore::IVGShapePtr VGCore::IVGSelectionInformation::GetNaturalMediaGroup ( ) {
    struct IVGShape * _result = 0;
    HRESULT _hr = get_NaturalMediaGroup(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGShapePtr(_result, false);
}

#pragma implementation_key(2331)
inline VARIANT_BOOL VGCore::IVGSelectionInformation::GetCanPrint ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_CanPrint(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2332)
inline VARIANT_BOOL VGCore::IVGSelectionInformation::GetIsEditingText ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsEditingText(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2333)
inline VARIANT_BOOL VGCore::IVGSelectionInformation::GetIsTextSelection ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsTextSelection(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2334)
inline VARIANT_BOOL VGCore::IVGSelectionInformation::GetIsOnPowerClipContents ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsOnPowerClipContents(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2335)
inline VARIANT_BOOL VGCore::IVGSelectionInformation::GetIsEditingRollOver ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsEditingRollOver(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2336)
inline VARIANT_BOOL VGCore::IVGSelectionInformation::GetCanApplyFillOutline ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_CanApplyFillOutline(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2337)
inline VARIANT_BOOL VGCore::IVGSelectionInformation::GetIsControlSelected ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsControlSelected(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2338)
inline VARIANT_BOOL VGCore::IVGSelectionInformation::GetCanDeleteControl ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_CanDeleteControl(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2339)
inline VARIANT_BOOL VGCore::IVGSelectionInformation::GetIsGroup ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsGroup(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2340)
inline VARIANT_BOOL VGCore::IVGSelectionInformation::GetIsRegularShape ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsRegularShape(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2341)
inline VARIANT_BOOL VGCore::IVGSelectionInformation::GetIsControlShape ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsControlShape(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2342)
inline VARIANT_BOOL VGCore::IVGSelectionInformation::GetIsBlendControl ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsBlendControl(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2343)
inline VARIANT_BOOL VGCore::IVGSelectionInformation::GetIsBlendGroup ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsBlendGroup(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2344)
inline VARIANT_BOOL VGCore::IVGSelectionInformation::GetIsCloneControl ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsCloneControl(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2345)
inline VARIANT_BOOL VGCore::IVGSelectionInformation::GetIsContourControl ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsContourControl(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2346)
inline VARIANT_BOOL VGCore::IVGSelectionInformation::GetIsContourGroup ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsContourGroup(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2347)
inline VARIANT_BOOL VGCore::IVGSelectionInformation::GetIsDropShadowControl ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsDropShadowControl(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2348)
inline VARIANT_BOOL VGCore::IVGSelectionInformation::GetIsDropShadowGroup ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsDropShadowGroup(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2349)
inline VARIANT_BOOL VGCore::IVGSelectionInformation::GetIsDimensionControl ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsDimensionControl(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2350)
inline VARIANT_BOOL VGCore::IVGSelectionInformation::GetIsExtrudeControl ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsExtrudeControl(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2351)
inline VARIANT_BOOL VGCore::IVGSelectionInformation::GetIsExtrudeGroup ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsExtrudeGroup(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2352)
inline VARIANT_BOOL VGCore::IVGSelectionInformation::GetIsBevelGroup ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsBevelGroup(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2353)
inline VARIANT_BOOL VGCore::IVGSelectionInformation::GetHasAutoLabelText ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_HasAutoLabelText(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2354)
inline VARIANT_BOOL VGCore::IVGSelectionInformation::GetIsEnvelope ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsEnvelope(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2355)
inline VARIANT_BOOL VGCore::IVGSelectionInformation::GetIsPerspective ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsPerspective(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2356)
inline VARIANT_BOOL VGCore::IVGSelectionInformation::GetIsDistortion ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsDistortion(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2357)
inline VARIANT_BOOL VGCore::IVGSelectionInformation::GetIsConnectorLine ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsConnectorLine(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2358)
inline VARIANT_BOOL VGCore::IVGSelectionInformation::GetIsConnector ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsConnector(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2359)
inline VARIANT_BOOL VGCore::IVGSelectionInformation::GetIsFittedText ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsFittedText(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2360)
inline VARIANT_BOOL VGCore::IVGSelectionInformation::GetIsFittedTextControl ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsFittedTextControl(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2361)
inline VARIANT_BOOL VGCore::IVGSelectionInformation::GetIsNaturalMediaControl ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsNaturalMediaControl(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2362)
inline VARIANT_BOOL VGCore::IVGSelectionInformation::GetIsNaturalMediaGroup ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsNaturalMediaGroup(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2363)
inline VARIANT_BOOL VGCore::IVGSelectionInformation::GetIsSecondExtrudeControl ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsSecondExtrudeControl(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2364)
inline VARIANT_BOOL VGCore::IVGSelectionInformation::GetIsSecondContourControl ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsSecondContourControl(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2365)
inline VARIANT_BOOL VGCore::IVGSelectionInformation::GetIsSecondDropShadowControl ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsSecondDropShadowControl(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2366)
inline VARIANT_BOOL VGCore::IVGSelectionInformation::GetIsSecondNaturalMediaControl ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsSecondNaturalMediaControl(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2367)
inline VARIANT_BOOL VGCore::IVGSelectionInformation::GetIsArtisticTextSelected ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsArtisticTextSelected(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2368)
inline VARIANT_BOOL VGCore::IVGSelectionInformation::GetIsParagraphTextSelected ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsParagraphTextSelected(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2369)
inline VARIANT_BOOL VGCore::IVGSelectionInformation::GetIsTextSelected ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsTextSelected(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2370)
inline VARIANT_BOOL VGCore::IVGSelectionInformation::GetIsOLESelected ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsOLESelected(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2371)
inline VARIANT_BOOL VGCore::IVGSelectionInformation::GetIsBitmapSelected ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsBitmapSelected(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2372)
inline VARIANT_BOOL VGCore::IVGSelectionInformation::GetIsBitmapPresent ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsBitmapPresent(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2373)
inline VARIANT_BOOL VGCore::IVGSelectionInformation::GetIsLensPresent ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsLensPresent(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2374)
inline VARIANT_BOOL VGCore::IVGSelectionInformation::GetIsMaskedBitmapPresent ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsMaskedBitmapPresent(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2375)
inline VARIANT_BOOL VGCore::IVGSelectionInformation::GetIsGroupSelected ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsGroupSelected(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2376)
inline VARIANT_BOOL VGCore::IVGSelectionInformation::GetCanUngroup ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_CanUngroup(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2377)
inline VARIANT_BOOL VGCore::IVGSelectionInformation::GetIsLinkGroupSelected ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsLinkGroupSelected(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2378)
inline VARIANT_BOOL VGCore::IVGSelectionInformation::GetIsLinkControlSelected ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsLinkControlSelected(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2379)
inline VARIANT_BOOL VGCore::IVGSelectionInformation::GetIsAttachedToDimension ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsAttachedToDimension(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2380)
inline VARIANT_BOOL VGCore::IVGSelectionInformation::GetIsFittedTextSelected ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsFittedTextSelected(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2381)
inline VARIANT_BOOL VGCore::IVGSelectionInformation::GetIsConnectorLineSelected ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsConnectorLineSelected(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2382)
inline VARIANT_BOOL VGCore::IVGSelectionInformation::GetIsConnectorSelected ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsConnectorSelected(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2383)
inline VARIANT_BOOL VGCore::IVGSelectionInformation::GetIsPerspectivePresent ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsPerspectivePresent(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2384)
inline VARIANT_BOOL VGCore::IVGSelectionInformation::GetIsEnvelopePresent ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsEnvelopePresent(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2385)
inline VARIANT_BOOL VGCore::IVGSelectionInformation::GetIsDistortionPresent ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsDistortionPresent(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2386)
inline VARIANT_BOOL VGCore::IVGSelectionInformation::GetIsGuidelineSelected ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsGuidelineSelected(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2387)
inline VARIANT_BOOL VGCore::IVGSelectionInformation::GetIsInternetObjectSelected ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsInternetObjectSelected(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2388)
inline VARIANT_BOOL VGCore::IVGSelectionInformation::GetIsSoundObjectSelected ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsSoundObjectSelected(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2389)
inline VARIANT_BOOL VGCore::IVGSelectionInformation::GetIsExternalBitmapSelected ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsExternalBitmapSelected(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2390)
inline VARIANT_BOOL VGCore::IVGSelectionInformation::GetIsNonExternalBitmapSelected ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsNonExternalBitmapSelected(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2391)
inline VARIANT_BOOL VGCore::IVGSelectionInformation::GetIsMeshFillSelected ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsMeshFillSelected(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2392)
inline VARIANT_BOOL VGCore::IVGSelectionInformation::GetIsMeshFillPresent ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsMeshFillPresent(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2393)
inline VARIANT_BOOL VGCore::IVGSelectionInformation::GetIsRollOverSelected ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsRollOverSelected(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2394)
inline VARIANT_BOOL VGCore::IVGSelectionInformation::GetContainsRollOverParent ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_ContainsRollOverParent(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2395)
inline VARIANT_BOOL VGCore::IVGSelectionInformation::GetCanClone ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_CanClone(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2396)
inline VARIANT_BOOL VGCore::IVGSelectionInformation::GetCanApplyBlend ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_CanApplyBlend(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2397)
inline VARIANT_BOOL VGCore::IVGSelectionInformation::GetCanApplyContour ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_CanApplyContour(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2398)
inline VARIANT_BOOL VGCore::IVGSelectionInformation::GetCanApplyFill ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_CanApplyFill(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2399)
inline VARIANT_BOOL VGCore::IVGSelectionInformation::GetCanApplyOutline ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_CanApplyOutline(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2400)
inline VARIANT_BOOL VGCore::IVGSelectionInformation::GetCanApplyTransparency ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_CanApplyTransparency(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2401)
inline VARIANT_BOOL VGCore::IVGSelectionInformation::GetCanAssignURL ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_CanAssignURL(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2402)
inline VARIANT_BOOL VGCore::IVGSelectionInformation::GetCanApplyDistortion ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_CanApplyDistortion(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2403)
inline VARIANT_BOOL VGCore::IVGSelectionInformation::GetCanApplyEnvelope ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_CanApplyEnvelope(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2404)
inline VARIANT_BOOL VGCore::IVGSelectionInformation::GetCanCopyBlend ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_CanCopyBlend(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2405)
inline VARIANT_BOOL VGCore::IVGSelectionInformation::GetCanCloneBlend ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_CanCloneBlend(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2406)
inline VARIANT_BOOL VGCore::IVGSelectionInformation::GetCanCopyExtrude ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_CanCopyExtrude(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2407)
inline VARIANT_BOOL VGCore::IVGSelectionInformation::GetCanCloneExtrude ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_CanCloneExtrude(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2408)
inline VARIANT_BOOL VGCore::IVGSelectionInformation::GetCanCopyContour ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_CanCopyContour(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2409)
inline VARIANT_BOOL VGCore::IVGSelectionInformation::GetCanCloneContour ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_CanCloneContour(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2410)
inline VARIANT_BOOL VGCore::IVGSelectionInformation::GetCanCopyDropShadow ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_CanCopyDropShadow(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2411)
inline VARIANT_BOOL VGCore::IVGSelectionInformation::GetCanCloneDropShadow ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_CanCloneDropShadow(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2412)
inline VARIANT_BOOL VGCore::IVGSelectionInformation::GetCanCopyLens ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_CanCopyLens(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2413)
inline VARIANT_BOOL VGCore::IVGSelectionInformation::GetCanCopyPerspective ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_CanCopyPerspective(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2414)
inline VARIANT_BOOL VGCore::IVGSelectionInformation::GetCanCopyEnvelope ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_CanCopyEnvelope(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2415)
inline VARIANT_BOOL VGCore::IVGSelectionInformation::GetCanCopyPowerclip ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_CanCopyPowerclip(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2416)
inline VARIANT_BOOL VGCore::IVGSelectionInformation::GetCanCopyDistortion ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_CanCopyDistortion(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2417)
inline VARIANT_BOOL VGCore::IVGSelectionInformation::GetCanLockShapes ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_CanLockShapes(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2418)
inline VARIANT_BOOL VGCore::IVGSelectionInformation::GetCanUnlockShapes ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_CanUnlockShapes(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface IVGCurve wrapper method implementations
//

#pragma implementation_key(2419)
inline double VGCore::IVGCurve::GetLength ( ) {
    double _result = 0;
    HRESULT _hr = get_Length(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2420)
inline VGCore::IVGSubPathsPtr VGCore::IVGCurve::GetSubPaths ( ) {
    struct IVGSubPaths * _result = 0;
    HRESULT _hr = get_SubPaths(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGSubPathsPtr(_result, false);
}

#pragma implementation_key(2421)
inline VGCore::IVGNodesPtr VGCore::IVGCurve::GetNodes ( ) {
    struct IVGNodes * _result = 0;
    HRESULT _hr = get_Nodes(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGNodesPtr(_result, false);
}

#pragma implementation_key(2422)
inline VGCore::IVGSegmentsPtr VGCore::IVGCurve::GetSegments ( ) {
    struct IVGSegments * _result = 0;
    HRESULT _hr = get_Segments(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGSegmentsPtr(_result, false);
}

#pragma implementation_key(2423)
inline VARIANT_BOOL VGCore::IVGCurve::GetClosed ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_Closed(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2424)
inline void VGCore::IVGCurve::PutClosed ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_Closed(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(2425)
inline VGCore::IVGNodeRangePtr VGCore::IVGCurve::Selection ( ) {
    struct IVGNodeRange * _result = 0;
    HRESULT _hr = raw_Selection(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGNodeRangePtr(_result, false);
}

#pragma implementation_key(2426)
inline VGCore::IVGSubPathPtr VGCore::IVGCurve::CreateSubPath ( double x, double y ) {
    struct IVGSubPath * _result = 0;
    HRESULT _hr = raw_CreateSubPath(x, y, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGSubPathPtr(_result, false);
}

#pragma implementation_key(2427)
inline HRESULT VGCore::IVGCurve::ReverseDirection ( ) {
    HRESULT _hr = raw_ReverseDirection();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(2428)
inline enum VGCore::cdrPositionOfPointOverShape VGCore::IVGCurve::IsOnCurve ( double x, double y, double HotArea ) {
    enum cdrPositionOfPointOverShape _result;
    HRESULT _hr = raw_IsOnCurve(x, y, HotArea, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2429)
inline HRESULT VGCore::IVGCurve::BindToDocument ( struct IVGDocument * Document ) {
    HRESULT _hr = raw_BindToDocument(Document);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(2430)
inline VGCore::IVGCurvePtr VGCore::IVGCurve::GetCopy ( ) {
    struct IVGCurve * _result = 0;
    HRESULT _hr = raw_GetCopy(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGCurvePtr(_result, false);
}

#pragma implementation_key(2431)
inline HRESULT VGCore::IVGCurve::CopyAssign ( struct IVGCurve * Source ) {
    HRESULT _hr = raw_CopyAssign(Source);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(2432)
inline VGCore::IVGSubPathPtr VGCore::IVGCurve::CreateSubPathFromArray ( SAFEARRAY * * Source, VARIANT_BOOL Closed, long NumElements ) {
    struct IVGSubPath * _result = 0;
    HRESULT _hr = raw_CreateSubPathFromArray(Source, Closed, NumElements, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGSubPathPtr(_result, false);
}

#pragma implementation_key(2433)
inline HRESULT VGCore::IVGCurve::AppendCurve ( struct IVGCurve * Source ) {
    HRESULT _hr = raw_AppendCurve(Source);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(2434)
inline SAFEARRAY * VGCore::IVGCurve::GetCurveInfo ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_GetCurveInfo(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2435)
inline long VGCore::IVGCurve::PutCurveInfo ( SAFEARRAY * * Source, long NumElements ) {
    long _result = 0;
    HRESULT _hr = raw_PutCurveInfo(Source, NumElements, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2436)
inline HRESULT VGCore::IVGCurve::ClearSelection ( ) {
    HRESULT _hr = raw_ClearSelection();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(2437)
inline VGCore::IVGCurvePtr VGCore::IVGCurve::GetPolyline ( long CurvePrecision ) {
    struct IVGCurve * _result = 0;
    HRESULT _hr = raw_GetPolyline(CurvePrecision, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGCurvePtr(_result, false);
}

#pragma implementation_key(2438)
inline VGCore::IVGCurvePtr VGCore::IVGCurve::RemoveOverlaps ( ) {
    struct IVGCurve * _result = 0;
    HRESULT _hr = raw_RemoveOverlaps(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGCurvePtr(_result, false);
}

#pragma implementation_key(2439)
inline VGCore::IVGCurvePtr VGCore::IVGCurve::Contour ( double Offset, enum cdrContourDirection Direction, enum cdrContourEndCapType EndCapType, enum cdrContourCornerType CornerType, double MiterLimit ) {
    struct IVGCurve * _result = 0;
    HRESULT _hr = raw_Contour(Offset, Direction, EndCapType, CornerType, MiterLimit, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGCurvePtr(_result, false);
}

#pragma implementation_key(2440)
inline VARIANT_BOOL VGCore::IVGCurve::IsPointInside ( double x, double y ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_IsPointInside(x, y, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2441)
inline VARIANT_BOOL VGCore::IVGCurve::IsRectOnEdge ( double x1, double y1, double x2, double y2 ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_IsRectOnEdge(x1, y1, x2, y2, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2442)
inline VGCore::IVGSegmentPtr VGCore::IVGCurve::FindClosestSegment ( double x, double y, double * ParamOffset ) {
    struct IVGSegment * _result = 0;
    HRESULT _hr = raw_FindClosestSegment(x, y, ParamOffset, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGSegmentPtr(_result, false);
}

#pragma implementation_key(2443)
inline VGCore::IVGNodePtr VGCore::IVGCurve::FindNodeAtPoint ( double x, double y, double HotArea ) {
    struct IVGNode * _result = 0;
    HRESULT _hr = raw_FindNodeAtPoint(x, y, HotArea, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGNodePtr(_result, false);
}

#pragma implementation_key(2444)
inline VGCore::IVGSegmentPtr VGCore::IVGCurve::FindSegmentAtPoint ( double x, double y, double * ParamOffset, double HotArea ) {
    struct IVGSegment * _result = 0;
    HRESULT _hr = raw_FindSegmentAtPoint(x, y, ParamOffset, HotArea, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGSegmentPtr(_result, false);
}

#pragma implementation_key(2445)
inline VGCore::IVGCurvePtr VGCore::IVGCurve::WeldWith ( struct IVGCurve * Curve ) {
    struct IVGCurve * _result = 0;
    HRESULT _hr = raw_WeldWith(Curve, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGCurvePtr(_result, false);
}

#pragma implementation_key(2446)
inline VARIANT_BOOL VGCore::IVGCurve::GetIsClockwise ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsClockwise(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2447)
inline double VGCore::IVGCurve::GetArea ( ) {
    double _result = 0;
    HRESULT _hr = get_Area(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2448)
inline VARIANT_BOOL VGCore::IVGCurve::GetBoundingBox ( double * x, double * y, double * Width, double * Height ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_GetBoundingBox(x, y, Width, Height, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2449)
inline VGCore::IVGRectPtr VGCore::IVGCurve::GetBoundingBox ( ) {
    struct IVGRect * _result = 0;
    HRESULT _hr = get_BoundingBox(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGRectPtr(_result, false);
}

#pragma implementation_key(2450)
inline VARIANT_BOOL VGCore::IVGCurve::IntersectsWith ( struct IVGCurve * Curve ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_IntersectsWith(Curve, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2451)
inline HRESULT VGCore::IVGCurve::AppendSubpathFitToPoints ( struct IVGPointRange * Points, VARIANT_BOOL UseCurrentViewForTolerance, double tolerance ) {
    HRESULT _hr = raw_AppendSubpathFitToPoints(Points, UseCurrentViewForTolerance, tolerance);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(2452)
inline HRESULT VGCore::IVGCurve::AppendSubpathFitToPointsAndCusps ( struct IVGPointRange * Points, SAFEARRAY * * CuspIndexArray, VARIANT_BOOL UseCurrentViewForTolerance, double tolerance ) {
    HRESULT _hr = raw_AppendSubpathFitToPointsAndCusps(Points, CuspIndexArray, UseCurrentViewForTolerance, tolerance);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(2453)
inline HRESULT VGCore::IVGCurve::ApplyTransformMatrix ( struct IVGTransformMatrix * TransformMatrix ) {
    HRESULT _hr = raw_ApplyTransformMatrix(TransformMatrix);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(2454)
inline HRESULT VGCore::IVGCurve::AppendSubpathFromPoints ( struct IVGPointRange * Points, VARIANT_BOOL Close ) {
    HRESULT _hr = raw_AppendSubpathFromPoints(Points, Close);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(2455)
inline VGCore::IVGCurvePtr VGCore::IVGCurve::CreateCurveMappedToStroke ( struct IVGSubPath * Stroke, double ScaleY, VARIANT_BOOL SelfWeld ) {
    struct IVGCurve * _result = 0;
    HRESULT _hr = raw_CreateCurveMappedToStroke(Stroke, ScaleY, SelfWeld, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGCurvePtr(_result, false);
}

#pragma implementation_key(2456)
inline VGCore::IVGCurvePtr VGCore::IVGCurve::CreateCurveMappedToStrokeAndReferenceLine ( struct IVGSubPath * Stroke, struct IVGPoint * Start, struct IVGPoint * End, double ScaleY, VARIANT_BOOL SelfWeld ) {
    struct IVGCurve * _result = 0;
    HRESULT _hr = raw_CreateCurveMappedToStrokeAndReferenceLine(Stroke, Start, End, ScaleY, SelfWeld, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGCurvePtr(_result, false);
}

#pragma implementation_key(2457)
inline HRESULT VGCore::IVGCurve::AutoReduceNodes ( double AmountToReduce0To100, VARIANT_BOOL SelectedNodesOnly ) {
    HRESULT _hr = raw_AutoReduceNodes(AmountToReduce0To100, SelectedNodesOnly);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(2458)
inline HRESULT VGCore::IVGCurve::JoinTouchingSubpaths ( VARIANT_BOOL AllowSubpathReversals, double tolerance ) {
    HRESULT _hr = raw_JoinTouchingSubpaths(AllowSubpathReversals, tolerance);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(2459)
inline HRESULT VGCore::IVGCurve::AppendSubpathCircle ( double CenterX, double CenterY, double Radius ) {
    HRESULT _hr = raw_AppendSubpathCircle(CenterX, CenterY, Radius);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(2460)
inline HRESULT VGCore::IVGCurve::AppendSubpathRectangle ( double Left, double Top, double Right, double Bottom ) {
    HRESULT _hr = raw_AppendSubpathRectangle(Left, Top, Right, Bottom);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(2461)
inline HRESULT VGCore::IVGCurve::AppendSubpathThreePointArc ( double StartX, double StartY, double EndX, double EndY, double ThirdX, double ThirdY ) {
    HRESULT _hr = raw_AppendSubpathThreePointArc(StartX, StartY, EndX, EndY, ThirdX, ThirdY);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(2462)
inline HRESULT VGCore::IVGCurve::SelfWeldClosedSubpaths ( ) {
    HRESULT _hr = raw_SelfWeldClosedSubpaths();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(2463)
inline HRESULT VGCore::IVGCurve::AppendSubpathEllipse ( double CenterX, double CenterY, double RadiusH, double RadiusV ) {
    HRESULT _hr = raw_AppendSubpathEllipse(CenterX, CenterY, RadiusH, RadiusV);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(2464)
inline VGCore::IVGCurvePtr VGCore::IVGCurve::WeldEx ( struct IVGCurve * TargetCurve, enum cdrWeldMethod Method, VARIANT_BOOL WindingSource, VARIANT_BOOL WindingTarget, long Flags ) {
    struct IVGCurve * _result = 0;
    HRESULT _hr = raw_WeldEx(TargetCurve, Method, WindingSource, WindingTarget, Flags, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGCurvePtr(_result, false);
}

//
// interface IVGArrowHead wrapper method implementations
//

#pragma implementation_key(2465)
inline long VGCore::IVGArrowHead::GetIndex ( ) {
    long _result = 0;
    HRESULT _hr = get_Index(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2466)
inline VGCore::IVGCurvePtr VGCore::IVGArrowHead::GetCurve ( ) {
    struct IVGCurve * _result = 0;
    HRESULT _hr = get_Curve(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGCurvePtr(_result, false);
}

#pragma implementation_key(2467)
inline double VGCore::IVGArrowHead::GetBaseOutlineScale ( ) {
    double _result = 0;
    HRESULT _hr = get_BaseOutlineScale(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2468)
inline double VGCore::IVGArrowHead::GetCenterX ( ) {
    double _result = 0;
    HRESULT _hr = get_CenterX(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2469)
inline double VGCore::IVGArrowHead::GetCenterY ( ) {
    double _result = 0;
    HRESULT _hr = get_CenterY(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2470)
inline double VGCore::IVGArrowHead::GetLineOffset ( ) {
    double _result = 0;
    HRESULT _hr = get_LineOffset(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2471)
inline VGCore::IVGArrowHeadPtr VGCore::IVGArrowHead::BindToDocument ( struct IVGDocument * Document ) {
    struct IVGArrowHead * _result = 0;
    HRESULT _hr = raw_BindToDocument(Document, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGArrowHeadPtr(_result, false);
}

#pragma implementation_key(2472)
inline VARIANT_BOOL VGCore::IVGArrowHead::CompareWith ( struct IVGArrowHead * ArrowHead ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_CompareWith(ArrowHead, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2473)
inline _bstr_t VGCore::IVGArrowHead::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(2474)
inline void VGCore::IVGArrowHead::PutName ( _bstr_t pVal ) {
    HRESULT _hr = put_Name(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(2475)
inline _bstr_t VGCore::IVGArrowHead::GetDisplayName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_DisplayName(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

//
// interface IVGArrowHeads wrapper method implementations
//

#pragma implementation_key(2476)
inline VGCore::IVGApplicationPtr VGCore::IVGArrowHeads::GetApplication ( ) {
    struct IVGApplication * _result = 0;
    HRESULT _hr = get_Application(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGApplicationPtr(_result, false);
}

#pragma implementation_key(2477)
inline VGCore::IVGApplicationPtr VGCore::IVGArrowHeads::GetParent ( ) {
    struct IVGApplication * _result = 0;
    HRESULT _hr = get_Parent(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGApplicationPtr(_result, false);
}

#pragma implementation_key(2478)
inline VGCore::IVGArrowHeadPtr VGCore::IVGArrowHeads::GetItem ( long Index ) {
    struct IVGArrowHead * _result = 0;
    HRESULT _hr = get_Item(Index, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGArrowHeadPtr(_result, false);
}

#pragma implementation_key(2479)
inline IUnknownPtr VGCore::IVGArrowHeads::Get_NewEnum ( ) {
    IUnknown * _result = 0;
    HRESULT _hr = get__NewEnum(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IUnknownPtr(_result, false);
}

#pragma implementation_key(2480)
inline long VGCore::IVGArrowHeads::GetCount ( ) {
    long _result = 0;
    HRESULT _hr = get_Count(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2481)
inline HRESULT VGCore::IVGArrowHeads::Remove ( long Index ) {
    HRESULT _hr = raw_Remove(Index);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(2482)
inline VGCore::IVGArrowHeadPtr VGCore::IVGArrowHeads::Add ( struct IVGArrowHead * ArrowHead ) {
    struct IVGArrowHead * _result = 0;
    HRESULT _hr = raw_Add(ArrowHead, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGArrowHeadPtr(_result, false);
}

#pragma implementation_key(2483)
inline VGCore::IVGArrowHeadPtr VGCore::IVGArrowHeads::Replace ( long Index, struct IVGArrowHead * ArrowHead ) {
    struct IVGArrowHead * _result = 0;
    HRESULT _hr = raw_Replace(Index, ArrowHead, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGArrowHeadPtr(_result, false);
}

//
// interface IVGSubPaths wrapper method implementations
//

#pragma implementation_key(2484)
inline VGCore::IVGApplicationPtr VGCore::IVGSubPaths::GetApplication ( ) {
    struct IVGApplication * _result = 0;
    HRESULT _hr = get_Application(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGApplicationPtr(_result, false);
}

#pragma implementation_key(2485)
inline VGCore::IVGCurvePtr VGCore::IVGSubPaths::GetParent ( ) {
    struct IVGCurve * _result = 0;
    HRESULT _hr = get_Parent(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGCurvePtr(_result, false);
}

#pragma implementation_key(2486)
inline VGCore::IVGSubPathPtr VGCore::IVGSubPaths::GetItem ( long Index ) {
    struct IVGSubPath * _result = 0;
    HRESULT _hr = get_Item(Index, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGSubPathPtr(_result, false);
}

#pragma implementation_key(2487)
inline IUnknownPtr VGCore::IVGSubPaths::Get_NewEnum ( ) {
    IUnknown * _result = 0;
    HRESULT _hr = get__NewEnum(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IUnknownPtr(_result, false);
}

#pragma implementation_key(2488)
inline long VGCore::IVGSubPaths::GetCount ( ) {
    long _result = 0;
    HRESULT _hr = get_Count(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2489)
inline VGCore::IVGSubPathPtr VGCore::IVGSubPaths::GetFirst ( ) {
    struct IVGSubPath * _result = 0;
    HRESULT _hr = get_First(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGSubPathPtr(_result, false);
}

#pragma implementation_key(2490)
inline VGCore::IVGSubPathPtr VGCore::IVGSubPaths::GetLast ( ) {
    struct IVGSubPath * _result = 0;
    HRESULT _hr = get_Last(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGSubPathPtr(_result, false);
}

//
// interface IVGSubPath wrapper method implementations
//

#pragma implementation_key(2491)
inline VGCore::IVGApplicationPtr VGCore::IVGSubPath::GetApplication ( ) {
    struct IVGApplication * _result = 0;
    HRESULT _hr = get_Application(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGApplicationPtr(_result, false);
}

#pragma implementation_key(2492)
inline VGCore::IVGCurvePtr VGCore::IVGSubPath::GetParent ( ) {
    struct IVGCurve * _result = 0;
    HRESULT _hr = get_Parent(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGCurvePtr(_result, false);
}

#pragma implementation_key(2493)
inline VGCore::IVGNodesPtr VGCore::IVGSubPath::GetNodes ( ) {
    struct IVGNodes * _result = 0;
    HRESULT _hr = get_Nodes(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGNodesPtr(_result, false);
}

#pragma implementation_key(2494)
inline VGCore::IVGSegmentsPtr VGCore::IVGSubPath::GetSegments ( ) {
    struct IVGSegments * _result = 0;
    HRESULT _hr = get_Segments(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGSegmentsPtr(_result, false);
}

#pragma implementation_key(2495)
inline long VGCore::IVGSubPath::GetIndex ( ) {
    long _result = 0;
    HRESULT _hr = get_Index(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2496)
inline double VGCore::IVGSubPath::GetLength ( ) {
    double _result = 0;
    HRESULT _hr = get_Length(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2497)
inline VARIANT_BOOL VGCore::IVGSubPath::GetClosed ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_Closed(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2498)
inline void VGCore::IVGSubPath::PutClosed ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_Closed(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(2499)
inline double VGCore::IVGSubPath::GetPositionX ( ) {
    double _result = 0;
    HRESULT _hr = get_PositionX(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2500)
inline void VGCore::IVGSubPath::PutPositionX ( double pVal ) {
    HRESULT _hr = put_PositionX(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(2501)
inline double VGCore::IVGSubPath::GetPositionY ( ) {
    double _result = 0;
    HRESULT _hr = get_PositionY(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2502)
inline void VGCore::IVGSubPath::PutPositionY ( double pVal ) {
    HRESULT _hr = put_PositionY(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(2503)
inline double VGCore::IVGSubPath::GetSizeWidth ( ) {
    double _result = 0;
    HRESULT _hr = get_SizeWidth(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2504)
inline double VGCore::IVGSubPath::GetSizeHeight ( ) {
    double _result = 0;
    HRESULT _hr = get_SizeHeight(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2505)
inline VGCore::IVGNodeRangePtr VGCore::IVGSubPath::Selection ( ) {
    struct IVGNodeRange * _result = 0;
    HRESULT _hr = raw_Selection(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGNodeRangePtr(_result, false);
}

#pragma implementation_key(2506)
inline HRESULT VGCore::IVGSubPath::ReverseDirection ( ) {
    HRESULT _hr = raw_ReverseDirection();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(2507)
inline VGCore::IVGShapePtr VGCore::IVGSubPath::Extract ( struct IVGShape * * OldCurve ) {
    struct IVGShape * _result = 0;
    HRESULT _hr = raw_Extract(OldCurve, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGShapePtr(_result, false);
}

#pragma implementation_key(2508)
inline HRESULT VGCore::IVGSubPath::Delete ( ) {
    HRESULT _hr = raw_Delete();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(2509)
inline HRESULT VGCore::IVGSubPath::GetPosition ( double * PositionX, double * PositionY ) {
    HRESULT _hr = raw_GetPosition(PositionX, PositionY);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(2510)
inline HRESULT VGCore::IVGSubPath::SetPosition ( double PositionX, double PositionY ) {
    HRESULT _hr = raw_SetPosition(PositionX, PositionY);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(2511)
inline HRESULT VGCore::IVGSubPath::Move ( double DeltaX, double DeltaY ) {
    HRESULT _hr = raw_Move(DeltaX, DeltaY);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(2512)
inline enum VGCore::cdrPositionOfPointOverShape VGCore::IVGSubPath::IsOnSubPath ( double x, double y, double HotArea ) {
    enum cdrPositionOfPointOverShape _result;
    HRESULT _hr = raw_IsOnSubPath(x, y, HotArea, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2513)
inline VGCore::IVGSegmentPtr VGCore::IVGSubPath::AppendLineSegment ( double x, double y, VARIANT_BOOL AppendAtBeginning ) {
    struct IVGSegment * _result = 0;
    HRESULT _hr = raw_AppendLineSegment(x, y, AppendAtBeginning, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGSegmentPtr(_result, false);
}

#pragma implementation_key(2514)
inline VGCore::IVGSegmentPtr VGCore::IVGSubPath::AppendCurveSegment ( double x, double y, double StartingControlPointLength, double StartingControlPointAngle, double EndingControlPointLength, double EndingControlPointAngle, VARIANT_BOOL AppendAtBeginning ) {
    struct IVGSegment * _result = 0;
    HRESULT _hr = raw_AppendCurveSegment(x, y, StartingControlPointLength, StartingControlPointAngle, EndingControlPointLength, EndingControlPointAngle, AppendAtBeginning, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGSegmentPtr(_result, false);
}

#pragma implementation_key(2515)
inline HRESULT VGCore::IVGSubPath::GetPointPositionAt ( double * x, double * y, double Offset, enum cdrSegmentOffsetType OffsetType ) {
    HRESULT _hr = raw_GetPointPositionAt(x, y, Offset, OffsetType);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(2516)
inline VGCore::IVGNodePtr VGCore::IVGSubPath::BreakApartAt ( double Offset, enum cdrSegmentOffsetType OffsetType ) {
    struct IVGNode * _result = 0;
    HRESULT _hr = raw_BreakApartAt(Offset, OffsetType, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGNodePtr(_result, false);
}

#pragma implementation_key(2517)
inline VGCore::IVGNodePtr VGCore::IVGSubPath::AddNodeAt ( double Offset, enum cdrSegmentOffsetType OffsetType ) {
    struct IVGNode * _result = 0;
    HRESULT _hr = raw_AddNodeAt(Offset, OffsetType, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGNodePtr(_result, false);
}

#pragma implementation_key(2518)
inline double VGCore::IVGSubPath::GetPerpendicularAt ( double Offset, enum cdrSegmentOffsetType OffsetType ) {
    double _result = 0;
    HRESULT _hr = raw_GetPerpendicularAt(Offset, OffsetType, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2519)
inline double VGCore::IVGSubPath::GetTangentAt ( double Offset, enum cdrSegmentOffsetType OffsetType ) {
    double _result = 0;
    HRESULT _hr = raw_GetTangentAt(Offset, OffsetType, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2520)
inline VGCore::IVGCrossPointsPtr VGCore::IVGSubPath::GetIntersections ( struct IVGSubPath * Target, enum cdrSegmentOffsetType OffsetType ) {
    struct IVGCrossPoints * _result = 0;
    HRESULT _hr = raw_GetIntersections(Target, OffsetType, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGCrossPointsPtr(_result, false);
}

#pragma implementation_key(2521)
inline VGCore::IVGSegmentPtr VGCore::IVGSubPath::GetSegmentAt ( double Offset, enum cdrSegmentOffsetType OffsetType, double * SegmentOffset ) {
    struct IVGSegment * _result = 0;
    HRESULT _hr = raw_GetSegmentAt(Offset, OffsetType, SegmentOffset, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGSegmentPtr(_result, false);
}

#pragma implementation_key(2522)
inline VGCore::IVGSubPathPtr VGCore::IVGSubPath::Next ( ) {
    struct IVGSubPath * _result = 0;
    HRESULT _hr = raw_Next(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGSubPathPtr(_result, false);
}

#pragma implementation_key(2523)
inline VGCore::IVGSubPathPtr VGCore::IVGSubPath::Previous ( ) {
    struct IVGSubPath * _result = 0;
    HRESULT _hr = raw_Previous(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGSubPathPtr(_result, false);
}

#pragma implementation_key(2524)
inline double VGCore::IVGSubPath::GetCurvatureAt ( double Offset, enum cdrSegmentOffsetType OffsetType ) {
    double _result = 0;
    HRESULT _hr = raw_GetCurvatureAt(Offset, OffsetType, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2525)
inline double VGCore::IVGSubPath::GetCurveSpeedAt ( double Offset, enum cdrSegmentOffsetType OffsetType ) {
    double _result = 0;
    HRESULT _hr = raw_GetCurveSpeedAt(Offset, OffsetType, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2526)
inline VGCore::IVGNodePtr VGCore::IVGSubPath::GetStartNode ( ) {
    struct IVGNode * _result = 0;
    HRESULT _hr = get_StartNode(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGNodePtr(_result, false);
}

#pragma implementation_key(2527)
inline VGCore::IVGNodePtr VGCore::IVGSubPath::GetEndNode ( ) {
    struct IVGNode * _result = 0;
    HRESULT _hr = get_EndNode(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGNodePtr(_result, false);
}

#pragma implementation_key(2528)
inline VARIANT_BOOL VGCore::IVGSubPath::FindSegmentOffset ( double AbsoluteOffset, struct IVGSegment * * Segment, double * ParamOffset, double * Remainder ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_FindSegmentOffset(AbsoluteOffset, Segment, ParamOffset, Remainder, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2529)
inline VGCore::IVGSegmentPtr VGCore::IVGSubPath::GetFirstSegment ( ) {
    struct IVGSegment * _result = 0;
    HRESULT _hr = get_FirstSegment(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGSegmentPtr(_result, false);
}

#pragma implementation_key(2530)
inline VGCore::IVGSegmentPtr VGCore::IVGSubPath::GetLastSegment ( ) {
    struct IVGSegment * _result = 0;
    HRESULT _hr = get_LastSegment(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGSegmentPtr(_result, false);
}

#pragma implementation_key(2531)
inline VGCore::IVGSegmentPtr VGCore::IVGSubPath::AppendCurveSegment2 ( double x, double y, double StartingControlPointX, double StartingControlPointY, double EndingControlPointX, double EndingControlPointY, VARIANT_BOOL AppendAtBeginning ) {
    struct IVGSegment * _result = 0;
    HRESULT _hr = raw_AppendCurveSegment2(x, y, StartingControlPointX, StartingControlPointY, EndingControlPointX, EndingControlPointY, AppendAtBeginning, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGSegmentPtr(_result, false);
}

#pragma implementation_key(2532)
inline VGCore::IVGCurvePtr VGCore::IVGSubPath::GetCopy ( ) {
    struct IVGCurve * _result = 0;
    HRESULT _hr = raw_GetCopy(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGCurvePtr(_result, false);
}

#pragma implementation_key(2533)
inline SAFEARRAY * VGCore::IVGSubPath::GetCurveInfo ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_GetCurveInfo(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2534)
inline long VGCore::IVGSubPath::PutCurveInfo ( SAFEARRAY * * Source, long NumElements ) {
    long _result = 0;
    HRESULT _hr = raw_PutCurveInfo(Source, NumElements, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2535)
inline VGCore::IVGCurvePtr VGCore::IVGSubPath::GetPolyline ( long CurvePrecision ) {
    struct IVGCurve * _result = 0;
    HRESULT _hr = raw_GetPolyline(CurvePrecision, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGCurvePtr(_result, false);
}

#pragma implementation_key(2536)
inline VARIANT_BOOL VGCore::IVGSubPath::IsPointInside ( double x, double y ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_IsPointInside(x, y, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2537)
inline VARIANT_BOOL VGCore::IVGSubPath::IsRectOnEdge ( double x1, double y1, double x2, double y2 ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_IsRectOnEdge(x1, y1, x2, y2, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2538)
inline VGCore::IVGSegmentPtr VGCore::IVGSubPath::FindClosestSegment ( double x, double y, double * ParamOffset ) {
    struct IVGSegment * _result = 0;
    HRESULT _hr = raw_FindClosestSegment(x, y, ParamOffset, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGSegmentPtr(_result, false);
}

#pragma implementation_key(2539)
inline VGCore::IVGNodePtr VGCore::IVGSubPath::FindNodeAtPoint ( double x, double y, double HotArea ) {
    struct IVGNode * _result = 0;
    HRESULT _hr = raw_FindNodeAtPoint(x, y, HotArea, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGNodePtr(_result, false);
}

#pragma implementation_key(2540)
inline VGCore::IVGSegmentPtr VGCore::IVGSubPath::FindSegmentAtPoint ( double x, double y, double * ParamOffset, double HotArea ) {
    struct IVGSegment * _result = 0;
    HRESULT _hr = raw_FindSegmentAtPoint(x, y, ParamOffset, HotArea, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGSegmentPtr(_result, false);
}

#pragma implementation_key(2541)
inline VARIANT_BOOL VGCore::IVGSubPath::GetIsClockwise ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsClockwise(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2542)
inline double VGCore::IVGSubPath::GetArea ( ) {
    double _result = 0;
    HRESULT _hr = get_Area(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2543)
inline VARIANT_BOOL VGCore::IVGSubPath::GetBoundingBox ( double * x, double * y, double * Width, double * Height ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_GetBoundingBox(x, y, Width, Height, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2544)
inline VGCore::IVGRectPtr VGCore::IVGSubPath::GetBoundingBox ( ) {
    struct IVGRect * _result = 0;
    HRESULT _hr = get_BoundingBox(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGRectPtr(_result, false);
}

#pragma implementation_key(2545)
inline HRESULT VGCore::IVGSubPath::EqualDivide ( long Divisions, double Gap ) {
    HRESULT _hr = raw_EqualDivide(Divisions, Gap);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(2546)
inline VGCore::IVGPointRangePtr VGCore::IVGSubPath::GetEvenlySpacedPoints ( double DistanceBetweenPointsAlongCurve, VARIANT_BOOL ScaleDistanceToFit ) {
    struct IVGPointRange * _result = 0;
    HRESULT _hr = raw_GetEvenlySpacedPoints(DistanceBetweenPointsAlongCurve, ScaleDistanceToFit, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGPointRangePtr(_result, false);
}

#pragma implementation_key(2547)
inline VGCore::IVGVectorPtr VGCore::IVGSubPath::GetPerpendicularVectorAt ( double Offset, enum cdrSegmentOffsetType OffsetType, VARIANT_BOOL Normalize ) {
    struct IVGVector * _result = 0;
    HRESULT _hr = raw_GetPerpendicularVectorAt(Offset, OffsetType, Normalize, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGVectorPtr(_result, false);
}

#pragma implementation_key(2548)
inline VGCore::IVGVectorPtr VGCore::IVGSubPath::GetTangentVectorAt ( double Offset, enum cdrSegmentOffsetType OffsetType, VARIANT_BOOL Normalize ) {
    struct IVGVector * _result = 0;
    HRESULT _hr = raw_GetTangentVectorAt(Offset, OffsetType, Normalize, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGVectorPtr(_result, false);
}

#pragma implementation_key(2549)
inline VGCore::IVGPointPtr VGCore::IVGSubPath::GetPointAt ( double Offset, enum cdrSegmentOffsetType OffsetType ) {
    struct IVGPoint * _result = 0;
    HRESULT _hr = raw_GetPointAt(Offset, OffsetType, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGPointPtr(_result, false);
}

//
// interface IVGNodes wrapper method implementations
//

#pragma implementation_key(2550)
inline VGCore::IVGApplicationPtr VGCore::IVGNodes::GetApplication ( ) {
    struct IVGApplication * _result = 0;
    HRESULT _hr = get_Application(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGApplicationPtr(_result, false);
}

#pragma implementation_key(2551)
inline VGCore::IVGCurvePtr VGCore::IVGNodes::GetParent ( ) {
    struct IVGCurve * _result = 0;
    HRESULT _hr = get_Parent(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGCurvePtr(_result, false);
}

#pragma implementation_key(2552)
inline VGCore::IVGNodePtr VGCore::IVGNodes::GetItem ( long Index ) {
    struct IVGNode * _result = 0;
    HRESULT _hr = get_Item(Index, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGNodePtr(_result, false);
}

#pragma implementation_key(2553)
inline IUnknownPtr VGCore::IVGNodes::Get_NewEnum ( ) {
    IUnknown * _result = 0;
    HRESULT _hr = get__NewEnum(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IUnknownPtr(_result, false);
}

#pragma implementation_key(2554)
inline long VGCore::IVGNodes::GetCount ( ) {
    long _result = 0;
    HRESULT _hr = get_Count(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2555)
inline VGCore::IVGNodeRangePtr VGCore::IVGNodes::Range ( SAFEARRAY * * IndexArray ) {
    struct IVGNodeRange * _result = 0;
    HRESULT _hr = raw_Range(IndexArray, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGNodeRangePtr(_result, false);
}

#pragma implementation_key(2556)
inline VGCore::IVGNodeRangePtr VGCore::IVGNodes::All ( ) {
    struct IVGNodeRange * _result = 0;
    HRESULT _hr = raw_All(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGNodeRangePtr(_result, false);
}

#pragma implementation_key(2557)
inline VGCore::IVGNodeRangePtr VGCore::IVGNodes::AllExcluding ( SAFEARRAY * * IndexArray ) {
    struct IVGNodeRange * _result = 0;
    HRESULT _hr = raw_AllExcluding(IndexArray, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGNodeRangePtr(_result, false);
}

#pragma implementation_key(2558)
inline VGCore::IVGNodePtr VGCore::IVGNodes::GetFirst ( ) {
    struct IVGNode * _result = 0;
    HRESULT _hr = get_First(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGNodePtr(_result, false);
}

#pragma implementation_key(2559)
inline VGCore::IVGNodePtr VGCore::IVGNodes::GetLast ( ) {
    struct IVGNode * _result = 0;
    HRESULT _hr = get_Last(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGNodePtr(_result, false);
}

//
// interface IVGNode wrapper method implementations
//

#pragma implementation_key(2560)
inline VGCore::IVGApplicationPtr VGCore::IVGNode::GetApplication ( ) {
    struct IVGApplication * _result = 0;
    HRESULT _hr = get_Application(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGApplicationPtr(_result, false);
}

#pragma implementation_key(2561)
inline VGCore::IVGCurvePtr VGCore::IVGNode::GetParent ( ) {
    struct IVGCurve * _result = 0;
    HRESULT _hr = get_Parent(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGCurvePtr(_result, false);
}

#pragma implementation_key(2562)
inline double VGCore::IVGNode::GetPositionX ( ) {
    double _result = 0;
    HRESULT _hr = get_PositionX(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2563)
inline void VGCore::IVGNode::PutPositionX ( double pVal ) {
    HRESULT _hr = put_PositionX(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(2564)
inline double VGCore::IVGNode::GetPositionY ( ) {
    double _result = 0;
    HRESULT _hr = get_PositionY(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2565)
inline void VGCore::IVGNode::PutPositionY ( double pVal ) {
    HRESULT _hr = put_PositionY(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(2566)
inline enum VGCore::cdrNodeType VGCore::IVGNode::GetType ( ) {
    enum cdrNodeType _result;
    HRESULT _hr = get_Type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2567)
inline void VGCore::IVGNode::PutType ( enum cdrNodeType pVal ) {
    HRESULT _hr = put_Type(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(2568)
inline VGCore::IVGSubPathPtr VGCore::IVGNode::GetSubPath ( ) {
    struct IVGSubPath * _result = 0;
    HRESULT _hr = get_SubPath(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGSubPathPtr(_result, false);
}

#pragma implementation_key(2569)
inline long VGCore::IVGNode::GetIndex ( ) {
    long _result = 0;
    HRESULT _hr = get_Index(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2570)
inline long VGCore::IVGNode::GetSubPathIndex ( ) {
    long _result = 0;
    HRESULT _hr = get_SubPathIndex(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2571)
inline long VGCore::IVGNode::GetAbsoluteIndex ( ) {
    long _result = 0;
    HRESULT _hr = get_AbsoluteIndex(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2572)
inline VARIANT_BOOL VGCore::IVGNode::GetIsEnding ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsEnding(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2573)
inline HRESULT VGCore::IVGNode::JoinWith ( struct IVGNode * Target ) {
    HRESULT _hr = raw_JoinWith(Target);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(2574)
inline HRESULT VGCore::IVGNode::ConnectWith ( struct IVGNode * Target ) {
    HRESULT _hr = raw_ConnectWith(Target);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(2575)
inline HRESULT VGCore::IVGNode::BreakApart ( ) {
    HRESULT _hr = raw_BreakApart();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(2576)
inline HRESULT VGCore::IVGNode::Delete ( ) {
    HRESULT _hr = raw_Delete();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(2577)
inline HRESULT VGCore::IVGNode::GetPosition ( double * PositionX, double * PositionY ) {
    HRESULT _hr = raw_GetPosition(PositionX, PositionY);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(2578)
inline HRESULT VGCore::IVGNode::SetPosition ( double PositionX, double PositionY ) {
    HRESULT _hr = raw_SetPosition(PositionX, PositionY);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(2579)
inline HRESULT VGCore::IVGNode::Move ( double DeltaX, double DeltaY ) {
    HRESULT _hr = raw_Move(DeltaX, DeltaY);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(2580)
inline VGCore::IVGNodePtr VGCore::IVGNode::Next ( ) {
    struct IVGNode * _result = 0;
    HRESULT _hr = raw_Next(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGNodePtr(_result, false);
}

#pragma implementation_key(2581)
inline VGCore::IVGNodePtr VGCore::IVGNode::Previous ( ) {
    struct IVGNode * _result = 0;
    HRESULT _hr = raw_Previous(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGNodePtr(_result, false);
}

#pragma implementation_key(2582)
inline double VGCore::IVGNode::GetDistanceFrom ( struct IVGNode * Node ) {
    double _result = 0;
    HRESULT _hr = raw_GetDistanceFrom(Node, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2583)
inline VGCore::IVGSegmentPtr VGCore::IVGNode::GetSegment ( ) {
    struct IVGSegment * _result = 0;
    HRESULT _hr = get_Segment(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGSegmentPtr(_result, false);
}

#pragma implementation_key(2584)
inline VGCore::IVGSegmentPtr VGCore::IVGNode::GetPrevSegment ( ) {
    struct IVGSegment * _result = 0;
    HRESULT _hr = get_PrevSegment(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGSegmentPtr(_result, false);
}

#pragma implementation_key(2585)
inline VGCore::IVGSegmentPtr VGCore::IVGNode::GetNextSegment ( ) {
    struct IVGSegment * _result = 0;
    HRESULT _hr = get_NextSegment(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGSegmentPtr(_result, false);
}

#pragma implementation_key(2586)
inline VARIANT_BOOL VGCore::IVGNode::Fillet ( double Radius, VARIANT_BOOL CombineSmoothSegments ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_Fillet(Radius, CombineSmoothSegments, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2587)
inline VARIANT_BOOL VGCore::IVGNode::Chamfer ( double DistanceA, double DistanceB, VARIANT_BOOL CombineSmoothSegments ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_Chamfer(DistanceA, DistanceB, CombineSmoothSegments, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2588)
inline VARIANT_BOOL VGCore::IVGNode::Scallop ( double Radius, VARIANT_BOOL CombineSmoothSegments ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_Scallop(Radius, CombineSmoothSegments, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2589)
inline VARIANT_BOOL VGCore::IVGNode::GetSelected ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_Selected(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2590)
inline void VGCore::IVGNode::PutSelected ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_Selected(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(2591)
inline HRESULT VGCore::IVGNode::CreateSelection ( ) {
    HRESULT _hr = raw_CreateSelection();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(2592)
inline VARIANT_BOOL VGCore::IVGNode::ExtendSubPaths ( struct IVGNode * Node2, VARIANT_BOOL JoinPaths ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_ExtendSubPaths(Node2, JoinPaths, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2593)
inline HRESULT VGCore::IVGNode::AveragePositionWith ( struct IVGNode * Node2, VARIANT_BOOL JoinPaths ) {
    HRESULT _hr = raw_AveragePositionWith(Node2, JoinPaths);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(2594)
inline HRESULT VGCore::IVGNode::GetPoint ( struct IVGPoint * * ppVal ) {
    HRESULT _hr = raw_GetPoint(ppVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(2595)
inline HRESULT VGCore::IVGNode::SetPoint ( struct IVGPoint * ppVal ) {
    HRESULT _hr = raw_SetPoint(ppVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface IVGSnapPoint wrapper method implementations
//

#pragma implementation_key(2596)
inline VGCore::IVGApplicationPtr VGCore::IVGSnapPoint::GetApplication ( ) {
    struct IVGApplication * _result = 0;
    HRESULT _hr = get_Application(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGApplicationPtr(_result, false);
}

#pragma implementation_key(2597)
inline VGCore::IVGShapePtr VGCore::IVGSnapPoint::GetParent ( ) {
    struct IVGShape * _result = 0;
    HRESULT _hr = get_Parent(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGShapePtr(_result, false);
}

#pragma implementation_key(2598)
inline double VGCore::IVGSnapPoint::GetPositionX ( ) {
    double _result = 0;
    HRESULT _hr = get_PositionX(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2599)
inline void VGCore::IVGSnapPoint::PutPositionX ( double pVal ) {
    HRESULT _hr = put_PositionX(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(2600)
inline double VGCore::IVGSnapPoint::GetPositionY ( ) {
    double _result = 0;
    HRESULT _hr = get_PositionY(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2601)
inline void VGCore::IVGSnapPoint::PutPositionY ( double pVal ) {
    HRESULT _hr = put_PositionY(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(2602)
inline enum VGCore::cdrPointType VGCore::IVGSnapPoint::GetType ( ) {
    enum cdrPointType _result;
    HRESULT _hr = get_Type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2603)
inline VGCore::IVGNodePtr VGCore::IVGSnapPoint::GetNode ( ) {
    struct IVGNode * _result = 0;
    HRESULT _hr = get_Node(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGNodePtr(_result, false);
}

#pragma implementation_key(2604)
inline VARIANT_BOOL VGCore::IVGSnapPoint::GetIsDeletable ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsDeletable(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2605)
inline VARIANT_BOOL VGCore::IVGSnapPoint::GetIsMovable ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsMovable(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2606)
inline VARIANT_BOOL VGCore::IVGSnapPoint::GetCanChangeDirection ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_CanChangeDirection(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2607)
inline HRESULT VGCore::IVGSnapPoint::GetPosition ( double * PositionX, double * PositionY ) {
    HRESULT _hr = raw_GetPosition(PositionX, PositionY);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(2608)
inline VARIANT_BOOL VGCore::IVGSnapPoint::GetUsesDirection ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_UsesDirection(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2609)
inline void VGCore::IVGSnapPoint::PutUsesDirection ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_UsesDirection(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(2610)
inline VARIANT_BOOL VGCore::IVGSnapPoint::GetIsSelectable ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsSelectable(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2611)
inline double VGCore::IVGSnapPoint::GetDirection ( ) {
    double _result = 0;
    HRESULT _hr = get_Direction(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2612)
inline void VGCore::IVGSnapPoint::PutDirection ( double pVal ) {
    HRESULT _hr = put_Direction(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(2613)
inline HRESULT VGCore::IVGSnapPoint::SetPosition ( double PositionX, double PositionY ) {
    HRESULT _hr = raw_SetPosition(PositionX, PositionY);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(2614)
inline VARIANT_BOOL VGCore::IVGSnapPoint::GetSelected ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_Selected(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2615)
inline void VGCore::IVGSnapPoint::PutSelected ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_Selected(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(2616)
inline HRESULT VGCore::IVGSnapPoint::CreateSelection ( ) {
    HRESULT _hr = raw_CreateSelection();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(2617)
inline VGCore::IVGUserSnapPointPtr VGCore::IVGSnapPoint::GetUser ( ) {
    struct IVGUserSnapPoint * _result = 0;
    HRESULT _hr = get_User(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGUserSnapPointPtr(_result, false);
}

#pragma implementation_key(2618)
inline VGCore::IVGObjectSnapPointPtr VGCore::IVGSnapPoint::GetObject ( ) {
    struct IVGObjectSnapPoint * _result = 0;
    HRESULT _hr = get_Object(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGObjectSnapPointPtr(_result, false);
}

#pragma implementation_key(2619)
inline VGCore::IVGShapePtr VGCore::IVGSnapPoint::GetShape ( ) {
    struct IVGShape * _result = 0;
    HRESULT _hr = get_Shape(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGShapePtr(_result, false);
}

#pragma implementation_key(2620)
inline VGCore::IVGBBoxSnapPointPtr VGCore::IVGSnapPoint::GetBBox ( ) {
    struct IVGBBoxSnapPoint * _result = 0;
    HRESULT _hr = get_BBox(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGBBoxSnapPointPtr(_result, false);
}

#pragma implementation_key(2621)
inline _bstr_t VGCore::IVGSnapPoint::GetReferenceData ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_ReferenceData(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(2622)
inline HRESULT VGCore::IVGSnapPoint::Delete ( ) {
    HRESULT _hr = raw_Delete();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(2623)
inline HRESULT VGCore::IVGSnapPoint::Move ( double OffsetX, double OffsetY ) {
    HRESULT _hr = raw_Move(OffsetX, OffsetY);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(2624)
inline VGCore::IVGEdgeSnapPointPtr VGCore::IVGSnapPoint::GetEdge ( ) {
    struct IVGEdgeSnapPoint * _result = 0;
    HRESULT _hr = get_Edge(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGEdgeSnapPointPtr(_result, false);
}

//
// interface IVGSnapPointRange wrapper method implementations
//

#pragma implementation_key(2625)
inline long VGCore::IVGSnapPointRange::GetCount ( ) {
    long _result = 0;
    HRESULT _hr = get_Count(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2626)
inline VGCore::IVGSnapPointPtr VGCore::IVGSnapPointRange::GetItem ( long Index ) {
    struct IVGSnapPoint * _result = 0;
    HRESULT _hr = get_Item(Index, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGSnapPointPtr(_result, false);
}

#pragma implementation_key(2627)
inline HRESULT VGCore::IVGSnapPointRange::Move ( double OffsetX, double OffsetY ) {
    HRESULT _hr = raw_Move(OffsetX, OffsetY);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(2628)
inline HRESULT VGCore::IVGSnapPointRange::Delete ( ) {
    HRESULT _hr = raw_Delete();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(2629)
inline IUnknownPtr VGCore::IVGSnapPointRange::Get_NewEnum ( ) {
    IUnknown * _result = 0;
    HRESULT _hr = get__NewEnum(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IUnknownPtr(_result, false);
}

#pragma implementation_key(2630)
inline VARIANT_BOOL VGCore::IVGSnapPointRange::Add ( struct IVGSnapPoint * SnapPoint ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_Add(SnapPoint, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2631)
inline VARIANT_BOOL VGCore::IVGSnapPointRange::Remove ( long Index ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_Remove(Index, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2632)
inline VARIANT_BOOL VGCore::IVGSnapPointRange::RemoveByReference ( _bstr_t ReferenceData ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_RemoveByReference(ReferenceData, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2633)
inline VGCore::IVGSnapPointPtr VGCore::IVGSnapPointRange::Find ( _bstr_t ReferenceData ) {
    struct IVGSnapPoint * _result = 0;
    HRESULT _hr = raw_Find(ReferenceData, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGSnapPointPtr(_result, false);
}

#pragma implementation_key(2634)
inline HRESULT VGCore::IVGSnapPointRange::CreateSelection ( ) {
    HRESULT _hr = raw_CreateSelection();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(2635)
inline HRESULT VGCore::IVGSnapPointRange::AddToSelection ( ) {
    HRESULT _hr = raw_AddToSelection();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(2636)
inline HRESULT VGCore::IVGSnapPointRange::RemoveFromSelection ( ) {
    HRESULT _hr = raw_RemoveFromSelection();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(2637)
inline HRESULT VGCore::IVGSnapPointRange::ChangeDirection ( double Direction, enum cdrTriState UsesDirection ) {
    HRESULT _hr = raw_ChangeDirection(Direction, UsesDirection);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(2638)
inline HRESULT VGCore::IVGSnapPointRange::SetAutoSnap ( VARIANT_BOOL AutoSnap ) {
    HRESULT _hr = raw_SetAutoSnap(AutoSnap);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface IVGSnapPoints wrapper method implementations
//

#pragma implementation_key(2639)
inline VGCore::IVGApplicationPtr VGCore::IVGSnapPoints::GetApplication ( ) {
    struct IVGApplication * _result = 0;
    HRESULT _hr = get_Application(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGApplicationPtr(_result, false);
}

#pragma implementation_key(2640)
inline VGCore::IVGShapePtr VGCore::IVGSnapPoints::GetParent ( ) {
    struct IVGShape * _result = 0;
    HRESULT _hr = get_Parent(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGShapePtr(_result, false);
}

#pragma implementation_key(2641)
inline VGCore::IVGSnapPointPtr VGCore::IVGSnapPoints::GetItem ( long Index ) {
    struct IVGSnapPoint * _result = 0;
    HRESULT _hr = get_Item(Index, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGSnapPointPtr(_result, false);
}

#pragma implementation_key(2642)
inline IUnknownPtr VGCore::IVGSnapPoints::Get_NewEnum ( ) {
    IUnknown * _result = 0;
    HRESULT _hr = get__NewEnum(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IUnknownPtr(_result, false);
}

#pragma implementation_key(2643)
inline long VGCore::IVGSnapPoints::GetCount ( ) {
    long _result = 0;
    HRESULT _hr = get_Count(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2644)
inline VGCore::IVGSnapPointPtr VGCore::IVGSnapPoints::User ( _bstr_t ID ) {
    struct IVGSnapPoint * _result = 0;
    HRESULT _hr = raw_User(ID, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGSnapPointPtr(_result, false);
}

#pragma implementation_key(2645)
inline VGCore::IVGSnapPointPtr VGCore::IVGSnapPoints::BBox ( enum cdrReferencePoint Type ) {
    struct IVGSnapPoint * _result = 0;
    HRESULT _hr = raw_BBox(Type, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGSnapPointPtr(_result, false);
}

#pragma implementation_key(2646)
inline VGCore::IVGSnapPointPtr VGCore::IVGSnapPoints::Object ( enum cdrObjectSnapPointType Type ) {
    struct IVGSnapPoint * _result = 0;
    HRESULT _hr = raw_Object(Type, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGSnapPointPtr(_result, false);
}

#pragma implementation_key(2647)
inline VGCore::IVGSnapPointPtr VGCore::IVGSnapPoints::FindClosest ( enum cdrPointType TypeSet, double PositionX, double PositionY ) {
    struct IVGSnapPoint * _result = 0;
    HRESULT _hr = raw_FindClosest(TypeSet, PositionX, PositionY, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGSnapPointPtr(_result, false);
}

#pragma implementation_key(2648)
inline VGCore::IVGSnapPointRangePtr VGCore::IVGSnapPoints::Range ( SAFEARRAY * * References ) {
    struct IVGSnapPointRange * _result = 0;
    HRESULT _hr = raw_Range(References, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGSnapPointRangePtr(_result, false);
}

#pragma implementation_key(2649)
inline VGCore::IVGSnapPointPtr VGCore::IVGSnapPoints::AddUserSnapPoint ( double PositionX, double PositionY, double Direction, VARIANT_BOOL UseDirection ) {
    struct IVGSnapPoint * _result = 0;
    HRESULT _hr = raw_AddUserSnapPoint(PositionX, PositionY, Direction, UseDirection, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGSnapPointPtr(_result, false);
}

#pragma implementation_key(2650)
inline VGCore::IVGSnapPointPtr VGCore::IVGSnapPoints::AddUserSnapPointEx ( _bstr_t ID, double PositionX, double PositionY, double Direction, VARIANT_BOOL UseDirection ) {
    struct IVGSnapPoint * _result = 0;
    HRESULT _hr = raw_AddUserSnapPointEx(ID, PositionX, PositionY, Direction, UseDirection, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGSnapPointPtr(_result, false);
}

#pragma implementation_key(2651)
inline VGCore::IVGSnapPointRangePtr VGCore::IVGSnapPoints::GetSelection ( ) {
    struct IVGSnapPointRange * _result = 0;
    HRESULT _hr = get_Selection(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGSnapPointRangePtr(_result, false);
}

#pragma implementation_key(2652)
inline HRESULT VGCore::IVGSnapPoints::ClearSelection ( ) {
    HRESULT _hr = raw_ClearSelection();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(2653)
inline VGCore::IVGSnapPointRangePtr VGCore::IVGSnapPoints::GetAll ( ) {
    struct IVGSnapPointRange * _result = 0;
    HRESULT _hr = get_All(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGSnapPointRangePtr(_result, false);
}

#pragma implementation_key(2654)
inline VGCore::IVGSnapPointPtr VGCore::IVGSnapPoints::Edge ( long SegmentIndex, double SegmentOffset ) {
    struct IVGSnapPoint * _result = 0;
    HRESULT _hr = raw_Edge(SegmentIndex, SegmentOffset, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGSnapPointPtr(_result, false);
}

#pragma implementation_key(2655)
inline VGCore::IVGSnapPointPtr VGCore::IVGSnapPoints::Auto ( ) {
    struct IVGSnapPoint * _result = 0;
    HRESULT _hr = raw_Auto(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGSnapPointPtr(_result, false);
}

//
// interface IVGConnector wrapper method implementations
//

#pragma implementation_key(2656)
inline VGCore::IVGSnapPointPtr VGCore::IVGConnector::GetStartPoint ( ) {
    struct IVGSnapPoint * _result = 0;
    HRESULT _hr = get_StartPoint(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGSnapPointPtr(_result, false);
}

#pragma implementation_key(2657)
inline void VGCore::IVGConnector::PutStartPoint ( struct IVGSnapPoint * ppVal ) {
    HRESULT _hr = put_StartPoint(ppVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(2658)
inline VGCore::IVGSnapPointPtr VGCore::IVGConnector::GetEndPoint ( ) {
    struct IVGSnapPoint * _result = 0;
    HRESULT _hr = get_EndPoint(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGSnapPointPtr(_result, false);
}

#pragma implementation_key(2659)
inline void VGCore::IVGConnector::PutEndPoint ( struct IVGSnapPoint * ppVal ) {
    HRESULT _hr = put_EndPoint(ppVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(2660)
inline enum VGCore::cdrConnectorType VGCore::IVGConnector::GetType ( ) {
    enum cdrConnectorType _result;
    HRESULT _hr = get_Type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface IVGDimensionLinear wrapper method implementations
//

#pragma implementation_key(2661)
inline enum VGCore::cdrLinearDimensionType VGCore::IVGDimensionLinear::GetType ( ) {
    enum cdrLinearDimensionType _result;
    HRESULT _hr = get_Type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2662)
inline VGCore::IVGSnapPointPtr VGCore::IVGDimensionLinear::GetPoint1 ( ) {
    struct IVGSnapPoint * _result = 0;
    HRESULT _hr = get_Point1(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGSnapPointPtr(_result, false);
}

#pragma implementation_key(2663)
inline void VGCore::IVGDimensionLinear::PutPoint1 ( struct IVGSnapPoint * ppVal ) {
    HRESULT _hr = put_Point1(ppVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(2664)
inline VGCore::IVGSnapPointPtr VGCore::IVGDimensionLinear::GetPoint2 ( ) {
    struct IVGSnapPoint * _result = 0;
    HRESULT _hr = get_Point2(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGSnapPointPtr(_result, false);
}

#pragma implementation_key(2665)
inline void VGCore::IVGDimensionLinear::PutPoint2 ( struct IVGSnapPoint * ppVal ) {
    HRESULT _hr = put_Point2(ppVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(2666)
inline VARIANT_BOOL VGCore::IVGDimensionLinear::GetTextCentered ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_TextCentered(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2667)
inline void VGCore::IVGDimensionLinear::PutTextCentered ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_TextCentered(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(2668)
inline double VGCore::IVGDimensionLinear::GetTextX ( ) {
    double _result = 0;
    HRESULT _hr = get_TextX(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2669)
inline void VGCore::IVGDimensionLinear::PutTextX ( double pVal ) {
    HRESULT _hr = put_TextX(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(2670)
inline double VGCore::IVGDimensionLinear::GetTextY ( ) {
    double _result = 0;
    HRESULT _hr = get_TextY(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2671)
inline void VGCore::IVGDimensionLinear::PutTextY ( double pVal ) {
    HRESULT _hr = put_TextY(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(2672)
inline enum VGCore::cdrDimensionStyle VGCore::IVGDimensionLinear::GetStyle ( ) {
    enum cdrDimensionStyle _result;
    HRESULT _hr = get_Style(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2673)
inline void VGCore::IVGDimensionLinear::PutStyle ( enum cdrDimensionStyle pVal ) {
    HRESULT _hr = put_Style(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(2674)
inline VARIANT_BOOL VGCore::IVGDimensionLinear::GetShowUnits ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_ShowUnits(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2675)
inline void VGCore::IVGDimensionLinear::PutShowUnits ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_ShowUnits(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(2676)
inline enum VGCore::cdrDimensionLinearUnits VGCore::IVGDimensionLinear::GetUnits ( ) {
    enum cdrDimensionLinearUnits _result;
    HRESULT _hr = get_Units(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2677)
inline void VGCore::IVGDimensionLinear::PutUnits ( enum cdrDimensionLinearUnits pVal ) {
    HRESULT _hr = put_Units(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(2678)
inline enum VGCore::cdrDimensionPlacement VGCore::IVGDimensionLinear::GetPlacement ( ) {
    enum cdrDimensionPlacement _result;
    HRESULT _hr = get_Placement(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2679)
inline void VGCore::IVGDimensionLinear::PutPlacement ( enum cdrDimensionPlacement pVal ) {
    HRESULT _hr = put_Placement(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(2680)
inline VARIANT_BOOL VGCore::IVGDimensionLinear::GetHorizontalText ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_HorizontalText(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2681)
inline void VGCore::IVGDimensionLinear::PutHorizontalText ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_HorizontalText(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(2682)
inline VARIANT_BOOL VGCore::IVGDimensionLinear::GetReverseTerminators ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_ReverseTerminators(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2683)
inline void VGCore::IVGDimensionLinear::PutReverseTerminators ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_ReverseTerminators(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(2684)
inline VARIANT_BOOL VGCore::IVGDimensionLinear::GetAutoReverseTerminators ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_AutoReverseTerminators(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2685)
inline void VGCore::IVGDimensionLinear::PutAutoReverseTerminators ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_AutoReverseTerminators(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(2686)
inline double VGCore::IVGDimensionLinear::GetReverseTerminatorLength ( ) {
    double _result = 0;
    HRESULT _hr = get_ReverseTerminatorLength(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2687)
inline VARIANT_BOOL VGCore::IVGDimensionLinear::GetUseReverseTerminatorLength ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_UseReverseTerminatorLength(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2688)
inline void VGCore::IVGDimensionLinear::PutUseReverseTerminatorLength ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_UseReverseTerminatorLength(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(2689)
inline HRESULT VGCore::IVGDimensionLinear::SetReverseTerminatorLength ( double Length ) {
    HRESULT _hr = raw_SetReverseTerminatorLength(Length);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(2690)
inline VARIANT_BOOL VGCore::IVGDimensionLinear::GetInnerDimensionLineVisible ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_InnerDimensionLineVisible(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2691)
inline void VGCore::IVGDimensionLinear::PutInnerDimensionLineVisible ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_InnerDimensionLineVisible(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IVGDimensionAngular wrapper method implementations
//

#pragma implementation_key(2692)
inline VGCore::IVGSnapPointPtr VGCore::IVGDimensionAngular::GetCenter ( ) {
    struct IVGSnapPoint * _result = 0;
    HRESULT _hr = get_Center(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGSnapPointPtr(_result, false);
}

#pragma implementation_key(2693)
inline void VGCore::IVGDimensionAngular::PutCenter ( struct IVGSnapPoint * ppVal ) {
    HRESULT _hr = put_Center(ppVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(2694)
inline VGCore::IVGSnapPointPtr VGCore::IVGDimensionAngular::GetPoint1 ( ) {
    struct IVGSnapPoint * _result = 0;
    HRESULT _hr = get_Point1(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGSnapPointPtr(_result, false);
}

#pragma implementation_key(2695)
inline void VGCore::IVGDimensionAngular::PutPoint1 ( struct IVGSnapPoint * ppVal ) {
    HRESULT _hr = put_Point1(ppVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(2696)
inline VGCore::IVGSnapPointPtr VGCore::IVGDimensionAngular::GetPoint2 ( ) {
    struct IVGSnapPoint * _result = 0;
    HRESULT _hr = get_Point2(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGSnapPointPtr(_result, false);
}

#pragma implementation_key(2697)
inline void VGCore::IVGDimensionAngular::PutPoint2 ( struct IVGSnapPoint * ppVal ) {
    HRESULT _hr = put_Point2(ppVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(2698)
inline double VGCore::IVGDimensionAngular::GetTextX ( ) {
    double _result = 0;
    HRESULT _hr = get_TextX(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2699)
inline void VGCore::IVGDimensionAngular::PutTextX ( double pVal ) {
    HRESULT _hr = put_TextX(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(2700)
inline double VGCore::IVGDimensionAngular::GetTextY ( ) {
    double _result = 0;
    HRESULT _hr = get_TextY(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2701)
inline void VGCore::IVGDimensionAngular::PutTextY ( double pVal ) {
    HRESULT _hr = put_TextY(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(2702)
inline VARIANT_BOOL VGCore::IVGDimensionAngular::GetShowUnits ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_ShowUnits(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2703)
inline void VGCore::IVGDimensionAngular::PutShowUnits ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_ShowUnits(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(2704)
inline enum VGCore::cdrDimensionAngularUnits VGCore::IVGDimensionAngular::GetUnits ( ) {
    enum cdrDimensionAngularUnits _result;
    HRESULT _hr = get_Units(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2705)
inline void VGCore::IVGDimensionAngular::PutUnits ( enum cdrDimensionAngularUnits pVal ) {
    HRESULT _hr = put_Units(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(2706)
inline VARIANT_BOOL VGCore::IVGDimensionAngular::GetClockwise ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_Clockwise(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2707)
inline void VGCore::IVGDimensionAngular::PutClockwise ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_Clockwise(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(2708)
inline VARIANT_BOOL VGCore::IVGDimensionAngular::GetInnerExtensionLinesVisible ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_InnerExtensionLinesVisible(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2709)
inline void VGCore::IVGDimensionAngular::PutInnerExtensionLinesVisible ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_InnerExtensionLinesVisible(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IVGSegment wrapper method implementations
//

#pragma implementation_key(2710)
inline VGCore::IVGApplicationPtr VGCore::IVGSegment::GetApplication ( ) {
    struct IVGApplication * _result = 0;
    HRESULT _hr = get_Application(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGApplicationPtr(_result, false);
}

#pragma implementation_key(2711)
inline VGCore::IVGCurvePtr VGCore::IVGSegment::GetParent ( ) {
    struct IVGCurve * _result = 0;
    HRESULT _hr = get_Parent(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGCurvePtr(_result, false);
}

#pragma implementation_key(2712)
inline enum VGCore::cdrSegmentType VGCore::IVGSegment::GetType ( ) {
    enum cdrSegmentType _result;
    HRESULT _hr = get_Type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2713)
inline void VGCore::IVGSegment::PutType ( enum cdrSegmentType pVal ) {
    HRESULT _hr = put_Type(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(2714)
inline VGCore::IVGSubPathPtr VGCore::IVGSegment::GetSubPath ( ) {
    struct IVGSubPath * _result = 0;
    HRESULT _hr = get_SubPath(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGSubPathPtr(_result, false);
}

#pragma implementation_key(2715)
inline double VGCore::IVGSegment::GetLength ( ) {
    double _result = 0;
    HRESULT _hr = get_Length(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2716)
inline long VGCore::IVGSegment::GetIndex ( ) {
    long _result = 0;
    HRESULT _hr = get_Index(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2717)
inline long VGCore::IVGSegment::GetSubPathIndex ( ) {
    long _result = 0;
    HRESULT _hr = get_SubPathIndex(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2718)
inline long VGCore::IVGSegment::GetAbsoluteIndex ( ) {
    long _result = 0;
    HRESULT _hr = get_AbsoluteIndex(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2719)
inline double VGCore::IVGSegment::GetStartingControlPointLength ( ) {
    double _result = 0;
    HRESULT _hr = get_StartingControlPointLength(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2720)
inline void VGCore::IVGSegment::PutStartingControlPointLength ( double pVal ) {
    HRESULT _hr = put_StartingControlPointLength(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(2721)
inline double VGCore::IVGSegment::GetStartingControlPointAngle ( ) {
    double _result = 0;
    HRESULT _hr = get_StartingControlPointAngle(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2722)
inline void VGCore::IVGSegment::PutStartingControlPointAngle ( double pVal ) {
    HRESULT _hr = put_StartingControlPointAngle(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(2723)
inline double VGCore::IVGSegment::GetEndingControlPointLength ( ) {
    double _result = 0;
    HRESULT _hr = get_EndingControlPointLength(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2724)
inline void VGCore::IVGSegment::PutEndingControlPointLength ( double pVal ) {
    HRESULT _hr = put_EndingControlPointLength(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(2725)
inline double VGCore::IVGSegment::GetEndingControlPointAngle ( ) {
    double _result = 0;
    HRESULT _hr = get_EndingControlPointAngle(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2726)
inline void VGCore::IVGSegment::PutEndingControlPointAngle ( double pVal ) {
    HRESULT _hr = put_EndingControlPointAngle(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(2727)
inline HRESULT VGCore::IVGSegment::GetPointPositionAt ( double * x, double * y, double Offset, enum cdrSegmentOffsetType OffsetType ) {
    HRESULT _hr = raw_GetPointPositionAt(x, y, Offset, OffsetType);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(2728)
inline VGCore::IVGNodePtr VGCore::IVGSegment::BreakApartAt ( double Offset, enum cdrSegmentOffsetType OffsetType ) {
    struct IVGNode * _result = 0;
    HRESULT _hr = raw_BreakApartAt(Offset, OffsetType, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGNodePtr(_result, false);
}

#pragma implementation_key(2729)
inline VGCore::IVGNodePtr VGCore::IVGSegment::AddNodeAt ( double Offset, enum cdrSegmentOffsetType OffsetType ) {
    struct IVGNode * _result = 0;
    HRESULT _hr = raw_AddNodeAt(Offset, OffsetType, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGNodePtr(_result, false);
}

#pragma implementation_key(2730)
inline double VGCore::IVGSegment::GetPerpendicularAt ( double Offset, enum cdrSegmentOffsetType OffsetType ) {
    double _result = 0;
    HRESULT _hr = raw_GetPerpendicularAt(Offset, OffsetType, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2731)
inline double VGCore::IVGSegment::GetTangentAt ( double Offset, enum cdrSegmentOffsetType OffsetType ) {
    double _result = 0;
    HRESULT _hr = raw_GetTangentAt(Offset, OffsetType, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2732)
inline VGCore::IVGCrossPointsPtr VGCore::IVGSegment::GetIntersections ( struct IVGSegment * Target, enum cdrSegmentOffsetType OffsetType ) {
    struct IVGCrossPoints * _result = 0;
    HRESULT _hr = raw_GetIntersections(Target, OffsetType, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGCrossPointsPtr(_result, false);
}

#pragma implementation_key(2733)
inline VGCore::IVGSegmentPtr VGCore::IVGSegment::Next ( ) {
    struct IVGSegment * _result = 0;
    HRESULT _hr = raw_Next(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGSegmentPtr(_result, false);
}

#pragma implementation_key(2734)
inline VGCore::IVGSegmentPtr VGCore::IVGSegment::Previous ( ) {
    struct IVGSegment * _result = 0;
    HRESULT _hr = raw_Previous(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGSegmentPtr(_result, false);
}

#pragma implementation_key(2735)
inline VGCore::IVGNodePtr VGCore::IVGSegment::GetStartNode ( ) {
    struct IVGNode * _result = 0;
    HRESULT _hr = get_StartNode(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGNodePtr(_result, false);
}

#pragma implementation_key(2736)
inline VGCore::IVGNodePtr VGCore::IVGSegment::GetEndNode ( ) {
    struct IVGNode * _result = 0;
    HRESULT _hr = get_EndNode(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGNodePtr(_result, false);
}

#pragma implementation_key(2737)
inline double VGCore::IVGSegment::GetStartingControlPointX ( ) {
    double _result = 0;
    HRESULT _hr = get_StartingControlPointX(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2738)
inline void VGCore::IVGSegment::PutStartingControlPointX ( double pVal ) {
    HRESULT _hr = put_StartingControlPointX(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(2739)
inline double VGCore::IVGSegment::GetStartingControlPointY ( ) {
    double _result = 0;
    HRESULT _hr = get_StartingControlPointY(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2740)
inline void VGCore::IVGSegment::PutStartingControlPointY ( double pVal ) {
    HRESULT _hr = put_StartingControlPointY(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(2741)
inline double VGCore::IVGSegment::GetEndingControlPointX ( ) {
    double _result = 0;
    HRESULT _hr = get_EndingControlPointX(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2742)
inline void VGCore::IVGSegment::PutEndingControlPointX ( double pVal ) {
    HRESULT _hr = put_EndingControlPointX(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(2743)
inline double VGCore::IVGSegment::GetEndingControlPointY ( ) {
    double _result = 0;
    HRESULT _hr = get_EndingControlPointY(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2744)
inline void VGCore::IVGSegment::PutEndingControlPointY ( double pVal ) {
    HRESULT _hr = put_EndingControlPointY(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(2745)
inline long VGCore::IVGSegment::GetPeaks ( double Angle, double * Offset1, double * Offset2, enum cdrSegmentOffsetType OffsetType ) {
    long _result = 0;
    HRESULT _hr = raw_GetPeaks(Angle, Offset1, Offset2, OffsetType, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2746)
inline long VGCore::IVGSegment::GetBendPoints ( double * Offset1, double * Offset2, enum cdrSegmentOffsetType OffsetType ) {
    long _result = 0;
    HRESULT _hr = raw_GetBendPoints(Offset1, Offset2, OffsetType, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2747)
inline double VGCore::IVGSegment::GetCurvatureAt ( double Offset, enum cdrSegmentOffsetType OffsetType ) {
    double _result = 0;
    HRESULT _hr = raw_GetCurvatureAt(Offset, OffsetType, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2748)
inline double VGCore::IVGSegment::GetCurveSpeedAt ( double Offset, enum cdrSegmentOffsetType OffsetType ) {
    double _result = 0;
    HRESULT _hr = raw_GetCurveSpeedAt(Offset, OffsetType, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2749)
inline VARIANT_BOOL VGCore::IVGSegment::FindParamOffset ( double AbsoluteOffset, double * ParamOffset, double * Remainder ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_FindParamOffset(AbsoluteOffset, ParamOffset, Remainder, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2750)
inline double VGCore::IVGSegment::GetAbsoluteOffset ( double ParamOffset ) {
    double _result = 0;
    HRESULT _hr = raw_GetAbsoluteOffset(ParamOffset, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2751)
inline HRESULT VGCore::IVGSegment::GetStartingControlPointPosition ( double * PositionX, double * PositionY ) {
    HRESULT _hr = raw_GetStartingControlPointPosition(PositionX, PositionY);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(2752)
inline HRESULT VGCore::IVGSegment::SetStartingControlPointPosition ( double PositionX, double PositionY ) {
    HRESULT _hr = raw_SetStartingControlPointPosition(PositionX, PositionY);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(2753)
inline HRESULT VGCore::IVGSegment::GetEndingControlPointPosition ( double * PositionX, double * PositionY ) {
    HRESULT _hr = raw_GetEndingControlPointPosition(PositionX, PositionY);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(2754)
inline HRESULT VGCore::IVGSegment::SetEndingControlPointPosition ( double PositionX, double PositionY ) {
    HRESULT _hr = raw_SetEndingControlPointPosition(PositionX, PositionY);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(2755)
inline VGCore::IVGCurvePtr VGCore::IVGSegment::GetCopy ( ) {
    struct IVGCurve * _result = 0;
    HRESULT _hr = raw_GetCopy(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGCurvePtr(_result, false);
}

#pragma implementation_key(2756)
inline VARIANT_BOOL VGCore::IVGSegment::GetSelected ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_Selected(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2757)
inline void VGCore::IVGSegment::PutSelected ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_Selected(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(2758)
inline HRESULT VGCore::IVGSegment::CreateSelection ( ) {
    HRESULT _hr = raw_CreateSelection();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(2759)
inline VGCore::IVGCurvePtr VGCore::IVGSegment::GetPolyline ( long CurvePrecision ) {
    struct IVGCurve * _result = 0;
    HRESULT _hr = raw_GetPolyline(CurvePrecision, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGCurvePtr(_result, false);
}

#pragma implementation_key(2760)
inline VARIANT_BOOL VGCore::IVGSegment::IsRectOnEdge ( double x1, double y1, double x2, double y2 ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_IsRectOnEdge(x1, y1, x2, y2, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2761)
inline VARIANT_BOOL VGCore::IVGSegment::FindClosestPoint ( double x, double y, double * ParamOffset ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_FindClosestPoint(x, y, ParamOffset, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2762)
inline VARIANT_BOOL VGCore::IVGSegment::FindParamOffsetAtPoint ( double x, double y, double * ParamOffset, double HotArea ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_FindParamOffsetAtPoint(x, y, ParamOffset, HotArea, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2763)
inline VARIANT_BOOL VGCore::IVGSegment::GetBoundingBox ( double * x, double * y, double * Width, double * Height ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_GetBoundingBox(x, y, Width, Height, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2764)
inline VGCore::IVGRectPtr VGCore::IVGSegment::GetBoundingBox ( ) {
    struct IVGRect * _result = 0;
    HRESULT _hr = get_BoundingBox(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGRectPtr(_result, false);
}

#pragma implementation_key(2765)
inline VGCore::IVGVectorPtr VGCore::IVGSegment::GetPerpendicularVectorAt ( double Offset, enum cdrSegmentOffsetType OffsetType, VARIANT_BOOL Normalize ) {
    struct IVGVector * _result = 0;
    HRESULT _hr = raw_GetPerpendicularVectorAt(Offset, OffsetType, Normalize, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGVectorPtr(_result, false);
}

#pragma implementation_key(2766)
inline VGCore::IVGVectorPtr VGCore::IVGSegment::GetTangentVectorAt ( double Offset, enum cdrSegmentOffsetType OffsetType, VARIANT_BOOL Normalize ) {
    struct IVGVector * _result = 0;
    HRESULT _hr = raw_GetTangentVectorAt(Offset, OffsetType, Normalize, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGVectorPtr(_result, false);
}

#pragma implementation_key(2767)
inline VGCore::IVGPointPtr VGCore::IVGSegment::GetPointAt ( double Offset, enum cdrSegmentOffsetType OffsetType ) {
    struct IVGPoint * _result = 0;
    HRESULT _hr = raw_GetPointAt(Offset, OffsetType, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGPointPtr(_result, false);
}

//
// interface IVGVector wrapper method implementations
//

#pragma implementation_key(2768)
inline double VGCore::IVGVector::Getx ( ) {
    double _result = 0;
    HRESULT _hr = get_x(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2769)
inline void VGCore::IVGVector::Putx ( double pVal ) {
    HRESULT _hr = put_x(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(2770)
inline double VGCore::IVGVector::Gety ( ) {
    double _result = 0;
    HRESULT _hr = get_y(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2771)
inline void VGCore::IVGVector::Puty ( double pVal ) {
    HRESULT _hr = put_y(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(2772)
inline double VGCore::IVGVector::GetLength ( ) {
    double _result = 0;
    HRESULT _hr = get_Length(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2773)
inline void VGCore::IVGVector::PutLength ( double pVal ) {
    HRESULT _hr = put_Length(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(2774)
inline double VGCore::IVGVector::GetAngle ( ) {
    double _result = 0;
    HRESULT _hr = get_Angle(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2775)
inline void VGCore::IVGVector::PutAngle ( double pVal ) {
    HRESULT _hr = put_Angle(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(2776)
inline VGCore::IVGPointPtr VGCore::IVGVector::GetOffsettedPoint ( struct IVGPoint * Origin, double Distance ) {
    struct IVGPoint * _result = 0;
    HRESULT _hr = raw_GetOffsettedPoint(Origin, Distance, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGPointPtr(_result, false);
}

#pragma implementation_key(2777)
inline HRESULT VGCore::IVGVector::Add ( struct IVGVector * Vector ) {
    HRESULT _hr = raw_Add(Vector);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(2778)
inline HRESULT VGCore::IVGVector::Subtract ( struct IVGVector * Vector ) {
    HRESULT _hr = raw_Subtract(Vector);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(2779)
inline HRESULT VGCore::IVGVector::MultiplyBy ( double Multiplier ) {
    HRESULT _hr = raw_MultiplyBy(Multiplier);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(2780)
inline HRESULT VGCore::IVGVector::Negate ( ) {
    HRESULT _hr = raw_Negate();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(2781)
inline HRESULT VGCore::IVGVector::Normalize ( ) {
    HRESULT _hr = raw_Normalize();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(2782)
inline double VGCore::IVGVector::AngleBetween ( struct IVGVector * Vector ) {
    double _result = 0;
    HRESULT _hr = raw_AngleBetween(Vector, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2783)
inline double VGCore::IVGVector::SmallAngleBetween ( struct IVGVector * Vector ) {
    double _result = 0;
    HRESULT _hr = raw_SmallAngleBetween(Vector, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2784)
inline double VGCore::IVGVector::DotProduct ( struct IVGVector * Vector ) {
    double _result = 0;
    HRESULT _hr = raw_DotProduct(Vector, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2785)
inline double VGCore::IVGVector::CrossProduct ( struct IVGVector * Vector ) {
    double _result = 0;
    HRESULT _hr = raw_CrossProduct(Vector, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2786)
inline HRESULT VGCore::IVGVector::SetFromPoints ( struct IVGPoint * Start, struct IVGPoint * End ) {
    HRESULT _hr = raw_SetFromPoints(Start, End);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(2787)
inline VGCore::IVGVectorPtr VGCore::IVGVector::ProjectOnto ( struct IVGVector * Vector ) {
    struct IVGVector * _result = 0;
    HRESULT _hr = raw_ProjectOnto(Vector, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGVectorPtr(_result, false);
}

#pragma implementation_key(2788)
inline VGCore::IVGVectorPtr VGCore::IVGVector::GetCopy ( ) {
    struct IVGVector * _result = 0;
    HRESULT _hr = raw_GetCopy(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGVectorPtr(_result, false);
}

#pragma implementation_key(2789)
inline HRESULT VGCore::IVGVector::BindToDocument ( struct IVGDocument * Document ) {
    HRESULT _hr = raw_BindToDocument(Document);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface IVGPoint wrapper method implementations
//

#pragma implementation_key(2790)
inline double VGCore::IVGPoint::Getx ( ) {
    double _result = 0;
    HRESULT _hr = get_x(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2791)
inline void VGCore::IVGPoint::Putx ( double pVal ) {
    HRESULT _hr = put_x(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(2792)
inline double VGCore::IVGPoint::Gety ( ) {
    double _result = 0;
    HRESULT _hr = get_y(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2793)
inline void VGCore::IVGPoint::Puty ( double pVal ) {
    HRESULT _hr = put_y(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(2794)
inline HRESULT VGCore::IVGPoint::Add ( struct IVGVector * Vector ) {
    HRESULT _hr = raw_Add(Vector);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(2795)
inline HRESULT VGCore::IVGPoint::Subtract ( struct IVGVector * Vector ) {
    HRESULT _hr = raw_Subtract(Vector);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(2796)
inline double VGCore::IVGPoint::DistanceTo ( struct IVGPoint * Point ) {
    double _result = 0;
    HRESULT _hr = raw_DistanceTo(Point, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2797)
inline VGCore::IVGPointPtr VGCore::IVGPoint::GetCopy ( ) {
    struct IVGPoint * _result = 0;
    HRESULT _hr = raw_GetCopy(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGPointPtr(_result, false);
}

#pragma implementation_key(2798)
inline HRESULT VGCore::IVGPoint::BindToDocument ( struct IVGDocument * Document ) {
    HRESULT _hr = raw_BindToDocument(Document);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface IVGPointRange wrapper method implementations
//

#pragma implementation_key(2799)
inline VGCore::IVGPointPtr VGCore::IVGPointRange::GetItem ( long Index ) {
    struct IVGPoint * _result = 0;
    HRESULT _hr = get_Item(Index, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGPointPtr(_result, false);
}

#pragma implementation_key(2800)
inline void VGCore::IVGPointRange::PutItem ( long Index, struct IVGPoint * ppVal ) {
    HRESULT _hr = put_Item(Index, ppVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(2801)
inline IUnknownPtr VGCore::IVGPointRange::Get_NewEnum ( ) {
    IUnknown * _result = 0;
    HRESULT _hr = get__NewEnum(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IUnknownPtr(_result, false);
}

#pragma implementation_key(2802)
inline VGCore::IVGPointPtr VGCore::IVGPointRange::GetFirst ( ) {
    struct IVGPoint * _result = 0;
    HRESULT _hr = get_First(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGPointPtr(_result, false);
}

#pragma implementation_key(2803)
inline VGCore::IVGPointPtr VGCore::IVGPointRange::GetLast ( ) {
    struct IVGPoint * _result = 0;
    HRESULT _hr = get_Last(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGPointPtr(_result, false);
}

#pragma implementation_key(2804)
inline long VGCore::IVGPointRange::GetCount ( ) {
    long _result = 0;
    HRESULT _hr = get_Count(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2805)
inline HRESULT VGCore::IVGPointRange::AddPoint ( struct IVGPoint * Point ) {
    HRESULT _hr = raw_AddPoint(Point);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(2806)
inline HRESULT VGCore::IVGPointRange::AddPointXY ( double x, double y ) {
    HRESULT _hr = raw_AddPointXY(x, y);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(2807)
inline HRESULT VGCore::IVGPointRange::InsertPoint ( long Index, struct IVGPoint * Point ) {
    HRESULT _hr = raw_InsertPoint(Index, Point);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(2808)
inline HRESULT VGCore::IVGPointRange::AddPoints ( struct IVGPointRange * Points ) {
    HRESULT _hr = raw_AddPoints(Points);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(2809)
inline HRESULT VGCore::IVGPointRange::InsertPoints ( long Index, struct IVGPointRange * Points ) {
    HRESULT _hr = raw_InsertPoints(Index, Points);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(2810)
inline HRESULT VGCore::IVGPointRange::Remove ( long Index ) {
    HRESULT _hr = raw_Remove(Index);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(2811)
inline HRESULT VGCore::IVGPointRange::RemoveRange ( long StartIndex, long EndIndex ) {
    HRESULT _hr = raw_RemoveRange(StartIndex, EndIndex);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(2812)
inline HRESULT VGCore::IVGPointRange::RemoveAll ( ) {
    HRESULT _hr = raw_RemoveAll();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(2813)
inline HRESULT VGCore::IVGPointRange::RemoveAdjacentDuplicates ( ) {
    HRESULT _hr = raw_RemoveAdjacentDuplicates();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(2814)
inline HRESULT VGCore::IVGPointRange::Reverse ( ) {
    HRESULT _hr = raw_Reverse();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(2815)
inline HRESULT VGCore::IVGPointRange::Smoothen ( double NumberOfPointsToSmoothAcross, VARIANT_BOOL Closed ) {
    HRESULT _hr = raw_Smoothen(NumberOfPointsToSmoothAcross, Closed);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(2816)
inline VGCore::IVGPointRangePtr VGCore::IVGPointRange::GetCopy ( ) {
    struct IVGPointRange * _result = 0;
    HRESULT _hr = raw_GetCopy(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGPointRangePtr(_result, false);
}

#pragma implementation_key(2817)
inline HRESULT VGCore::IVGPointRange::BindToDocument ( struct IVGDocument * Document ) {
    HRESULT _hr = raw_BindToDocument(Document);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface IVGTransformMatrix wrapper method implementations
//

#pragma implementation_key(2818)
inline double VGCore::IVGTransformMatrix::Getd11 ( ) {
    double _result = 0;
    HRESULT _hr = get_d11(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2819)
inline void VGCore::IVGTransformMatrix::Putd11 ( double pVal ) {
    HRESULT _hr = put_d11(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(2820)
inline double VGCore::IVGTransformMatrix::Getd12 ( ) {
    double _result = 0;
    HRESULT _hr = get_d12(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2821)
inline void VGCore::IVGTransformMatrix::Putd12 ( double pVal ) {
    HRESULT _hr = put_d12(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(2822)
inline double VGCore::IVGTransformMatrix::Getd21 ( ) {
    double _result = 0;
    HRESULT _hr = get_d21(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2823)
inline void VGCore::IVGTransformMatrix::Putd21 ( double pVal ) {
    HRESULT _hr = put_d21(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(2824)
inline double VGCore::IVGTransformMatrix::Getd22 ( ) {
    double _result = 0;
    HRESULT _hr = get_d22(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2825)
inline void VGCore::IVGTransformMatrix::Putd22 ( double pVal ) {
    HRESULT _hr = put_d22(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(2826)
inline double VGCore::IVGTransformMatrix::GetTranslationX ( ) {
    double _result = 0;
    HRESULT _hr = get_TranslationX(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2827)
inline void VGCore::IVGTransformMatrix::PutTranslationX ( double pVal ) {
    HRESULT _hr = put_TranslationX(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(2828)
inline double VGCore::IVGTransformMatrix::GetTranslationY ( ) {
    double _result = 0;
    HRESULT _hr = get_TranslationY(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2829)
inline void VGCore::IVGTransformMatrix::PutTranslationY ( double pVal ) {
    HRESULT _hr = put_TranslationY(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(2830)
inline VGCore::IVGVectorPtr VGCore::IVGTransformMatrix::GetTranslation ( ) {
    struct IVGVector * _result = 0;
    HRESULT _hr = get_Translation(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGVectorPtr(_result, false);
}

#pragma implementation_key(2831)
inline void VGCore::IVGTransformMatrix::PutTranslation ( struct IVGVector * ppVal ) {
    HRESULT _hr = put_Translation(ppVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(2832)
inline HRESULT VGCore::IVGTransformMatrix::SetToIdentity ( ) {
    HRESULT _hr = raw_SetToIdentity();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(2833)
inline HRESULT VGCore::IVGTransformMatrix::Invert ( ) {
    HRESULT _hr = raw_Invert();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(2834)
inline HRESULT VGCore::IVGTransformMatrix::TranslateBy ( double x, double y ) {
    HRESULT _hr = raw_TranslateBy(x, y);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(2835)
inline HRESULT VGCore::IVGTransformMatrix::TranslateByVector ( struct IVGVector * Vector ) {
    HRESULT _hr = raw_TranslateByVector(Vector);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(2836)
inline HRESULT VGCore::IVGTransformMatrix::SetTranslation ( double x, double y ) {
    HRESULT _hr = raw_SetTranslation(x, y);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(2837)
inline HRESULT VGCore::IVGTransformMatrix::Rotate ( double Angle ) {
    HRESULT _hr = raw_Rotate(Angle);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(2838)
inline HRESULT VGCore::IVGTransformMatrix::RotateAround ( double Angle, double x, double y ) {
    HRESULT _hr = raw_RotateAround(Angle, x, y);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(2839)
inline HRESULT VGCore::IVGTransformMatrix::Scale ( double ScaleX, double ScaleY ) {
    HRESULT _hr = raw_Scale(ScaleX, ScaleY);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(2840)
inline HRESULT VGCore::IVGTransformMatrix::ScaleAround ( double ScaleX, double ScaleY, double x, double y ) {
    HRESULT _hr = raw_ScaleAround(ScaleX, ScaleY, x, y);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(2841)
inline HRESULT VGCore::IVGTransformMatrix::Transform ( struct IVGTransformMatrix * TransformMatrix ) {
    HRESULT _hr = raw_Transform(TransformMatrix);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(2842)
inline HRESULT VGCore::IVGTransformMatrix::TransformAround ( struct IVGTransformMatrix * TransformMatrix, double x, double y ) {
    HRESULT _hr = raw_TransformAround(TransformMatrix, x, y);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(2843)
inline HRESULT VGCore::IVGTransformMatrix::TransformPoint ( struct IVGPoint * Point ) {
    HRESULT _hr = raw_TransformPoint(Point);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(2844)
inline HRESULT VGCore::IVGTransformMatrix::TransformPoints ( struct IVGPointRange * Points ) {
    HRESULT _hr = raw_TransformPoints(Points);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(2845)
inline HRESULT VGCore::IVGTransformMatrix::TransformVector ( struct IVGVector * Vector ) {
    HRESULT _hr = raw_TransformVector(Vector);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(2846)
inline HRESULT VGCore::IVGTransformMatrix::UntransformPoint ( struct IVGPoint * Point ) {
    HRESULT _hr = raw_UntransformPoint(Point);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(2847)
inline HRESULT VGCore::IVGTransformMatrix::UntransformPoints ( struct IVGPointRange * Points ) {
    HRESULT _hr = raw_UntransformPoints(Points);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(2848)
inline HRESULT VGCore::IVGTransformMatrix::UntransformVector ( struct IVGVector * Vector ) {
    HRESULT _hr = raw_UntransformVector(Vector);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(2849)
inline VARIANT_BOOL VGCore::IVGTransformMatrix::GetIsIdentity ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsIdentity(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2850)
inline VARIANT_BOOL VGCore::IVGTransformMatrix::GetIsSkewedOrRotatedOrMirrored ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsSkewedOrRotatedOrMirrored(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2851)
inline VARIANT_BOOL VGCore::IVGTransformMatrix::GetContainsOnlyTranslation ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_ContainsOnlyTranslation(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2852)
inline VARIANT_BOOL VGCore::IVGTransformMatrix::GetIsSkewedOrRotated ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsSkewedOrRotated(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2853)
inline VARIANT_BOOL VGCore::IVGTransformMatrix::GetIsScaledOrSkewedOrRotated ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsScaledOrSkewedOrRotated(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2854)
inline VARIANT_BOOL VGCore::IVGTransformMatrix::GetIsOrthogonal ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsOrthogonal(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2855)
inline VARIANT_BOOL VGCore::IVGTransformMatrix::GetIsOrthonormalAxisAligned ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsOrthonormalAxisAligned(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2856)
inline VARIANT_BOOL VGCore::IVGTransformMatrix::GetIsOrthonormal ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsOrthonormal(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2857)
inline VARIANT_BOOL VGCore::IVGTransformMatrix::GetIsMirrored ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsMirrored(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2858)
inline VARIANT_BOOL VGCore::IVGTransformMatrix::GetIsScaled ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsScaled(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2859)
inline VARIANT_BOOL VGCore::IVGTransformMatrix::GetIsTranslated ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsTranslated(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2860)
inline VGCore::IVGTransformMatrixPtr VGCore::IVGTransformMatrix::GetCopy ( ) {
    struct IVGTransformMatrix * _result = 0;
    HRESULT _hr = raw_GetCopy(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGTransformMatrixPtr(_result, false);
}

#pragma implementation_key(2861)
inline HRESULT VGCore::IVGTransformMatrix::BindToDocument ( struct IVGDocument * Document ) {
    HRESULT _hr = raw_BindToDocument(Document);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface IVGProperties wrapper method implementations
//

#pragma implementation_key(2862)
inline _variant_t VGCore::IVGProperties::GetItem ( _bstr_t Name, long ID ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = get_Item(Name, ID, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

#pragma implementation_key(2863)
inline void VGCore::IVGProperties::PutItem ( _bstr_t Name, long ID, const _variant_t & pVal ) {
    HRESULT _hr = put_Item(Name, ID, pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(2864)
inline IUnknownPtr VGCore::IVGProperties::Get_NewEnum ( ) {
    IUnknown * _result = 0;
    HRESULT _hr = get__NewEnum(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IUnknownPtr(_result, false);
}

#pragma implementation_key(2865)
inline long VGCore::IVGProperties::GetIndex ( _bstr_t Name, long ID ) {
    long _result = 0;
    HRESULT _hr = get_Index(Name, ID, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2866)
inline _variant_t VGCore::IVGProperties::GetItemByIndex ( long Index ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = get_ItemByIndex(Index, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

#pragma implementation_key(2867)
inline HRESULT VGCore::IVGProperties::Delete ( _bstr_t Name, long ID ) {
    HRESULT _hr = raw_Delete(Name, ID);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(2868)
inline HRESULT VGCore::IVGProperties::DeleteByIndex ( long Index ) {
    HRESULT _hr = raw_DeleteByIndex(Index);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(2869)
inline long VGCore::IVGProperties::GetCount ( ) {
    long _result = 0;
    HRESULT _hr = get_Count(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2870)
inline HRESULT VGCore::IVGProperties::Description ( long Index, BSTR * Name, long * ID ) {
    HRESULT _hr = raw_Description(Index, Name, ID);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(2871)
inline HRESULT VGCore::IVGProperties::PutFile ( _bstr_t Name, long ID, _bstr_t FileName ) {
    HRESULT _hr = raw_PutFile(Name, ID, FileName);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(2872)
inline HRESULT VGCore::IVGProperties::GetFile ( _bstr_t Name, long ID, _bstr_t FileName ) {
    HRESULT _hr = raw_GetFile(Name, ID, FileName);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(2873)
inline VARIANT_BOOL VGCore::IVGProperties::Exists ( _bstr_t Name, long ID ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_Exists(Name, ID, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2874)
inline VARIANT_BOOL VGCore::IVGProperties::DeleteAll ( _bstr_t Name ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_DeleteAll(Name, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2875)
inline VGCore::IVGPointPtr VGCore::IVGProperties::GetPoint ( _bstr_t uuidName ) {
    struct IVGPoint * _result = 0;
    HRESULT _hr = raw_GetPoint(uuidName, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGPointPtr(_result, false);
}

#pragma implementation_key(2876)
inline HRESULT VGCore::IVGProperties::SetPoint ( _bstr_t uuidName, struct IVGPoint * pVal ) {
    HRESULT _hr = raw_SetPoint(uuidName, pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(2877)
inline VGCore::IVGVectorPtr VGCore::IVGProperties::GetVector ( _bstr_t uuidName ) {
    struct IVGVector * _result = 0;
    HRESULT _hr = raw_GetVector(uuidName, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGVectorPtr(_result, false);
}

#pragma implementation_key(2878)
inline HRESULT VGCore::IVGProperties::SetVector ( _bstr_t uuidName, struct IVGVector * pVal ) {
    HRESULT _hr = raw_SetVector(uuidName, pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(2879)
inline VGCore::IVGCurvePtr VGCore::IVGProperties::GetCurve ( _bstr_t uuidName ) {
    struct IVGCurve * _result = 0;
    HRESULT _hr = raw_GetCurve(uuidName, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGCurvePtr(_result, false);
}

#pragma implementation_key(2880)
inline HRESULT VGCore::IVGProperties::SetCurve ( _bstr_t uuidName, struct IVGCurve * pVal ) {
    HRESULT _hr = raw_SetCurve(uuidName, pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface IVGToolStateAttributes wrapper method implementations
//

#pragma implementation_key(2881)
inline _bstr_t VGCore::IVGToolStateAttributes::GetPropertyBarGuid ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_PropertyBarGuid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(2882)
inline void VGCore::IVGToolStateAttributes::PutPropertyBarGuid ( _bstr_t pVal ) {
    HRESULT _hr = put_PropertyBarGuid(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(2883)
inline _bstr_t VGCore::IVGToolStateAttributes::GetContextMenuGuid ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_ContextMenuGuid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(2884)
inline void VGCore::IVGToolStateAttributes::PutContextMenuGuid ( _bstr_t pVal ) {
    HRESULT _hr = put_ContextMenuGuid(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(2885)
inline VARIANT_BOOL VGCore::IVGToolStateAttributes::GetUseTabletPressure ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_UseTabletPressure(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2886)
inline void VGCore::IVGToolStateAttributes::PutUseTabletPressure ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_UseTabletPressure(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(2887)
inline VARIANT_BOOL VGCore::IVGToolStateAttributes::GetAllowTempPickState ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_AllowTempPickState(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2888)
inline void VGCore::IVGToolStateAttributes::PutAllowTempPickState ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_AllowTempPickState(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(2889)
inline VARIANT_BOOL VGCore::IVGToolStateAttributes::GetAllowAutopan ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_AllowAutopan(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2890)
inline void VGCore::IVGToolStateAttributes::PutAllowAutopan ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_AllowAutopan(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(2891)
inline VARIANT_BOOL VGCore::IVGToolStateAttributes::GetAllowContextMenu ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_AllowContextMenu(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2892)
inline void VGCore::IVGToolStateAttributes::PutAllowContextMenu ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_AllowContextMenu(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(2893)
inline VARIANT_BOOL VGCore::IVGToolStateAttributes::GetCanUpdateSelectionOnMouseClick ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_CanUpdateSelectionOnMouseClick(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2894)
inline void VGCore::IVGToolStateAttributes::PutCanUpdateSelectionOnMouseClick ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_CanUpdateSelectionOnMouseClick(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(2895)
inline VARIANT_BOOL VGCore::IVGToolStateAttributes::GetDeselectOnLButtonDown ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_DeselectOnLButtonDown(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2896)
inline void VGCore::IVGToolStateAttributes::PutDeselectOnLButtonDown ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_DeselectOnLButtonDown(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(2897)
inline VARIANT_BOOL VGCore::IVGToolStateAttributes::GetEnterGraceStateOnLButtonDown ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_EnterGraceStateOnLButtonDown(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2898)
inline void VGCore::IVGToolStateAttributes::PutEnterGraceStateOnLButtonDown ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_EnterGraceStateOnLButtonDown(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(2899)
inline void VGCore::IVGToolStateAttributes::PutStatusInfo ( _bstr_t _arg1 ) {
    HRESULT _hr = put_StatusInfo(_arg1);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(2900)
inline HRESULT VGCore::IVGToolStateAttributes::SetCursor ( enum cdrCursorShape CursorShape ) {
    HRESULT _hr = raw_SetCursor(CursorShape);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(2901)
inline HRESULT VGCore::IVGToolStateAttributes::StartTimer ( long TimerId, long TimeToTick, VARIANT_BOOL OneTime ) {
    HRESULT _hr = raw_StartTimer(TimerId, TimeToTick, OneTime);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(2902)
inline HRESULT VGCore::IVGToolStateAttributes::StopTimer ( long TimerId ) {
    HRESULT _hr = raw_StopTimer(TimerId);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(2903)
inline HRESULT VGCore::IVGToolStateAttributes::SnapMouse ( struct IVGPoint * pt ) {
    HRESULT _hr = raw_SnapMouse(pt);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(2904)
inline HRESULT VGCore::IVGToolStateAttributes::AnchoredSnapMouse ( struct IVGPoint * pt, struct IVGPoint * AnchorPoint ) {
    HRESULT _hr = raw_AnchoredSnapMouse(pt, AnchorPoint);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(2905)
inline HRESULT VGCore::IVGToolStateAttributes::ConstrainMouse ( struct IVGPoint * pt, struct IVGPoint * AnchorPoint ) {
    HRESULT _hr = raw_ConstrainMouse(pt, AnchorPoint);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(2906)
inline VARIANT_BOOL VGCore::IVGToolStateAttributes::IsKeyDown ( long KeyCode ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_IsKeyDown(KeyCode, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2907)
inline double VGCore::IVGToolStateAttributes::GetCurrentPressure ( ) {
    double _result = 0;
    HRESULT _hr = get_CurrentPressure(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2908)
inline HRESULT VGCore::IVGToolStateAttributes::SetCursorGuid ( _bstr_t newVal ) {
    HRESULT _hr = raw_SetCursorGuid(newVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(2909)
inline HRESULT VGCore::IVGToolStateAttributes::SetStateHintsPage ( _bstr_t newVal ) {
    HRESULT _hr = raw_SetStateHintsPage(newVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(2910)
inline HRESULT VGCore::IVGToolStateAttributes::ExitTemporaryToolState ( ) {
    HRESULT _hr = raw_ExitTemporaryToolState();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(2911)
inline VGCore::IVGDocumentPtr VGCore::IVGToolStateAttributes::GetDocument ( ) {
    struct IVGDocument * _result = 0;
    HRESULT _hr = get_Document(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGDocumentPtr(_result, false);
}

#pragma implementation_key(2912)
inline HRESULT VGCore::IVGToolStateAttributes::SetFocus ( ) {
    HRESULT _hr = raw_SetFocus();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(2913)
inline HRESULT VGCore::IVGToolStateAttributes::CaptureMouse ( ) {
    HRESULT _hr = raw_CaptureMouse();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(2914)
inline HRESULT VGCore::IVGToolStateAttributes::ReleaseMouse ( ) {
    HRESULT _hr = raw_ReleaseMouse();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface IVGToolState wrapper method implementations
//

#pragma implementation_key(2915)
inline HRESULT VGCore::IVGToolState::OnStartState ( struct IVGToolStateAttributes * StateAttributes ) {
    HRESULT _hr = raw_OnStartState(StateAttributes);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(2916)
inline HRESULT VGCore::IVGToolState::OnExitState ( ) {
    HRESULT _hr = raw_OnExitState();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(2917)
inline HRESULT VGCore::IVGToolState::OnMouseMove ( struct IVGPoint * pt ) {
    HRESULT _hr = raw_OnMouseMove(pt);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(2918)
inline HRESULT VGCore::IVGToolState::OnLButtonDown ( struct IVGPoint * pt ) {
    HRESULT _hr = raw_OnLButtonDown(pt);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(2919)
inline HRESULT VGCore::IVGToolState::OnLButtonDownLeaveGrace ( struct IVGPoint * pt ) {
    HRESULT _hr = raw_OnLButtonDownLeaveGrace(pt);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(2920)
inline HRESULT VGCore::IVGToolState::OnLButtonUp ( struct IVGPoint * pt ) {
    HRESULT _hr = raw_OnLButtonUp(pt);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(2921)
inline HRESULT VGCore::IVGToolState::OnLButtonDblClick ( struct IVGPoint * pt ) {
    HRESULT _hr = raw_OnLButtonDblClick(pt);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(2922)
inline HRESULT VGCore::IVGToolState::OnClick ( struct IVGPoint * pt, VARIANT_BOOL * Handled ) {
    HRESULT _hr = raw_OnClick(pt, Handled);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(2923)
inline HRESULT VGCore::IVGToolState::OnRButtonDown ( struct IVGPoint * pt, VARIANT_BOOL * Handled ) {
    HRESULT _hr = raw_OnRButtonDown(pt, Handled);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(2924)
inline HRESULT VGCore::IVGToolState::OnRButtonUp ( struct IVGPoint * pt, VARIANT_BOOL * Handled ) {
    HRESULT _hr = raw_OnRButtonUp(pt, Handled);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(2925)
inline HRESULT VGCore::IVGToolState::OnKeyDown ( long KeyCode, VARIANT_BOOL * Handled ) {
    HRESULT _hr = raw_OnKeyDown(KeyCode, Handled);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(2926)
inline HRESULT VGCore::IVGToolState::OnKeyUp ( long KeyCode, VARIANT_BOOL * Handled ) {
    HRESULT _hr = raw_OnKeyUp(KeyCode, Handled);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(2927)
inline HRESULT VGCore::IVGToolState::OnDelete ( VARIANT_BOOL * Handled ) {
    HRESULT _hr = raw_OnDelete(Handled);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(2928)
inline HRESULT VGCore::IVGToolState::OnAbort ( ) {
    HRESULT _hr = raw_OnAbort();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(2929)
inline HRESULT VGCore::IVGToolState::OnCommit ( struct IVGPoint * pt ) {
    HRESULT _hr = raw_OnCommit(pt);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(2930)
inline HRESULT VGCore::IVGToolState::OnSnapMouse ( struct IVGPoint * pt, VARIANT_BOOL * Handled ) {
    HRESULT _hr = raw_OnSnapMouse(pt, Handled);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(2931)
inline HRESULT VGCore::IVGToolState::OnTimer ( long TimerId, long TimeEllapsed ) {
    HRESULT _hr = raw_OnTimer(TimerId, TimeEllapsed);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(2932)
inline VARIANT_BOOL VGCore::IVGToolState::GetIsDrawing ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsDrawing(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface IVGOnScreenCurve wrapper method implementations
//

#pragma implementation_key(2933)
inline HRESULT VGCore::IVGOnScreenCurve::Show ( ) {
    HRESULT _hr = raw_Show();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(2934)
inline HRESULT VGCore::IVGOnScreenCurve::Hide ( ) {
    HRESULT _hr = raw_Hide();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(2935)
inline HRESULT VGCore::IVGOnScreenCurve::SetPen ( long Color, long WidthInPixels, enum cdrOnScreenCurvePenStyle Style ) {
    HRESULT _hr = raw_SetPen(Color, WidthInPixels, Style);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(2936)
inline HRESULT VGCore::IVGOnScreenCurve::SetNoPen ( ) {
    HRESULT _hr = raw_SetNoPen();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(2937)
inline HRESULT VGCore::IVGOnScreenCurve::SetBrush ( long Color ) {
    HRESULT _hr = raw_SetBrush(Color);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(2938)
inline HRESULT VGCore::IVGOnScreenCurve::SetNoBrush ( ) {
    HRESULT _hr = raw_SetNoBrush();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(2939)
inline HRESULT VGCore::IVGOnScreenCurve::SetCurve ( struct IVGCurve * Curve ) {
    HRESULT _hr = raw_SetCurve(Curve);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(2940)
inline HRESULT VGCore::IVGOnScreenCurve::SetLine ( double x1, double y1, double x2, double y2 ) {
    HRESULT _hr = raw_SetLine(x1, y1, x2, y2);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(2941)
inline HRESULT VGCore::IVGOnScreenCurve::SetRectangle ( double x1, double y1, double x2, double y2 ) {
    HRESULT _hr = raw_SetRectangle(x1, y1, x2, y2);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(2942)
inline HRESULT VGCore::IVGOnScreenCurve::SetCircle ( double CenterX, double CenterY, double Radius ) {
    HRESULT _hr = raw_SetCircle(CenterX, CenterY, Radius);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(2943)
inline HRESULT VGCore::IVGOnScreenCurve::SetPoints ( struct IVGPointRange * Points ) {
    HRESULT _hr = raw_SetPoints(Points);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface IVGMathUtils wrapper method implementations
//

#pragma implementation_key(2944)
inline VGCore::IVGPointPtr VGCore::IVGMathUtils::Interpolate ( struct IVGPoint * S, struct IVGPoint * E, double t ) {
    struct IVGPoint * _result = 0;
    HRESULT _hr = raw_Interpolate(S, E, t, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGPointPtr(_result, false);
}

#pragma implementation_key(2945)
inline VARIANT_BOOL VGCore::IVGMathUtils::IntersectLineSegments ( struct IVGPoint * S1, struct IVGPoint * E1, struct IVGPoint * S2, struct IVGPoint * E2, struct IVGPoint * * ppVal ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_IntersectLineSegments(S1, E1, S2, E2, ppVal, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2946)
inline double VGCore::IVGMathUtils::DistanceToLineSegment ( struct IVGPoint * S, struct IVGPoint * E, struct IVGPoint * Point ) {
    double _result = 0;
    HRESULT _hr = raw_DistanceToLineSegment(S, E, Point, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2947)
inline VGCore::IVGPointPtr VGCore::IVGMathUtils::ClosestPointToLineSegment ( struct IVGPoint * S, struct IVGPoint * E, struct IVGPoint * Point ) {
    struct IVGPoint * _result = 0;
    HRESULT _hr = raw_ClosestPointToLineSegment(S, E, Point, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGPointPtr(_result, false);
}

#pragma implementation_key(2948)
inline VARIANT_BOOL VGCore::IVGMathUtils::IntersectInfiniteLines ( struct IVGPoint * S1, struct IVGPoint * E1, struct IVGPoint * S2, struct IVGPoint * E2, struct IVGPoint * * ppVal ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_IntersectInfiniteLines(S1, E1, S2, E2, ppVal, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2949)
inline double VGCore::IVGMathUtils::DistanceToInfiniteLine ( struct IVGPoint * S, struct IVGPoint * E, struct IVGPoint * Point ) {
    double _result = 0;
    HRESULT _hr = raw_DistanceToInfiniteLine(S, E, Point, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2950)
inline VGCore::IVGPointPtr VGCore::IVGMathUtils::ClosestPointToInfiniteLine ( struct IVGPoint * S, struct IVGPoint * E, struct IVGPoint * Point ) {
    struct IVGPoint * _result = 0;
    HRESULT _hr = raw_ClosestPointToInfiniteLine(S, E, Point, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGPointPtr(_result, false);
}

#pragma implementation_key(2951)
inline double VGCore::IVGMathUtils::GetRandomReal ( double low, double High ) {
    double _result = 0;
    HRESULT _hr = raw_GetRandomReal(low, High, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2952)
inline long VGCore::IVGMathUtils::GetRandomInteger ( long low, long High ) {
    long _result = 0;
    HRESULT _hr = raw_GetRandomInteger(low, High, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2953)
inline HRESULT VGCore::IVGMathUtils::FitLineToPoints ( struct IVGPointRange * Points, struct IVGPoint * * Origin, struct IVGVector * * Direction ) {
    HRESULT _hr = raw_FitLineToPoints(Points, Origin, Direction);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(2954)
inline VGCore::IVGPointPtr VGCore::IVGMathUtils::MidPoint ( struct IVGPoint * S, struct IVGPoint * E ) {
    struct IVGPoint * _result = 0;
    HRESULT _hr = raw_MidPoint(S, E, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGPointPtr(_result, false);
}

#pragma implementation_key(2955)
inline VGCore::IVGPointPtr VGCore::IVGMathUtils::CreatePoint ( double x, double y ) {
    struct IVGPoint * _result = 0;
    HRESULT _hr = raw_CreatePoint(x, y, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGPointPtr(_result, false);
}

#pragma implementation_key(2956)
inline VGCore::IVGVectorPtr VGCore::IVGMathUtils::CreateVector ( double x, double y ) {
    struct IVGVector * _result = 0;
    HRESULT _hr = raw_CreateVector(x, y, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGVectorPtr(_result, false);
}

#pragma implementation_key(2957)
inline VGCore::IVGPointRangePtr VGCore::IVGMathUtils::CreatePointRange ( ) {
    struct IVGPointRange * _result = 0;
    HRESULT _hr = raw_CreatePointRange(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGPointRangePtr(_result, false);
}

#pragma implementation_key(2958)
inline VGCore::IVGTransformMatrixPtr VGCore::IVGMathUtils::CreateIdentityTransformMatrix ( ) {
    struct IVGTransformMatrix * _result = 0;
    HRESULT _hr = raw_CreateIdentityTransformMatrix(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGTransformMatrixPtr(_result, false);
}

#pragma implementation_key(2959)
inline VGCore::IVGTransformMatrixPtr VGCore::IVGMathUtils::CreateRotationTransformMatrix ( double Angle, double OriginX, double OriginY ) {
    struct IVGTransformMatrix * _result = 0;
    HRESULT _hr = raw_CreateRotationTransformMatrix(Angle, OriginX, OriginY, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGTransformMatrixPtr(_result, false);
}

#pragma implementation_key(2960)
inline VGCore::IVGTransformMatrixPtr VGCore::IVGMathUtils::CreateTranslationTransformMatrix ( double TranslateX, double TranslateY ) {
    struct IVGTransformMatrix * _result = 0;
    HRESULT _hr = raw_CreateTranslationTransformMatrix(TranslateX, TranslateY, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGTransformMatrixPtr(_result, false);
}

#pragma implementation_key(2961)
inline VGCore::IVGTransformMatrixPtr VGCore::IVGMathUtils::CreateScaleTransformMatrix ( double ScaleX, double ScaleY, double OriginX, double OriginY ) {
    struct IVGTransformMatrix * _result = 0;
    HRESULT _hr = raw_CreateScaleTransformMatrix(ScaleX, ScaleY, OriginX, OriginY, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGTransformMatrixPtr(_result, false);
}

#pragma implementation_key(2962)
inline VGCore::IVGTransformMatrixPtr VGCore::IVGMathUtils::CreateLineSegmentTransformMatrix ( struct IVGPoint * FromStart, struct IVGPoint * FromEnd, struct IVGPoint * ToStart, struct IVGPoint * ToEnd ) {
    struct IVGTransformMatrix * _result = 0;
    HRESULT _hr = raw_CreateLineSegmentTransformMatrix(FromStart, FromEnd, ToStart, ToEnd, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGTransformMatrixPtr(_result, false);
}

//
// interface IVGNodeRange wrapper method implementations
//

#pragma implementation_key(2963)
inline VGCore::IVGApplicationPtr VGCore::IVGNodeRange::GetApplication ( ) {
    struct IVGApplication * _result = 0;
    HRESULT _hr = get_Application(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGApplicationPtr(_result, false);
}

#pragma implementation_key(2964)
inline VGCore::IVGCurvePtr VGCore::IVGNodeRange::GetParent ( ) {
    struct IVGCurve * _result = 0;
    HRESULT _hr = get_Parent(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGCurvePtr(_result, false);
}

#pragma implementation_key(2965)
inline VGCore::IVGNodePtr VGCore::IVGNodeRange::GetItem ( long Index ) {
    struct IVGNode * _result = 0;
    HRESULT _hr = get_Item(Index, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGNodePtr(_result, false);
}

#pragma implementation_key(2966)
inline long VGCore::IVGNodeRange::GetCount ( ) {
    long _result = 0;
    HRESULT _hr = get_Count(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2967)
inline enum VGCore::cdrNodeType VGCore::IVGNodeRange::GetType ( ) {
    enum cdrNodeType _result;
    HRESULT _hr = get_Type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2968)
inline double VGCore::IVGNodeRange::GetPositionX ( ) {
    double _result = 0;
    HRESULT _hr = get_PositionX(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2969)
inline double VGCore::IVGNodeRange::GetPositionY ( ) {
    double _result = 0;
    HRESULT _hr = get_PositionY(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2970)
inline double VGCore::IVGNodeRange::GetSizeWidth ( ) {
    double _result = 0;
    HRESULT _hr = get_SizeWidth(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2971)
inline double VGCore::IVGNodeRange::GetSizeHeight ( ) {
    double _result = 0;
    HRESULT _hr = get_SizeHeight(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2972)
inline HRESULT VGCore::IVGNodeRange::Add ( struct IVGNode * Node ) {
    HRESULT _hr = raw_Add(Node);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(2973)
inline HRESULT VGCore::IVGNodeRange::Remove ( long Index ) {
    HRESULT _hr = raw_Remove(Index);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(2974)
inline HRESULT VGCore::IVGNodeRange::Move ( double DeltaX, double DeltaY, long AnchorIndex, VARIANT_BOOL ElasticMode ) {
    HRESULT _hr = raw_Move(DeltaX, DeltaY, AnchorIndex, ElasticMode);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(2975)
inline HRESULT VGCore::IVGNodeRange::Delete ( ) {
    HRESULT _hr = raw_Delete();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(2976)
inline HRESULT VGCore::IVGNodeRange::Stretch ( float RatioX, float RatioY, VARIANT_BOOL UseAnchorPoint, double StretchAnchorX, double StretchAnchorY ) {
    HRESULT _hr = raw_Stretch(RatioX, RatioY, UseAnchorPoint, StretchAnchorX, StretchAnchorY);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(2977)
inline HRESULT VGCore::IVGNodeRange::Rotate ( double Angle, VARIANT_BOOL UseCenterPoint, double RotationCenterX, double RotationCenterY ) {
    HRESULT _hr = raw_Rotate(Angle, UseCenterPoint, RotationCenterX, RotationCenterY);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(2978)
inline HRESULT VGCore::IVGNodeRange::Skew ( double AngleX, double AngleY, VARIANT_BOOL UseAnchorPoint, double SkewAnchorX, double SkewAnchorY ) {
    HRESULT _hr = raw_Skew(AngleX, AngleY, UseAnchorPoint, SkewAnchorX, SkewAnchorY);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(2979)
inline HRESULT VGCore::IVGNodeRange::AutoReduce ( double PrecisionMargin ) {
    HRESULT _hr = raw_AutoReduce(PrecisionMargin);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(2980)
inline HRESULT VGCore::IVGNodeRange::RemoveAll ( ) {
    HRESULT _hr = raw_RemoveAll();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(2981)
inline HRESULT VGCore::IVGNodeRange::SetType ( enum cdrNodeType Type ) {
    HRESULT _hr = raw_SetType(Type);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(2982)
inline IUnknownPtr VGCore::IVGNodeRange::Get_NewEnum ( ) {
    IUnknown * _result = 0;
    HRESULT _hr = get__NewEnum(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IUnknownPtr(_result, false);
}

#pragma implementation_key(2983)
inline HRESULT VGCore::IVGNodeRange::AddRange ( struct IVGNodeRange * NodeRange ) {
    HRESULT _hr = raw_AddRange(NodeRange);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(2984)
inline VGCore::IVGSegmentRangePtr VGCore::IVGNodeRange::GetSegmentRange ( ) {
    struct IVGSegmentRange * _result = 0;
    HRESULT _hr = get_SegmentRange(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGSegmentRangePtr(_result, false);
}

#pragma implementation_key(2985)
inline HRESULT VGCore::IVGNodeRange::BreakApart ( ) {
    HRESULT _hr = raw_BreakApart();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(2986)
inline HRESULT VGCore::IVGNodeRange::Smoothen ( long Smoothness ) {
    HRESULT _hr = raw_Smoothen(Smoothness);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(2987)
inline HRESULT VGCore::IVGNodeRange::RemoveRange ( struct IVGNodeRange * NodeRange ) {
    HRESULT _hr = raw_RemoveRange(NodeRange);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(2988)
inline HRESULT VGCore::IVGNodeRange::Fillet ( double Radius, VARIANT_BOOL CombineSmoothSegments ) {
    HRESULT _hr = raw_Fillet(Radius, CombineSmoothSegments);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(2989)
inline HRESULT VGCore::IVGNodeRange::Chamfer ( double DistanceA, double DistanceB, VARIANT_BOOL CombineSmoothSegments ) {
    HRESULT _hr = raw_Chamfer(DistanceA, DistanceB, CombineSmoothSegments);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(2990)
inline HRESULT VGCore::IVGNodeRange::Scallop ( double Radius, VARIANT_BOOL CombineSmoothSegments ) {
    HRESULT _hr = raw_Scallop(Radius, CombineSmoothSegments);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(2991)
inline HRESULT VGCore::IVGNodeRange::CreateSelection ( ) {
    HRESULT _hr = raw_CreateSelection();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(2992)
inline HRESULT VGCore::IVGNodeRange::AddToSelection ( ) {
    HRESULT _hr = raw_AddToSelection();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(2993)
inline HRESULT VGCore::IVGNodeRange::RemoveFromSelection ( ) {
    HRESULT _hr = raw_RemoveFromSelection();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(2994)
inline VGCore::IVGNodePtr VGCore::IVGNodeRange::GetFirstNode ( ) {
    struct IVGNode * _result = 0;
    HRESULT _hr = get_FirstNode(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGNodePtr(_result, false);
}

#pragma implementation_key(2995)
inline VGCore::IVGNodePtr VGCore::IVGNodeRange::GetLastNode ( ) {
    struct IVGNode * _result = 0;
    HRESULT _hr = get_LastNode(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGNodePtr(_result, false);
}

#pragma implementation_key(2996)
inline VARIANT_BOOL VGCore::IVGNodeRange::GetBoundingBox ( double * x, double * y, double * Width, double * Height ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_GetBoundingBox(x, y, Width, Height, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2997)
inline VGCore::IVGRectPtr VGCore::IVGNodeRange::GetBoundingBox ( ) {
    struct IVGRect * _result = 0;
    HRESULT _hr = get_BoundingBox(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGRectPtr(_result, false);
}

//
// interface IVGSegmentRange wrapper method implementations
//

#pragma implementation_key(2998)
inline VGCore::IVGApplicationPtr VGCore::IVGSegmentRange::GetApplication ( ) {
    struct IVGApplication * _result = 0;
    HRESULT _hr = get_Application(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGApplicationPtr(_result, false);
}

#pragma implementation_key(2999)
inline VGCore::IVGCurvePtr VGCore::IVGSegmentRange::GetParent ( ) {
    struct IVGCurve * _result = 0;
    HRESULT _hr = get_Parent(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGCurvePtr(_result, false);
}

#pragma implementation_key(3000)
inline VGCore::IVGSegmentPtr VGCore::IVGSegmentRange::GetItem ( long Index ) {
    struct IVGSegment * _result = 0;
    HRESULT _hr = get_Item(Index, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGSegmentPtr(_result, false);
}

#pragma implementation_key(3001)
inline long VGCore::IVGSegmentRange::GetCount ( ) {
    long _result = 0;
    HRESULT _hr = get_Count(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3002)
inline enum VGCore::cdrSegmentType VGCore::IVGSegmentRange::GetType ( ) {
    enum cdrSegmentType _result;
    HRESULT _hr = get_Type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3003)
inline double VGCore::IVGSegmentRange::GetLength ( ) {
    double _result = 0;
    HRESULT _hr = get_Length(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3004)
inline HRESULT VGCore::IVGSegmentRange::Add ( struct IVGSegment * Segment ) {
    HRESULT _hr = raw_Add(Segment);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(3005)
inline HRESULT VGCore::IVGSegmentRange::Remove ( long Index ) {
    HRESULT _hr = raw_Remove(Index);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(3006)
inline HRESULT VGCore::IVGSegmentRange::AddNode ( ) {
    HRESULT _hr = raw_AddNode();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(3007)
inline HRESULT VGCore::IVGSegmentRange::RemoveAll ( ) {
    HRESULT _hr = raw_RemoveAll();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(3008)
inline HRESULT VGCore::IVGSegmentRange::SetType ( enum cdrSegmentType Type ) {
    HRESULT _hr = raw_SetType(Type);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(3009)
inline IUnknownPtr VGCore::IVGSegmentRange::Get_NewEnum ( ) {
    IUnknown * _result = 0;
    HRESULT _hr = get__NewEnum(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IUnknownPtr(_result, false);
}

#pragma implementation_key(3010)
inline HRESULT VGCore::IVGSegmentRange::AddRange ( struct IVGSegmentRange * SegmentRange ) {
    HRESULT _hr = raw_AddRange(SegmentRange);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(3011)
inline VGCore::IVGNodeRangePtr VGCore::IVGSegmentRange::GetNodeRange ( ) {
    struct IVGNodeRange * _result = 0;
    HRESULT _hr = get_NodeRange(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGNodeRangePtr(_result, false);
}

#pragma implementation_key(3012)
inline HRESULT VGCore::IVGSegmentRange::RemoveRange ( struct IVGSegmentRange * SegmentRange ) {
    HRESULT _hr = raw_RemoveRange(SegmentRange);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(3013)
inline VGCore::IVGSegmentPtr VGCore::IVGSegmentRange::GetFirstSegment ( ) {
    struct IVGSegment * _result = 0;
    HRESULT _hr = get_FirstSegment(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGSegmentPtr(_result, false);
}

#pragma implementation_key(3014)
inline VGCore::IVGSegmentPtr VGCore::IVGSegmentRange::GetLastSegment ( ) {
    struct IVGSegment * _result = 0;
    HRESULT _hr = get_LastSegment(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGSegmentPtr(_result, false);
}

#pragma implementation_key(3015)
inline HRESULT VGCore::IVGSegmentRange::CreateSelection ( ) {
    HRESULT _hr = raw_CreateSelection();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(3016)
inline HRESULT VGCore::IVGSegmentRange::AddToSelection ( ) {
    HRESULT _hr = raw_AddToSelection();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(3017)
inline HRESULT VGCore::IVGSegmentRange::RemoveFromSelection ( ) {
    HRESULT _hr = raw_RemoveFromSelection();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface IVGSegments wrapper method implementations
//

#pragma implementation_key(3018)
inline VGCore::IVGApplicationPtr VGCore::IVGSegments::GetApplication ( ) {
    struct IVGApplication * _result = 0;
    HRESULT _hr = get_Application(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGApplicationPtr(_result, false);
}

#pragma implementation_key(3019)
inline VGCore::IVGCurvePtr VGCore::IVGSegments::GetParent ( ) {
    struct IVGCurve * _result = 0;
    HRESULT _hr = get_Parent(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGCurvePtr(_result, false);
}

#pragma implementation_key(3020)
inline VGCore::IVGSegmentPtr VGCore::IVGSegments::GetItem ( long Index ) {
    struct IVGSegment * _result = 0;
    HRESULT _hr = get_Item(Index, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGSegmentPtr(_result, false);
}

#pragma implementation_key(3021)
inline IUnknownPtr VGCore::IVGSegments::Get_NewEnum ( ) {
    IUnknown * _result = 0;
    HRESULT _hr = get__NewEnum(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IUnknownPtr(_result, false);
}

#pragma implementation_key(3022)
inline long VGCore::IVGSegments::GetCount ( ) {
    long _result = 0;
    HRESULT _hr = get_Count(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3023)
inline VGCore::IVGSegmentRangePtr VGCore::IVGSegments::Range ( SAFEARRAY * * IndexArray ) {
    struct IVGSegmentRange * _result = 0;
    HRESULT _hr = raw_Range(IndexArray, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGSegmentRangePtr(_result, false);
}

#pragma implementation_key(3024)
inline VGCore::IVGSegmentRangePtr VGCore::IVGSegments::All ( ) {
    struct IVGSegmentRange * _result = 0;
    HRESULT _hr = raw_All(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGSegmentRangePtr(_result, false);
}

#pragma implementation_key(3025)
inline VGCore::IVGSegmentRangePtr VGCore::IVGSegments::AllExcluding ( SAFEARRAY * * IndexArray ) {
    struct IVGSegmentRange * _result = 0;
    HRESULT _hr = raw_AllExcluding(IndexArray, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGSegmentRangePtr(_result, false);
}

#pragma implementation_key(3026)
inline VGCore::IVGSegmentPtr VGCore::IVGSegments::GetFirst ( ) {
    struct IVGSegment * _result = 0;
    HRESULT _hr = get_First(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGSegmentPtr(_result, false);
}

#pragma implementation_key(3027)
inline VGCore::IVGSegmentPtr VGCore::IVGSegments::GetLast ( ) {
    struct IVGSegment * _result = 0;
    HRESULT _hr = get_Last(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGSegmentPtr(_result, false);
}

//
// interface IVGBitmap wrapper method implementations
//

#pragma implementation_key(3028)
inline long VGCore::IVGBitmap::GetSizeWidth ( ) {
    long _result = 0;
    HRESULT _hr = get_SizeWidth(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3029)
inline long VGCore::IVGBitmap::GetSizeHeight ( ) {
    long _result = 0;
    HRESULT _hr = get_SizeHeight(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3030)
inline long VGCore::IVGBitmap::GetResolutionX ( ) {
    long _result = 0;
    HRESULT _hr = get_ResolutionX(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3031)
inline long VGCore::IVGBitmap::GetResolutionY ( ) {
    long _result = 0;
    HRESULT _hr = get_ResolutionY(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3032)
inline VARIANT_BOOL VGCore::IVGBitmap::GetExternallyLinked ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_ExternallyLinked(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3033)
inline HRESULT VGCore::IVGBitmap::ResolveLink ( ) {
    HRESULT _hr = raw_ResolveLink();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(3034)
inline HRESULT VGCore::IVGBitmap::UpdateLink ( ) {
    HRESULT _hr = raw_UpdateLink();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(3035)
inline HRESULT VGCore::IVGBitmap::Inflate ( long Width, long Height ) {
    HRESULT _hr = raw_Inflate(Width, Height);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(3036)
inline _bstr_t VGCore::IVGBitmap::GetLinkFileName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_LinkFileName(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(3037)
inline enum VGCore::cdrImageType VGCore::IVGBitmap::GetMode ( ) {
    enum cdrImageType _result;
    HRESULT _hr = get_Mode(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3038)
inline VGCore::ICorelExportFilterPtr VGCore::IVGBitmap::SaveAs ( _bstr_t FileName, enum cdrFilter Filter, enum cdrCompressionType Compression ) {
    struct ICorelExportFilter * _result = 0;
    HRESULT _hr = raw_SaveAs(FileName, Filter, Compression, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return ICorelExportFilterPtr(_result, false);
}

#pragma implementation_key(3039)
inline HRESULT VGCore::IVGBitmap::Resample ( long Width, long Height, VARIANT_BOOL AntiAlias, double ResolutionX, double ResolutionY ) {
    HRESULT _hr = raw_Resample(Width, Height, AntiAlias, ResolutionX, ResolutionY);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(3040)
inline HRESULT VGCore::IVGBitmap::ConvertTo ( enum cdrImageType Mode ) {
    HRESULT _hr = raw_ConvertTo(Mode);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(3041)
inline HRESULT VGCore::IVGBitmap::ApplyBitmapEffect ( _bstr_t UndoString, _bstr_t Command ) {
    HRESULT _hr = raw_ApplyBitmapEffect(UndoString, Command);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(3042)
inline HRESULT VGCore::IVGBitmap::Crop ( ) {
    HRESULT _hr = raw_Crop();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(3043)
inline VARIANT_BOOL VGCore::IVGBitmap::GetTransparent ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_Transparent(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3044)
inline VARIANT_BOOL VGCore::IVGBitmap::GetWatermarked ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_Watermarked(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3045)
inline VARIANT_BOOL VGCore::IVGBitmap::GetOPILinked ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_OPILinked(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3046)
inline VARIANT_BOOL VGCore::IVGBitmap::GetIsEPS ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsEPS(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3047)
inline DATE VGCore::IVGBitmap::GetExternalLinkTime ( ) {
    DATE _result = 0;
    HRESULT _hr = get_ExternalLinkTime(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3048)
inline HRESULT VGCore::IVGBitmap::ConvertToPaletted ( enum cdrImagePaletteType PaletteType, enum cdrDitherType DitherType, long DitherIntensity, long Smoothing, long NumColors, VARIANT_BOOL ColorSensitive, long TargetColor, long Importance, long Lightness, long ToleranceA, long ToleranceB, VARIANT * Palette ) {
    HRESULT _hr = raw_ConvertToPaletted(PaletteType, DitherType, DitherIntensity, Smoothing, NumColors, ColorSensitive, TargetColor, Importance, Lightness, ToleranceA, ToleranceB, Palette);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(3049)
inline HRESULT VGCore::IVGBitmap::ConvertToPaletted2 ( struct IVGStructPaletteOptions * Options ) {
    HRESULT _hr = raw_ConvertToPaletted2(Options);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(3050)
inline HRESULT VGCore::IVGBitmap::ConvertToBW ( enum cdrRenderType RenderType, long Intensity, long Threshold, enum cdrHalftoneType Halftone, long HalftoneAngle, long HalftoneSize ) {
    HRESULT _hr = raw_ConvertToBW(RenderType, Intensity, Threshold, Halftone, HalftoneAngle, HalftoneSize);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(3051)
inline HRESULT VGCore::IVGBitmap::ResetCropEnvelope ( ) {
    HRESULT _hr = raw_ResetCropEnvelope();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(3052)
inline VARIANT_BOOL VGCore::IVGBitmap::GetEmbedded ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_Embedded(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3053)
inline VARIANT_BOOL VGCore::IVGBitmap::GetCropped ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_Cropped(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3054)
inline VARIANT_BOOL VGCore::IVGBitmap::GetCropEnvelopeModified ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_CropEnvelopeModified(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3055)
inline VGCore::IVGCurvePtr VGCore::IVGBitmap::GetCropEnvelope ( ) {
    struct IVGCurve * _result = 0;
    HRESULT _hr = get_CropEnvelope(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGCurvePtr(_result, false);
}

#pragma implementation_key(3056)
inline VGCore::IVGCurvePtr VGCore::IVGBitmap::GetBoundingBoxPath ( ) {
    struct IVGCurve * _result = 0;
    HRESULT _hr = get_BoundingBoxPath(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGCurvePtr(_result, false);
}

#pragma implementation_key(3057)
inline HRESULT VGCore::IVGBitmap::ConvertToDuotone ( struct IVGDuotone * Duotone ) {
    HRESULT _hr = raw_ConvertToDuotone(Duotone);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(3058)
inline VGCore::IVGDuotonePtr VGCore::IVGBitmap::GetDuotone ( ) {
    struct IVGDuotone * _result = 0;
    HRESULT _hr = get_Duotone(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGDuotonePtr(_result, false);
}

#pragma implementation_key(3059)
inline void VGCore::IVGBitmap::PutLinkFileName ( _bstr_t pVal ) {
    HRESULT _hr = put_LinkFileName(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(3060)
inline VGCore::IVGTraceSettingsPtr VGCore::IVGBitmap::Trace ( enum cdrTraceType TraceType, short Smoothing, short DetailLevelPercent, enum cdrColorType ColorMode, enum cdrPaletteID PaletteID, long ColorCount, VARIANT_BOOL DeleteOriginalObject, VARIANT_BOOL RemoveBackground, VARIANT_BOOL RemoveEntireBackColor ) {
    struct IVGTraceSettings * _result = 0;
    HRESULT _hr = raw_Trace(TraceType, Smoothing, DetailLevelPercent, ColorMode, PaletteID, ColorCount, DeleteOriginalObject, RemoveBackground, RemoveEntireBackColor, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGTraceSettingsPtr(_result, false);
}

#pragma implementation_key(3061)
inline VGCore::IVGImagePtr VGCore::IVGBitmap::GetImage ( ) {
    struct IVGImage * _result = 0;
    HRESULT _hr = get_Image(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGImagePtr(_result, false);
}

#pragma implementation_key(3062)
inline VGCore::IVGImagePtr VGCore::IVGBitmap::GetImageAlpha ( ) {
    struct IVGImage * _result = 0;
    HRESULT _hr = get_ImageAlpha(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGImagePtr(_result, false);
}

#pragma implementation_key(3063)
inline HRESULT VGCore::IVGBitmap::SetImageData ( struct IVGImage * Image, struct IVGImage * Alpha, long OffsetX, long OffsetY ) {
    HRESULT _hr = raw_SetImageData(Image, Alpha, OffsetX, OffsetY);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface IVGEPS wrapper method implementations
//

#pragma implementation_key(3064)
inline VGCore::IVGBitmapPtr VGCore::IVGEPS::GetPreviewBitmap ( ) {
    struct IVGBitmap * _result = 0;
    HRESULT _hr = get_PreviewBitmap(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGBitmapPtr(_result, false);
}

#pragma implementation_key(3065)
inline SAFEARRAY * VGCore::IVGEPS::GetData ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = get_Data(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3066)
inline _bstr_t VGCore::IVGEPS::GetDataAsString ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_DataAsString(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(3067)
inline VGCore::IVGCurvePtr VGCore::IVGEPS::GetCropEnvelope ( ) {
    struct IVGCurve * _result = 0;
    HRESULT _hr = get_CropEnvelope(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGCurvePtr(_result, false);
}

#pragma implementation_key(3068)
inline HRESULT VGCore::IVGEPS::ResetCropEnvelope ( ) {
    HRESULT _hr = raw_ResetCropEnvelope();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(3069)
inline VARIANT_BOOL VGCore::IVGEPS::GetCropEnvelopeModified ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_CropEnvelopeModified(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3070)
inline VGCore::IVGCurvePtr VGCore::IVGEPS::GetBoundingBoxPath ( ) {
    struct IVGCurve * _result = 0;
    HRESULT _hr = get_BoundingBoxPath(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGCurvePtr(_result, false);
}

#pragma implementation_key(3071)
inline _bstr_t VGCore::IVGEPS::GetLinkFileName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_LinkFileName(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(3072)
inline void VGCore::IVGEPS::PutLinkFileName ( _bstr_t pVal ) {
    HRESULT _hr = put_LinkFileName(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(3073)
inline SAFEARRAY * VGCore::IVGEPS::GetDCSFileNames ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = get_DCSFileNames(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface IVGDuotone wrapper method implementations
//

#pragma implementation_key(3074)
inline enum VGCore::cdrDuotoneType VGCore::IVGDuotone::GetType ( ) {
    enum cdrDuotoneType _result;
    HRESULT _hr = get_Type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3075)
inline void VGCore::IVGDuotone::PutType ( enum cdrDuotoneType pVal ) {
    HRESULT _hr = put_Type(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(3076)
inline VARIANT_BOOL VGCore::IVGDuotone::GetUseOverprints ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_UseOverprints(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3077)
inline void VGCore::IVGDuotone::PutUseOverprints ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_UseOverprints(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(3078)
inline long VGCore::IVGDuotone::GetOverprintCount ( ) {
    long _result = 0;
    HRESULT _hr = get_OverprintCount(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3079)
inline VGCore::IVGDuotoneOverprintPtr VGCore::IVGDuotone::GetOverprints ( long Index ) {
    struct IVGDuotoneOverprint * _result = 0;
    HRESULT _hr = get_Overprints(Index, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGDuotoneOverprintPtr(_result, false);
}

#pragma implementation_key(3080)
inline long VGCore::IVGDuotone::GetInkCount ( ) {
    long _result = 0;
    HRESULT _hr = get_InkCount(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3081)
inline VGCore::IVGDuotoneInkPtr VGCore::IVGDuotone::GetInks ( long Index ) {
    struct IVGDuotoneInk * _result = 0;
    HRESULT _hr = get_Inks(Index, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGDuotoneInkPtr(_result, false);
}

#pragma implementation_key(3082)
inline VGCore::IVGDuotonePtr VGCore::IVGDuotone::GetCopy ( ) {
    struct IVGDuotone * _result = 0;
    HRESULT _hr = raw_GetCopy(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGDuotonePtr(_result, false);
}

#pragma implementation_key(3083)
inline HRESULT VGCore::IVGDuotone::CopyAssign ( struct IVGDuotone * Duotone ) {
    HRESULT _hr = raw_CopyAssign(Duotone);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(3084)
inline HRESULT VGCore::IVGDuotone::ResetOverprints ( ) {
    HRESULT _hr = raw_ResetOverprints();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(3085)
inline VARIANT_BOOL VGCore::IVGDuotone::Load ( _bstr_t FileName ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_Load(FileName, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3086)
inline VARIANT_BOOL VGCore::IVGDuotone::Save ( _bstr_t FileName ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_Save(FileName, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface IVGDuotoneOverprint wrapper method implementations
//

#pragma implementation_key(3087)
inline long VGCore::IVGDuotoneOverprint::GetCyan ( ) {
    long _result = 0;
    HRESULT _hr = get_Cyan(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3088)
inline void VGCore::IVGDuotoneOverprint::PutCyan ( long pVal ) {
    HRESULT _hr = put_Cyan(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(3089)
inline long VGCore::IVGDuotoneOverprint::GetMagenta ( ) {
    long _result = 0;
    HRESULT _hr = get_Magenta(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3090)
inline void VGCore::IVGDuotoneOverprint::PutMagenta ( long pVal ) {
    HRESULT _hr = put_Magenta(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(3091)
inline long VGCore::IVGDuotoneOverprint::GetYellow ( ) {
    long _result = 0;
    HRESULT _hr = get_Yellow(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3092)
inline void VGCore::IVGDuotoneOverprint::PutYellow ( long pVal ) {
    HRESULT _hr = put_Yellow(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(3093)
inline long VGCore::IVGDuotoneOverprint::GetBlack ( ) {
    long _result = 0;
    HRESULT _hr = get_Black(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3094)
inline void VGCore::IVGDuotoneOverprint::PutBlack ( long pVal ) {
    HRESULT _hr = put_Black(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(3095)
inline VGCore::IVGColorPtr VGCore::IVGDuotoneOverprint::GetColor ( ) {
    struct IVGColor * _result = 0;
    HRESULT _hr = get_Color(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGColorPtr(_result, false);
}

#pragma implementation_key(3096)
inline void VGCore::IVGDuotoneOverprint::PutColor ( struct IVGColor * ppVal ) {
    HRESULT _hr = put_Color(ppVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(3097)
inline HRESULT VGCore::IVGDuotoneOverprint::Reset ( ) {
    HRESULT _hr = raw_Reset();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(3098)
inline HRESULT VGCore::IVGDuotoneOverprint::SetValues ( long Cyan, long Magenta, long Yellow, long Black ) {
    HRESULT _hr = raw_SetValues(Cyan, Magenta, Yellow, Black);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface IVGColor wrapper method implementations
//

#pragma implementation_key(3099)
inline IDispatchPtr VGCore::IVGColor::GetApplication ( ) {
    IDispatch * _result = 0;
    HRESULT _hr = get_Application(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IDispatchPtr(_result, false);
}

#pragma implementation_key(3100)
inline IDispatchPtr VGCore::IVGColor::GetParent ( ) {
    IDispatch * _result = 0;
    HRESULT _hr = get_Parent(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IDispatchPtr(_result, false);
}

#pragma implementation_key(3101)
inline enum VGCore::cdrColorType VGCore::IVGColor::GetType ( ) {
    enum cdrColorType _result;
    HRESULT _hr = get_Type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3102)
inline HRESULT VGCore::IVGColor::RGBAssign ( long Red, long Green, long Blue ) {
    HRESULT _hr = raw_RGBAssign(Red, Green, Blue);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(3103)
inline long VGCore::IVGColor::GetRGBRed ( ) {
    long _result = 0;
    HRESULT _hr = get_RGBRed(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3104)
inline void VGCore::IVGColor::PutRGBRed ( long pVal ) {
    HRESULT _hr = put_RGBRed(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(3105)
inline long VGCore::IVGColor::GetRGBGreen ( ) {
    long _result = 0;
    HRESULT _hr = get_RGBGreen(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3106)
inline void VGCore::IVGColor::PutRGBGreen ( long pVal ) {
    HRESULT _hr = put_RGBGreen(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(3107)
inline long VGCore::IVGColor::GetRGBBlue ( ) {
    long _result = 0;
    HRESULT _hr = get_RGBBlue(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3108)
inline void VGCore::IVGColor::PutRGBBlue ( long pVal ) {
    HRESULT _hr = put_RGBBlue(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(3109)
inline HRESULT VGCore::IVGColor::ConvertToRGB ( ) {
    HRESULT _hr = raw_ConvertToRGB();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(3110)
inline HRESULT VGCore::IVGColor::CMYKAssign ( long Cyan, long Magenta, long Yellow, long Black ) {
    HRESULT _hr = raw_CMYKAssign(Cyan, Magenta, Yellow, Black);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(3111)
inline long VGCore::IVGColor::GetCMYKCyan ( ) {
    long _result = 0;
    HRESULT _hr = get_CMYKCyan(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3112)
inline void VGCore::IVGColor::PutCMYKCyan ( long pVal ) {
    HRESULT _hr = put_CMYKCyan(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(3113)
inline long VGCore::IVGColor::GetCMYKYellow ( ) {
    long _result = 0;
    HRESULT _hr = get_CMYKYellow(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3114)
inline void VGCore::IVGColor::PutCMYKYellow ( long pVal ) {
    HRESULT _hr = put_CMYKYellow(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(3115)
inline long VGCore::IVGColor::GetCMYKMagenta ( ) {
    long _result = 0;
    HRESULT _hr = get_CMYKMagenta(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3116)
inline void VGCore::IVGColor::PutCMYKMagenta ( long pVal ) {
    HRESULT _hr = put_CMYKMagenta(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(3117)
inline long VGCore::IVGColor::GetCMYKBlack ( ) {
    long _result = 0;
    HRESULT _hr = get_CMYKBlack(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3118)
inline void VGCore::IVGColor::PutCMYKBlack ( long pVal ) {
    HRESULT _hr = put_CMYKBlack(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(3119)
inline HRESULT VGCore::IVGColor::ConvertToCMYK ( ) {
    HRESULT _hr = raw_ConvertToCMYK();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(3120)
inline HRESULT VGCore::IVGColor::CMYAssign ( long Cyan, long Magenta, long Yellow ) {
    HRESULT _hr = raw_CMYAssign(Cyan, Magenta, Yellow);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(3121)
inline long VGCore::IVGColor::GetCMYCyan ( ) {
    long _result = 0;
    HRESULT _hr = get_CMYCyan(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3122)
inline void VGCore::IVGColor::PutCMYCyan ( long pVal ) {
    HRESULT _hr = put_CMYCyan(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(3123)
inline long VGCore::IVGColor::GetCMYMagenta ( ) {
    long _result = 0;
    HRESULT _hr = get_CMYMagenta(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3124)
inline void VGCore::IVGColor::PutCMYMagenta ( long pVal ) {
    HRESULT _hr = put_CMYMagenta(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(3125)
inline long VGCore::IVGColor::GetCMYYellow ( ) {
    long _result = 0;
    HRESULT _hr = get_CMYYellow(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3126)
inline void VGCore::IVGColor::PutCMYYellow ( long pVal ) {
    HRESULT _hr = put_CMYYellow(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(3127)
inline HRESULT VGCore::IVGColor::ConvertToCMY ( ) {
    HRESULT _hr = raw_ConvertToCMY();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(3128)
inline HRESULT VGCore::IVGColor::HSBAssign ( long Hue, long Saturation, long Brightness ) {
    HRESULT _hr = raw_HSBAssign(Hue, Saturation, Brightness);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(3129)
inline long VGCore::IVGColor::GetHSBHue ( ) {
    long _result = 0;
    HRESULT _hr = get_HSBHue(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3130)
inline void VGCore::IVGColor::PutHSBHue ( long pVal ) {
    HRESULT _hr = put_HSBHue(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(3131)
inline long VGCore::IVGColor::GetHSBSaturation ( ) {
    long _result = 0;
    HRESULT _hr = get_HSBSaturation(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3132)
inline void VGCore::IVGColor::PutHSBSaturation ( long pVal ) {
    HRESULT _hr = put_HSBSaturation(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(3133)
inline long VGCore::IVGColor::GetHSBBrightness ( ) {
    long _result = 0;
    HRESULT _hr = get_HSBBrightness(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3134)
inline void VGCore::IVGColor::PutHSBBrightness ( long pVal ) {
    HRESULT _hr = put_HSBBrightness(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(3135)
inline HRESULT VGCore::IVGColor::ConvertToHSB ( ) {
    HRESULT _hr = raw_ConvertToHSB();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(3136)
inline HRESULT VGCore::IVGColor::HLSAssign ( long Hue, long Lightness, long Saturation ) {
    HRESULT _hr = raw_HLSAssign(Hue, Lightness, Saturation);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(3137)
inline long VGCore::IVGColor::GetHLSHue ( ) {
    long _result = 0;
    HRESULT _hr = get_HLSHue(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3138)
inline void VGCore::IVGColor::PutHLSHue ( long pVal ) {
    HRESULT _hr = put_HLSHue(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(3139)
inline long VGCore::IVGColor::GetHLSLightness ( ) {
    long _result = 0;
    HRESULT _hr = get_HLSLightness(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3140)
inline void VGCore::IVGColor::PutHLSLightness ( long pVal ) {
    HRESULT _hr = put_HLSLightness(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(3141)
inline long VGCore::IVGColor::GetHLSSaturation ( ) {
    long _result = 0;
    HRESULT _hr = get_HLSSaturation(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3142)
inline void VGCore::IVGColor::PutHLSSaturation ( long pVal ) {
    HRESULT _hr = put_HLSSaturation(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(3143)
inline HRESULT VGCore::IVGColor::ConvertToHLS ( ) {
    HRESULT _hr = raw_ConvertToHLS();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(3144)
inline HRESULT VGCore::IVGColor::BWAssign ( VARIANT_BOOL White ) {
    HRESULT _hr = raw_BWAssign(White);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(3145)
inline VARIANT_BOOL VGCore::IVGColor::GetBW ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_BW(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3146)
inline void VGCore::IVGColor::PutBW ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_BW(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(3147)
inline HRESULT VGCore::IVGColor::ConvertToBW ( ) {
    HRESULT _hr = raw_ConvertToBW();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(3148)
inline HRESULT VGCore::IVGColor::GrayAssign ( long GrayValue ) {
    HRESULT _hr = raw_GrayAssign(GrayValue);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(3149)
inline long VGCore::IVGColor::GetGray ( ) {
    long _result = 0;
    HRESULT _hr = get_Gray(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3150)
inline void VGCore::IVGColor::PutGray ( long pVal ) {
    HRESULT _hr = put_Gray(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(3151)
inline HRESULT VGCore::IVGColor::ConvertToGray ( ) {
    HRESULT _hr = raw_ConvertToGray();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(3152)
inline HRESULT VGCore::IVGColor::CorelScriptAssign ( long ColorModel, long V1, long V2, long V3, long V4, long V5, long V6, long V7 ) {
    HRESULT _hr = raw_CorelScriptAssign(ColorModel, V1, V2, V3, V4, V5, V6, V7);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(3153)
inline HRESULT VGCore::IVGColor::CorelScriptGetComponent ( long * ColorModel, long * V1, long * V2, long * V3, long * V4, long * V5, long * V6, long * V7 ) {
    HRESULT _hr = raw_CorelScriptGetComponent(ColorModel, V1, V2, V3, V4, V5, V6, V7);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(3154)
inline HRESULT VGCore::IVGColor::UserAssign ( long ParentWindowHandle ) {
    HRESULT _hr = raw_UserAssign(ParentWindowHandle);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(3155)
inline HRESULT VGCore::IVGColor::CopyAssign ( struct IVGColor * Color ) {
    HRESULT _hr = raw_CopyAssign(Color);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(3156)
inline _bstr_t VGCore::IVGColor::GetName ( VARIANT_BOOL Components ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(Components, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(3157)
inline HRESULT VGCore::IVGColor::YIQAssign ( long y, long I, long Q ) {
    HRESULT _hr = raw_YIQAssign(y, I, Q);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(3158)
inline long VGCore::IVGColor::GetYIQLuminanceY ( ) {
    long _result = 0;
    HRESULT _hr = get_YIQLuminanceY(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3159)
inline void VGCore::IVGColor::PutYIQLuminanceY ( long pVal ) {
    HRESULT _hr = put_YIQLuminanceY(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(3160)
inline long VGCore::IVGColor::GetYIQChromaI ( ) {
    long _result = 0;
    HRESULT _hr = get_YIQChromaI(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3161)
inline void VGCore::IVGColor::PutYIQChromaI ( long pVal ) {
    HRESULT _hr = put_YIQChromaI(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(3162)
inline long VGCore::IVGColor::GetYIQChromaQ ( ) {
    long _result = 0;
    HRESULT _hr = get_YIQChromaQ(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3163)
inline void VGCore::IVGColor::PutYIQChromaQ ( long pVal ) {
    HRESULT _hr = put_YIQChromaQ(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(3164)
inline HRESULT VGCore::IVGColor::ConvertToYIQ ( ) {
    HRESULT _hr = raw_ConvertToYIQ();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(3165)
inline HRESULT VGCore::IVGColor::LabAssign ( long L, long A, long B ) {
    HRESULT _hr = raw_LabAssign(L, A, B);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(3166)
inline long VGCore::IVGColor::GetLabLuminance ( ) {
    long _result = 0;
    HRESULT _hr = get_LabLuminance(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3167)
inline void VGCore::IVGColor::PutLabLuminance ( long pVal ) {
    HRESULT _hr = put_LabLuminance(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(3168)
inline long VGCore::IVGColor::GetLabComponentA ( ) {
    long _result = 0;
    HRESULT _hr = get_LabComponentA(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3169)
inline void VGCore::IVGColor::PutLabComponentA ( long pVal ) {
    HRESULT _hr = put_LabComponentA(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(3170)
inline long VGCore::IVGColor::GetLabComponentB ( ) {
    long _result = 0;
    HRESULT _hr = get_LabComponentB(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3171)
inline void VGCore::IVGColor::PutLabComponentB ( long pVal ) {
    HRESULT _hr = put_LabComponentB(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(3172)
inline HRESULT VGCore::IVGColor::ConvertToLab ( ) {
    HRESULT _hr = raw_ConvertToLab();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(3173)
inline HRESULT VGCore::IVGColor::RegistrationAssign ( ) {
    HRESULT _hr = raw_RegistrationAssign();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(3174)
inline HRESULT VGCore::IVGColor::FixedAssign ( enum cdrPaletteID PaletteID, long PaletteIndex, long Tint ) {
    HRESULT _hr = raw_FixedAssign(PaletteID, PaletteIndex, Tint);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(3175)
inline enum VGCore::cdrPaletteID VGCore::IVGColor::GetPaletteID ( ) {
    enum cdrPaletteID _result;
    HRESULT _hr = get_PaletteID(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3176)
inline long VGCore::IVGColor::GetPaletteIndex ( ) {
    long _result = 0;
    HRESULT _hr = get_PaletteIndex(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3177)
inline void VGCore::IVGColor::PutPaletteIndex ( long pVal ) {
    HRESULT _hr = put_PaletteIndex(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(3178)
inline long VGCore::IVGColor::GetTint ( ) {
    long _result = 0;
    HRESULT _hr = get_Tint(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3179)
inline void VGCore::IVGColor::PutTint ( long pVal ) {
    HRESULT _hr = put_Tint(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(3180)
inline HRESULT VGCore::IVGColor::ConvertToFixed ( enum cdrPaletteID PaletteID ) {
    HRESULT _hr = raw_ConvertToFixed(PaletteID);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(3181)
inline VARIANT_BOOL VGCore::IVGColor::UserAssignEx ( long ParentWindowHandle ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_UserAssignEx(ParentWindowHandle, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3182)
inline HRESULT VGCore::IVGColor::SetName ( _bstr_t Name ) {
    HRESULT _hr = raw_SetName(Name);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(3183)
inline HRESULT VGCore::IVGColor::BlendWith ( struct IVGColor * Color, long MixRatio ) {
    HRESULT _hr = raw_BlendWith(Color, MixRatio);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(3184)
inline VARIANT_BOOL VGCore::IVGColor::IsSame ( struct IVGColor * Color ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_IsSame(Color, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3185)
inline VARIANT_BOOL VGCore::IVGColor::GetIsInGamut ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsInGamut(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3186)
inline VGCore::IVGColorPtr VGCore::IVGColor::GetInGamutColor ( ) {
    struct IVGColor * _result = 0;
    HRESULT _hr = get_InGamutColor(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGColorPtr(_result, false);
}

#pragma implementation_key(3187)
inline VARIANT_BOOL VGCore::IVGColor::GetIsCMYK ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsCMYK(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3188)
inline VARIANT_BOOL VGCore::IVGColor::GetIsGray ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsGray(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3189)
inline VARIANT_BOOL VGCore::IVGColor::GetIsWhite ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsWhite(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3190)
inline VARIANT_BOOL VGCore::IVGColor::GetIsSpot ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsSpot(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3191)
inline VARIANT_BOOL VGCore::IVGColor::GetIsTintable ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsTintable(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3192)
inline VARIANT_BOOL VGCore::IVGColor::GetIsValidDuotoneColor ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsValidDuotoneColor(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3193)
inline VGCore::IVGColorPtr VGCore::IVGColor::GetValidDuotoneColor ( ) {
    struct IVGColor * _result = 0;
    HRESULT _hr = get_ValidDuotoneColor(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGColorPtr(_result, false);
}

#pragma implementation_key(3194)
inline long VGCore::IVGColor::GetColorDistanceFrom ( struct IVGColor * Color ) {
    long _result = 0;
    HRESULT _hr = raw_GetColorDistanceFrom(Color, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3195)
inline VARIANT_BOOL VGCore::IVGColor::IsSimilar ( struct IVGColor * Color ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_IsSimilar(Color, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3196)
inline _bstr_t VGCore::IVGColor::ToString ( ) {
    BSTR _result = 0;
    HRESULT _hr = raw_ToString(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(3197)
inline VARIANT_BOOL VGCore::IVGColor::StringAssign ( _bstr_t ColorString ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_StringAssign(ColorString, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3198)
inline HRESULT VGCore::IVGColor::Invalidate ( ) {
    HRESULT _hr = raw_Invalidate();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(3199)
inline _bstr_t VGCore::IVGColor::GetHexValue ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_HexValue(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(3200)
inline void VGCore::IVGColor::PutHexValue ( _bstr_t pVal ) {
    HRESULT _hr = put_HexValue(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(3201)
inline VGCore::IVGColorPtr VGCore::IVGColor::GetCopy ( ) {
    struct IVGColor * _result = 0;
    HRESULT _hr = raw_GetCopy(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGColorPtr(_result, false);
}

#pragma implementation_key(3202)
inline long VGCore::IVGColor::GetRGBValue ( ) {
    long _result = 0;
    HRESULT _hr = get_RGBValue(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3203)
inline void VGCore::IVGColor::PutRGBValue ( long pVal ) {
    HRESULT _hr = put_RGBValue(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(3204)
inline HRESULT VGCore::IVGColor::CopyAppearance ( struct IVGColor * Color, struct IVGColorContext * SourceColorContext ) {
    HRESULT _hr = raw_CopyAppearance(Color, SourceColorContext);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(3205)
inline VGCore::IVGColorContextPtr VGCore::IVGColor::GetColorContext ( ) {
    struct IVGColorContext * _result = 0;
    HRESULT _hr = get_ColorContext(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGColorContextPtr(_result, false);
}

#pragma implementation_key(3206)
inline VARIANT_BOOL VGCore::IVGColor::ConvertTo ( enum cdrColorType ColorType, struct IVGColorContext * DestinationColorContext, struct IVGColorContext * SourceColorContext ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_ConvertTo(ColorType, DestinationColorContext, SourceColorContext, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3207)
inline VGCore::IVGPalettePtr VGCore::IVGColor::GetPalette ( ) {
    struct IVGPalette * _result = 0;
    HRESULT _hr = get_Palette(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGPalettePtr(_result, false);
}

#pragma implementation_key(3208)
inline HRESULT VGCore::IVGColor::SpotAssign ( _bstr_t PaletteIdentifier, long SpotColorID, long Tint ) {
    HRESULT _hr = raw_SpotAssign(PaletteIdentifier, SpotColorID, Tint);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(3209)
inline HRESULT VGCore::IVGColor::SpotAssignByName ( _bstr_t PaletteIdentifier, _bstr_t SpotColorName, long Tint ) {
    HRESULT _hr = raw_SpotAssignByName(PaletteIdentifier, SpotColorName, Tint);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(3210)
inline HRESULT VGCore::IVGColor::ConvertToPalette ( _bstr_t PaletteIdentifier ) {
    HRESULT _hr = raw_ConvertToPalette(PaletteIdentifier);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(3211)
inline long VGCore::IVGColor::GetSpotColorID ( ) {
    long _result = 0;
    HRESULT _hr = get_SpotColorID(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3212)
inline void VGCore::IVGColor::PutSpotColorID ( long pVal ) {
    HRESULT _hr = put_SpotColorID(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(3213)
inline _bstr_t VGCore::IVGColor::GetSpotColorName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_SpotColorName(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(3214)
inline HRESULT VGCore::IVGColor::PaletteAssign ( _bstr_t PaletteIdentifier, long ColorIndex ) {
    HRESULT _hr = raw_PaletteAssign(PaletteIdentifier, ColorIndex);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(3215)
inline _bstr_t VGCore::IVGColor::GetPaletteIdentifier ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_PaletteIdentifier(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(3216)
inline VARIANT_BOOL VGCore::IVGColor::GetIsColorStyle ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsColorStyle(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3217)
inline _bstr_t VGCore::IVGColor::GetColorStyleName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_ColorStyleName(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(3218)
inline HRESULT VGCore::IVGColor::ModifyColorStyleColor ( struct IVGColor * Color, VARIANT_BOOL ChangeWholeHarmony ) {
    HRESULT _hr = raw_ModifyColorStyleColor(Color, ChangeWholeHarmony);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface IVGDuotoneInk wrapper method implementations
//

#pragma implementation_key(3219)
inline VGCore::IVGColorPtr VGCore::IVGDuotoneInk::GetColor ( ) {
    struct IVGColor * _result = 0;
    HRESULT _hr = get_Color(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGColorPtr(_result, false);
}

#pragma implementation_key(3220)
inline void VGCore::IVGDuotoneInk::PutColor ( struct IVGColor * ppVal ) {
    HRESULT _hr = put_Color(ppVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(3221)
inline long VGCore::IVGDuotoneInk::GetHandleCount ( ) {
    long _result = 0;
    HRESULT _hr = get_HandleCount(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3222)
inline long VGCore::IVGDuotoneInk::GetHandleX ( long Index ) {
    long _result = 0;
    HRESULT _hr = get_HandleX(Index, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3223)
inline void VGCore::IVGDuotoneInk::PutHandleX ( long Index, long pVal ) {
    HRESULT _hr = put_HandleX(Index, pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(3224)
inline long VGCore::IVGDuotoneInk::GetHandleY ( long Index ) {
    long _result = 0;
    HRESULT _hr = get_HandleY(Index, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3225)
inline void VGCore::IVGDuotoneInk::PutHandleY ( long Index, long pVal ) {
    HRESULT _hr = put_HandleY(Index, pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(3226)
inline long VGCore::IVGDuotoneInk::AddHandle ( long x, long y ) {
    long _result = 0;
    HRESULT _hr = raw_AddHandle(x, y, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3227)
inline VARIANT_BOOL VGCore::IVGDuotoneInk::RemoveHandle ( long Index ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_RemoveHandle(Index, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3228)
inline long VGCore::IVGDuotoneInk::FindHandle ( long x, long y ) {
    long _result = 0;
    HRESULT _hr = raw_FindHandle(x, y, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3229)
inline VARIANT_BOOL VGCore::IVGDuotoneInk::Load ( _bstr_t FileName ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_Load(FileName, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3230)
inline VARIANT_BOOL VGCore::IVGDuotoneInk::Save ( _bstr_t FileName ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_Save(FileName, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3231)
inline long VGCore::IVGDuotoneInk::GetCurveLevel ( long Index ) {
    long _result = 0;
    HRESULT _hr = get_CurveLevel(Index, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3232)
inline HRESULT VGCore::IVGDuotoneInk::Reset ( ) {
    HRESULT _hr = raw_Reset();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(3233)
inline SAFEARRAY * VGCore::IVGDuotoneInk::GetCurveLevels ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_GetCurveLevels(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3234)
inline SAFEARRAY * VGCore::IVGDuotoneInk::GetHandles ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_GetHandles(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3235)
inline HRESULT VGCore::IVGDuotoneInk::PutHandles ( const _variant_t & HandleArray, long NumElements ) {
    HRESULT _hr = raw_PutHandles(HandleArray, NumElements);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface IVGFountainColor wrapper method implementations
//

#pragma implementation_key(3236)
inline long VGCore::IVGFountainColor::GetPosition ( ) {
    long _result = 0;
    HRESULT _hr = get_Position(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3237)
inline VGCore::IVGColorPtr VGCore::IVGFountainColor::GetColor ( ) {
    struct IVGColor * _result = 0;
    HRESULT _hr = get_Color(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGColorPtr(_result, false);
}

#pragma implementation_key(3238)
inline void VGCore::IVGFountainColor::PutColor ( struct IVGColor * ppVal ) {
    HRESULT _hr = put_Color(ppVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(3239)
inline HRESULT VGCore::IVGFountainColor::Move ( long NewPosition ) {
    HRESULT _hr = raw_Move(NewPosition);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(3240)
inline HRESULT VGCore::IVGFountainColor::Delete ( ) {
    HRESULT _hr = raw_Delete();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(3241)
inline long VGCore::IVGFountainColor::GetMidPoint ( ) {
    long _result = 0;
    HRESULT _hr = get_MidPoint(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3242)
inline void VGCore::IVGFountainColor::PutMidPoint ( long pVal ) {
    HRESULT _hr = put_MidPoint(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(3243)
inline enum VGCore::cdrFountainFillBlendType VGCore::IVGFountainColor::GetBlendType ( ) {
    enum cdrFountainFillBlendType _result;
    HRESULT _hr = get_BlendType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3244)
inline void VGCore::IVGFountainColor::PutBlendType ( enum cdrFountainFillBlendType pVal ) {
    HRESULT _hr = put_BlendType(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(3245)
inline unsigned char VGCore::IVGFountainColor::GetOpacity ( ) {
    unsigned char _result = 0;
    HRESULT _hr = get_Opacity(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3246)
inline void VGCore::IVGFountainColor::PutOpacity ( unsigned char pVal ) {
    HRESULT _hr = put_Opacity(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IVGFountainColors wrapper method implementations
//

#pragma implementation_key(3247)
inline VGCore::IVGFountainColorPtr VGCore::IVGFountainColors::GetItem ( long Index ) {
    struct IVGFountainColor * _result = 0;
    HRESULT _hr = get_Item(Index, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGFountainColorPtr(_result, false);
}

#pragma implementation_key(3248)
inline void VGCore::IVGFountainColors::PutItem ( long Index, struct IVGFountainColor * ppVal ) {
    HRESULT _hr = put_Item(Index, ppVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(3249)
inline IUnknownPtr VGCore::IVGFountainColors::Get_NewEnum ( ) {
    IUnknown * _result = 0;
    HRESULT _hr = get__NewEnum(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IUnknownPtr(_result, false);
}

#pragma implementation_key(3250)
inline long VGCore::IVGFountainColors::GetCount ( ) {
    long _result = 0;
    HRESULT _hr = get_Count(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3251)
inline HRESULT VGCore::IVGFountainColors::Add ( struct IVGColor * Color, long Position ) {
    HRESULT _hr = raw_Add(Color, Position);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(3252)
inline long VGCore::IVGFountainColors::GetGrayLevel ( long Index ) {
    long _result = 0;
    HRESULT _hr = get_GrayLevel(Index, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3253)
inline void VGCore::IVGFountainColors::PutGrayLevel ( long Index, long pVal ) {
    HRESULT _hr = put_GrayLevel(Index, pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(3254)
inline HRESULT VGCore::IVGFountainColors::AddGrayLevel ( long GrayLevel, long Position ) {
    HRESULT _hr = raw_AddGrayLevel(GrayLevel, Position);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(3255)
inline VGCore::IVGFountainColorPtr VGCore::IVGFountainColors::GetFirst ( ) {
    struct IVGFountainColor * _result = 0;
    HRESULT _hr = get_First(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGFountainColorPtr(_result, false);
}

#pragma implementation_key(3256)
inline VGCore::IVGFountainColorPtr VGCore::IVGFountainColors::GetLast ( ) {
    struct IVGFountainColor * _result = 0;
    HRESULT _hr = get_Last(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGFountainColorPtr(_result, false);
}

//
// interface IVGFountainFill wrapper method implementations
//

#pragma implementation_key(3257)
inline enum VGCore::cdrFountainFillType VGCore::IVGFountainFill::GetType ( ) {
    enum cdrFountainFillType _result;
    HRESULT _hr = get_Type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3258)
inline void VGCore::IVGFountainFill::PutType ( enum cdrFountainFillType pVal ) {
    HRESULT _hr = put_Type(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(3259)
inline double VGCore::IVGFountainFill::GetStartX ( ) {
    double _result = 0;
    HRESULT _hr = get_StartX(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3260)
inline void VGCore::IVGFountainFill::PutStartX ( double pVal ) {
    HRESULT _hr = put_StartX(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(3261)
inline double VGCore::IVGFountainFill::GetStartY ( ) {
    double _result = 0;
    HRESULT _hr = get_StartY(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3262)
inline void VGCore::IVGFountainFill::PutStartY ( double pVal ) {
    HRESULT _hr = put_StartY(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(3263)
inline double VGCore::IVGFountainFill::GetEndX ( ) {
    double _result = 0;
    HRESULT _hr = get_EndX(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3264)
inline void VGCore::IVGFountainFill::PutEndX ( double pVal ) {
    HRESULT _hr = put_EndX(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(3265)
inline double VGCore::IVGFountainFill::GetEndY ( ) {
    double _result = 0;
    HRESULT _hr = get_EndY(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3266)
inline void VGCore::IVGFountainFill::PutEndY ( double pVal ) {
    HRESULT _hr = put_EndY(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(3267)
inline double VGCore::IVGFountainFill::GetAngle ( ) {
    double _result = 0;
    HRESULT _hr = get_Angle(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3268)
inline HRESULT VGCore::IVGFountainFill::SetAngle ( double Angle ) {
    HRESULT _hr = raw_SetAngle(Angle);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(3269)
inline HRESULT VGCore::IVGFountainFill::Translate ( double x, double y ) {
    HRESULT _hr = raw_Translate(x, y);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(3270)
inline long VGCore::IVGFountainFill::GetEdgePad ( ) {
    long _result = 0;
    HRESULT _hr = get_EdgePad(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3271)
inline long VGCore::IVGFountainFill::GetSteps ( ) {
    long _result = 0;
    HRESULT _hr = get_Steps(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3272)
inline void VGCore::IVGFountainFill::PutSteps ( long pVal ) {
    HRESULT _hr = put_Steps(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(3273)
inline enum VGCore::cdrFountainFillBlendType VGCore::IVGFountainFill::GetBlendType ( ) {
    enum cdrFountainFillBlendType _result;
    HRESULT _hr = get_BlendType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3274)
inline void VGCore::IVGFountainFill::PutBlendType ( enum cdrFountainFillBlendType pVal ) {
    HRESULT _hr = put_BlendType(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(3275)
inline long VGCore::IVGFountainFill::GetMidPoint ( ) {
    long _result = 0;
    HRESULT _hr = get_MidPoint(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3276)
inline void VGCore::IVGFountainFill::PutMidPoint ( long pVal ) {
    HRESULT _hr = put_MidPoint(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(3277)
inline VGCore::IVGFountainColorsPtr VGCore::IVGFountainFill::GetColors ( ) {
    struct IVGFountainColors * _result = 0;
    HRESULT _hr = get_Colors(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGFountainColorsPtr(_result, false);
}

#pragma implementation_key(3278)
inline VGCore::IVGColorPtr VGCore::IVGFountainFill::GetStartColor ( ) {
    struct IVGColor * _result = 0;
    HRESULT _hr = get_StartColor(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGColorPtr(_result, false);
}

#pragma implementation_key(3279)
inline void VGCore::IVGFountainFill::PutStartColor ( struct IVGColor * ppVal ) {
    HRESULT _hr = put_StartColor(ppVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(3280)
inline VGCore::IVGColorPtr VGCore::IVGFountainFill::GetEndColor ( ) {
    struct IVGColor * _result = 0;
    HRESULT _hr = get_EndColor(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGColorPtr(_result, false);
}

#pragma implementation_key(3281)
inline void VGCore::IVGFountainFill::PutEndColor ( struct IVGColor * ppVal ) {
    HRESULT _hr = put_EndColor(ppVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(3282)
inline void VGCore::IVGFountainFill::PutColors ( struct IVGFountainColors * ppVal ) {
    HRESULT _hr = put_Colors(ppVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(3283)
inline HRESULT VGCore::IVGFountainFill::SetEdgePad ( long EdgePad ) {
    HRESULT _hr = raw_SetEdgePad(EdgePad);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(3284)
inline double VGCore::IVGFountainFill::GetCenterOffsetX ( ) {
    double _result = 0;
    HRESULT _hr = get_CenterOffsetX(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3285)
inline void VGCore::IVGFountainFill::PutCenterOffsetX ( double pVal ) {
    HRESULT _hr = put_CenterOffsetX(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(3286)
inline double VGCore::IVGFountainFill::GetCenterOffsetY ( ) {
    double _result = 0;
    HRESULT _hr = get_CenterOffsetY(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3287)
inline void VGCore::IVGFountainFill::PutCenterOffsetY ( double pVal ) {
    HRESULT _hr = put_CenterOffsetY(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(3288)
inline VARIANT_BOOL VGCore::IVGFountainFill::GetSmoothBlend ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_SmoothBlend(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3289)
inline void VGCore::IVGFountainFill::PutSmoothBlend ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_SmoothBlend(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(3290)
inline enum VGCore::cdrFountainFillSpreadMethod VGCore::IVGFountainFill::GetSpreadMethod ( ) {
    enum cdrFountainFillSpreadMethod _result;
    HRESULT _hr = get_SpreadMethod(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3291)
inline void VGCore::IVGFountainFill::PutSpreadMethod ( enum cdrFountainFillSpreadMethod pVal ) {
    HRESULT _hr = put_SpreadMethod(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(3292)
inline VARIANT_BOOL VGCore::IVGFountainFill::GetAnisotropic ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_Anisotropic(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3293)
inline void VGCore::IVGFountainFill::PutAnisotropic ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_Anisotropic(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(3294)
inline VARIANT_BOOL VGCore::IVGFountainFill::GetIsTransparent ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsTransparent(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3295)
inline enum VGCore::cdrMergeMode VGCore::IVGFountainFill::GetMergeMode ( ) {
    enum cdrMergeMode _result;
    HRESULT _hr = get_MergeMode(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3296)
inline void VGCore::IVGFountainFill::PutMergeMode ( enum cdrMergeMode pVal ) {
    HRESULT _hr = put_MergeMode(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(3297)
inline double VGCore::IVGFountainFill::GetScaleX ( ) {
    double _result = 0;
    HRESULT _hr = get_ScaleX(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3298)
inline void VGCore::IVGFountainFill::PutScaleX ( double pVal ) {
    HRESULT _hr = put_ScaleX(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(3299)
inline double VGCore::IVGFountainFill::GetScaleY ( ) {
    double _result = 0;
    HRESULT _hr = get_ScaleY(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3300)
inline void VGCore::IVGFountainFill::PutScaleY ( double pVal ) {
    HRESULT _hr = put_ScaleY(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(3301)
inline double VGCore::IVGFountainFill::GetSkew ( ) {
    double _result = 0;
    HRESULT _hr = get_Skew(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3302)
inline void VGCore::IVGFountainFill::PutSkew ( double pVal ) {
    HRESULT _hr = put_Skew(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(3303)
inline double VGCore::IVGFountainFill::GetBlendAcceleration ( ) {
    double _result = 0;
    HRESULT _hr = get_BlendAcceleration(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3304)
inline void VGCore::IVGFountainFill::PutBlendAcceleration ( double pVal ) {
    HRESULT _hr = put_BlendAcceleration(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(3305)
inline HRESULT VGCore::IVGFountainFill::MakeOpaque ( ) {
    HRESULT _hr = raw_MakeOpaque();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(3306)
inline HRESULT VGCore::IVGFountainFill::GetTransformations ( double * d11, double * d12, double * d21, double * d22 ) {
    HRESULT _hr = raw_GetTransformations(d11, d12, d21, d22);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(3307)
inline HRESULT VGCore::IVGFountainFill::SetTransformations ( double d11, double d12, double d21, double d22 ) {
    HRESULT _hr = raw_SetTransformations(d11, d12, d21, d22);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(3308)
inline VARIANT_BOOL VGCore::IVGFountainFill::GetHasHSBBlends ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_HasHSBBlends(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3309)
inline VARIANT_BOOL VGCore::IVGFountainFill::GetHasNonLinearBlends ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_HasNonLinearBlends(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3310)
inline double VGCore::IVGFountainFill::GetEnd2X ( ) {
    double _result = 0;
    HRESULT _hr = get_End2X(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3311)
inline void VGCore::IVGFountainFill::PutEnd2X ( double pVal ) {
    HRESULT _hr = put_End2X(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(3312)
inline double VGCore::IVGFountainFill::GetEnd2Y ( ) {
    double _result = 0;
    HRESULT _hr = get_End2Y(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3313)
inline void VGCore::IVGFountainFill::PutEnd2Y ( double pVal ) {
    HRESULT _hr = put_End2Y(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IVGPatternFill wrapper method implementations
//

#pragma implementation_key(3314)
inline enum VGCore::cdrPatternFillType VGCore::IVGPatternFill::GetType ( ) {
    enum cdrPatternFillType _result;
    HRESULT _hr = get_Type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3315)
inline void VGCore::IVGPatternFill::PutType ( enum cdrPatternFillType pVal ) {
    HRESULT _hr = put_Type(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(3316)
inline VGCore::IVGColorPtr VGCore::IVGPatternFill::GetFrontColor ( ) {
    struct IVGColor * _result = 0;
    HRESULT _hr = get_FrontColor(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGColorPtr(_result, false);
}

#pragma implementation_key(3317)
inline void VGCore::IVGPatternFill::PutFrontColor ( struct IVGColor * ppVal ) {
    HRESULT _hr = put_FrontColor(ppVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(3318)
inline VGCore::IVGColorPtr VGCore::IVGPatternFill::GetBackColor ( ) {
    struct IVGColor * _result = 0;
    HRESULT _hr = get_BackColor(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGColorPtr(_result, false);
}

#pragma implementation_key(3319)
inline void VGCore::IVGPatternFill::PutBackColor ( struct IVGColor * ppVal ) {
    HRESULT _hr = put_BackColor(ppVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(3320)
inline VGCore::IVGPatternCanvasPtr VGCore::IVGPatternFill::GetCanvas ( ) {
    struct IVGPatternCanvas * _result = 0;
    HRESULT _hr = get_Canvas(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGPatternCanvasPtr(_result, false);
}

#pragma implementation_key(3321)
inline void VGCore::IVGPatternFill::PutCanvas ( struct IVGPatternCanvas * ppVal ) {
    HRESULT _hr = put_Canvas(ppVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(3322)
inline _bstr_t VGCore::IVGPatternFill::GetFilePath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_FilePath(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(3323)
inline double VGCore::IVGPatternFill::GetOriginX ( ) {
    double _result = 0;
    HRESULT _hr = get_OriginX(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3324)
inline void VGCore::IVGPatternFill::PutOriginX ( double pVal ) {
    HRESULT _hr = put_OriginX(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(3325)
inline double VGCore::IVGPatternFill::GetOriginY ( ) {
    double _result = 0;
    HRESULT _hr = get_OriginY(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3326)
inline void VGCore::IVGPatternFill::PutOriginY ( double pVal ) {
    HRESULT _hr = put_OriginY(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(3327)
inline double VGCore::IVGPatternFill::GetTileWidth ( ) {
    double _result = 0;
    HRESULT _hr = get_TileWidth(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3328)
inline void VGCore::IVGPatternFill::PutTileWidth ( double pVal ) {
    HRESULT _hr = put_TileWidth(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(3329)
inline double VGCore::IVGPatternFill::GetTileHeight ( ) {
    double _result = 0;
    HRESULT _hr = get_TileHeight(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3330)
inline void VGCore::IVGPatternFill::PutTileHeight ( double pVal ) {
    HRESULT _hr = put_TileHeight(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(3331)
inline enum VGCore::cdrTileOffsetType VGCore::IVGPatternFill::GetTileOffsetType ( ) {
    enum cdrTileOffsetType _result;
    HRESULT _hr = get_TileOffsetType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3332)
inline void VGCore::IVGPatternFill::PutTileOffsetType ( enum cdrTileOffsetType pVal ) {
    HRESULT _hr = put_TileOffsetType(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(3333)
inline long VGCore::IVGPatternFill::GetTileOffset ( ) {
    long _result = 0;
    HRESULT _hr = get_TileOffset(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3334)
inline void VGCore::IVGPatternFill::PutTileOffset ( long pVal ) {
    HRESULT _hr = put_TileOffset(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(3335)
inline double VGCore::IVGPatternFill::GetSkewAngle ( ) {
    double _result = 0;
    HRESULT _hr = get_SkewAngle(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3336)
inline void VGCore::IVGPatternFill::PutSkewAngle ( double pVal ) {
    HRESULT _hr = put_SkewAngle(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(3337)
inline double VGCore::IVGPatternFill::GetRotationAngle ( ) {
    double _result = 0;
    HRESULT _hr = get_RotationAngle(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3338)
inline void VGCore::IVGPatternFill::PutRotationAngle ( double pVal ) {
    HRESULT _hr = put_RotationAngle(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(3339)
inline VARIANT_BOOL VGCore::IVGPatternFill::GetTransformWithShape ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_TransformWithShape(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3340)
inline void VGCore::IVGPatternFill::PutTransformWithShape ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_TransformWithShape(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(3341)
inline VARIANT_BOOL VGCore::IVGPatternFill::Load ( _bstr_t FileName ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_Load(FileName, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3342)
inline VARIANT_BOOL VGCore::IVGPatternFill::GetMirrorFill ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_MirrorFill(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3343)
inline void VGCore::IVGPatternFill::PutMirrorFill ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_MirrorFill(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(3344)
inline VARIANT_BOOL VGCore::IVGPatternFill::GetMirrorFillX ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_MirrorFillX(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3345)
inline void VGCore::IVGPatternFill::PutMirrorFillX ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_MirrorFillX(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(3346)
inline VARIANT_BOOL VGCore::IVGPatternFill::GetMirrorFillY ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_MirrorFillY(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3347)
inline void VGCore::IVGPatternFill::PutMirrorFillY ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_MirrorFillY(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IVGOutline wrapper method implementations
//

#pragma implementation_key(3348)
inline double VGCore::IVGOutline::GetWidth ( ) {
    double _result = 0;
    HRESULT _hr = get_Width(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3349)
inline void VGCore::IVGOutline::PutWidth ( double pVal ) {
    HRESULT _hr = put_Width(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(3350)
inline VGCore::IVGColorPtr VGCore::IVGOutline::GetColor ( ) {
    struct IVGColor * _result = 0;
    HRESULT _hr = get_Color(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGColorPtr(_result, false);
}

#pragma implementation_key(3351)
inline void VGCore::IVGOutline::PutColor ( struct IVGColor * ppVal ) {
    HRESULT _hr = put_Color(ppVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(3352)
inline VGCore::IVGShapePtr VGCore::IVGOutline::ConvertToObject ( ) {
    struct IVGShape * _result = 0;
    HRESULT _hr = raw_ConvertToObject(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGShapePtr(_result, false);
}

#pragma implementation_key(3353)
inline enum VGCore::cdrOutlineType VGCore::IVGOutline::GetType ( ) {
    enum cdrOutlineType _result;
    HRESULT _hr = get_Type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3354)
inline void VGCore::IVGOutline::PutType ( enum cdrOutlineType Type ) {
    HRESULT _hr = put_Type(Type);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(3355)
inline VGCore::IVGOutlineStylePtr VGCore::IVGOutline::GetStyle ( ) {
    struct IVGOutlineStyle * _result = 0;
    HRESULT _hr = get_Style(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGOutlineStylePtr(_result, false);
}

#pragma implementation_key(3356)
inline void VGCore::IVGOutline::PutStyle ( struct IVGOutlineStyle * ppStyle ) {
    HRESULT _hr = put_Style(ppStyle);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(3357)
inline VGCore::IVGArrowHeadPtr VGCore::IVGOutline::GetStartArrow ( ) {
    struct IVGArrowHead * _result = 0;
    HRESULT _hr = get_StartArrow(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGArrowHeadPtr(_result, false);
}

#pragma implementation_key(3358)
inline void VGCore::IVGOutline::PutStartArrow ( struct IVGArrowHead * ppArrowHead ) {
    HRESULT _hr = put_StartArrow(ppArrowHead);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(3359)
inline VGCore::IVGArrowHeadPtr VGCore::IVGOutline::GetEndArrow ( ) {
    struct IVGArrowHead * _result = 0;
    HRESULT _hr = get_EndArrow(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGArrowHeadPtr(_result, false);
}

#pragma implementation_key(3360)
inline void VGCore::IVGOutline::PutEndArrow ( struct IVGArrowHead * ppArrowHead ) {
    HRESULT _hr = put_EndArrow(ppArrowHead);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(3361)
inline long VGCore::IVGOutline::GetNibStretch ( ) {
    long _result = 0;
    HRESULT _hr = get_NibStretch(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3362)
inline void VGCore::IVGOutline::PutNibStretch ( long pVal ) {
    HRESULT _hr = put_NibStretch(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(3363)
inline double VGCore::IVGOutline::GetNibAngle ( ) {
    double _result = 0;
    HRESULT _hr = get_NibAngle(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3364)
inline void VGCore::IVGOutline::PutNibAngle ( double pVal ) {
    HRESULT _hr = put_NibAngle(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(3365)
inline VARIANT_BOOL VGCore::IVGOutline::GetBehindFill ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_BehindFill(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3366)
inline void VGCore::IVGOutline::PutBehindFill ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_BehindFill(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(3367)
inline enum VGCore::cdrOutlineLineCaps VGCore::IVGOutline::GetLineCaps ( ) {
    enum cdrOutlineLineCaps _result;
    HRESULT _hr = get_LineCaps(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3368)
inline void VGCore::IVGOutline::PutLineCaps ( enum cdrOutlineLineCaps pVal ) {
    HRESULT _hr = put_LineCaps(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(3369)
inline enum VGCore::cdrOutlineLineJoin VGCore::IVGOutline::GetLineJoin ( ) {
    enum cdrOutlineLineJoin _result;
    HRESULT _hr = get_LineJoin(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3370)
inline void VGCore::IVGOutline::PutLineJoin ( enum cdrOutlineLineJoin pVal ) {
    HRESULT _hr = put_LineJoin(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(3371)
inline VARIANT_BOOL VGCore::IVGOutline::GetScaleWithShape ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_ScaleWithShape(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3372)
inline void VGCore::IVGOutline::PutScaleWithShape ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_ScaleWithShape(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(3373)
inline HRESULT VGCore::IVGOutline::SetProperties ( double Width, struct IVGOutlineStyle * Style, struct IVGColor * Color, struct IVGArrowHead * StartArrow, struct IVGArrowHead * EndArrow, enum cdrTriState BehindFill, enum cdrTriState ScaleWithShape, enum cdrOutlineLineCaps LineCaps, enum cdrOutlineLineJoin LineJoin, double NibAngle, long NibStretch, double DashDotLength, double PenWidth, double MiterLimit ) {
    HRESULT _hr = raw_SetProperties(Width, Style, Color, StartArrow, EndArrow, BehindFill, ScaleWithShape, LineCaps, LineJoin, NibAngle, NibStretch, DashDotLength, PenWidth, MiterLimit);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(3374)
inline double VGCore::IVGOutline::GetSize ( ) {
    double _result = 0;
    HRESULT _hr = get_Size(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3375)
inline void VGCore::IVGOutline::PutSize ( double pVal ) {
    HRESULT _hr = put_Size(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(3376)
inline VGCore::IVGOutlinePtr VGCore::IVGOutline::GetCopy ( ) {
    struct IVGOutline * _result = 0;
    HRESULT _hr = raw_GetCopy(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGOutlinePtr(_result, false);
}

#pragma implementation_key(3377)
inline HRESULT VGCore::IVGOutline::CopyAssign ( struct IVGOutline * SourceOutline ) {
    HRESULT _hr = raw_CopyAssign(SourceOutline);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(3378)
inline VARIANT_BOOL VGCore::IVGOutline::UserAssign ( long ParentWindowHandle ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_UserAssign(ParentWindowHandle, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3379)
inline VGCore::IVGPSScreenOptionsPtr VGCore::IVGOutline::GetPSScreen ( ) {
    struct IVGPSScreenOptions * _result = 0;
    HRESULT _hr = get_PSScreen(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGPSScreenOptionsPtr(_result, false);
}

#pragma implementation_key(3380)
inline VARIANT_BOOL VGCore::IVGOutline::CompareWith ( struct IVGOutline * Outline ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_CompareWith(Outline, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3381)
inline double VGCore::IVGOutline::GetDashDotLength ( ) {
    double _result = 0;
    HRESULT _hr = get_DashDotLength(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3382)
inline void VGCore::IVGOutline::PutDashDotLength ( double pVal ) {
    HRESULT _hr = put_DashDotLength(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(3383)
inline _bstr_t VGCore::IVGOutline::ToString ( ) {
    BSTR _result = 0;
    HRESULT _hr = raw_ToString(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(3384)
inline VARIANT_BOOL VGCore::IVGOutline::StringAssign ( _bstr_t OutlineString ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_StringAssign(OutlineString, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3385)
inline double VGCore::IVGOutline::GetPenWidth ( ) {
    double _result = 0;
    HRESULT _hr = get_PenWidth(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3386)
inline void VGCore::IVGOutline::PutPenWidth ( double pVal ) {
    HRESULT _hr = put_PenWidth(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(3387)
inline double VGCore::IVGOutline::GetMiterLimit ( ) {
    double _result = 0;
    HRESULT _hr = get_MiterLimit(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3388)
inline void VGCore::IVGOutline::PutMiterLimit ( double pVal ) {
    HRESULT _hr = put_MiterLimit(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(3389)
inline HRESULT VGCore::IVGOutline::SetNoOutline ( ) {
    HRESULT _hr = raw_SetNoOutline();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(3390)
inline VGCore::IVGArrowHeadOptionsPtr VGCore::IVGOutline::GetStartArrowOptions ( ) {
    struct IVGArrowHeadOptions * _result = 0;
    HRESULT _hr = get_StartArrowOptions(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGArrowHeadOptionsPtr(_result, false);
}

#pragma implementation_key(3391)
inline void VGCore::IVGOutline::PutStartArrowOptions ( struct IVGArrowHeadOptions * ppVal ) {
    HRESULT _hr = put_StartArrowOptions(ppVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(3392)
inline VGCore::IVGArrowHeadOptionsPtr VGCore::IVGOutline::GetEndArrowOptions ( ) {
    struct IVGArrowHeadOptions * _result = 0;
    HRESULT _hr = get_EndArrowOptions(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGArrowHeadOptionsPtr(_result, false);
}

#pragma implementation_key(3393)
inline void VGCore::IVGOutline::PutEndArrowOptions ( struct IVGArrowHeadOptions * ppVal ) {
    HRESULT _hr = put_EndArrowOptions(ppVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(3394)
inline enum VGCore::cdrOutlineJustification VGCore::IVGOutline::GetJustification ( ) {
    enum cdrOutlineJustification _result;
    HRESULT _hr = get_Justification(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3395)
inline void VGCore::IVGOutline::PutJustification ( enum cdrOutlineJustification pVal ) {
    HRESULT _hr = put_Justification(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(3396)
inline HRESULT VGCore::IVGOutline::SetPropertiesEx ( double Width, struct IVGOutlineStyle * Style, struct IVGColor * Color, struct IVGArrowHead * StartArrow, struct IVGArrowHead * EndArrow, enum cdrTriState BehindFill, enum cdrTriState ScaleWithShape, enum cdrOutlineLineCaps LineCaps, enum cdrOutlineLineJoin LineJoin, double NibAngle, long NibStretch, double DashDotLength, double PenWidth, double MiterLimit, enum cdrOutlineJustification Justification ) {
    HRESULT _hr = raw_SetPropertiesEx(Width, Style, Color, StartArrow, EndArrow, BehindFill, ScaleWithShape, LineCaps, LineJoin, NibAngle, NibStretch, DashDotLength, PenWidth, MiterLimit, Justification);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(3397)
inline enum VGCore::cdrOutlineDashAdjust VGCore::IVGOutline::GetAdjustDashes ( ) {
    enum cdrOutlineDashAdjust _result;
    HRESULT _hr = get_AdjustDashes(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3398)
inline void VGCore::IVGOutline::PutAdjustDashes ( enum cdrOutlineDashAdjust pVal ) {
    HRESULT _hr = put_AdjustDashes(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IVGHatchPattern wrapper method implementations
//

#pragma implementation_key(3399)
inline double VGCore::IVGHatchPattern::GetAngle ( ) {
    double _result = 0;
    HRESULT _hr = get_Angle(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3400)
inline void VGCore::IVGHatchPattern::PutAngle ( double pVal ) {
    HRESULT _hr = put_Angle(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(3401)
inline double VGCore::IVGHatchPattern::GetOriginX ( ) {
    double _result = 0;
    HRESULT _hr = get_OriginX(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3402)
inline void VGCore::IVGHatchPattern::PutOriginX ( double pVal ) {
    HRESULT _hr = put_OriginX(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(3403)
inline double VGCore::IVGHatchPattern::GetOriginY ( ) {
    double _result = 0;
    HRESULT _hr = get_OriginY(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3404)
inline void VGCore::IVGHatchPattern::PutOriginY ( double pVal ) {
    HRESULT _hr = put_OriginY(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(3405)
inline double VGCore::IVGHatchPattern::GetSpacing ( ) {
    double _result = 0;
    HRESULT _hr = get_Spacing(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3406)
inline void VGCore::IVGHatchPattern::PutSpacing ( double pVal ) {
    HRESULT _hr = put_Spacing(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(3407)
inline double VGCore::IVGHatchPattern::GetShift ( ) {
    double _result = 0;
    HRESULT _hr = get_Shift(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3408)
inline void VGCore::IVGHatchPattern::PutShift ( double pVal ) {
    HRESULT _hr = put_Shift(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(3409)
inline double VGCore::IVGHatchPattern::GetShiftPercent ( ) {
    double _result = 0;
    HRESULT _hr = get_ShiftPercent(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3410)
inline void VGCore::IVGHatchPattern::PutShiftPercent ( double pVal ) {
    HRESULT _hr = put_ShiftPercent(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(3411)
inline VGCore::IVGOutlinePtr VGCore::IVGHatchPattern::GetOutline ( ) {
    struct IVGOutline * _result = 0;
    HRESULT _hr = get_Outline(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGOutlinePtr(_result, false);
}

#pragma implementation_key(3412)
inline long VGCore::IVGHatchPattern::GetIndex ( ) {
    long _result = 0;
    HRESULT _hr = get_Index(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3413)
inline HRESULT VGCore::IVGHatchPattern::Delete ( ) {
    HRESULT _hr = raw_Delete();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(3414)
inline HRESULT VGCore::IVGHatchPattern::SetOrigin ( double OriginX, double OriginY ) {
    HRESULT _hr = raw_SetOrigin(OriginX, OriginY);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(3415)
inline HRESULT VGCore::IVGHatchPattern::GetOrigin ( double * OriginX, double * OriginY ) {
    HRESULT _hr = raw_GetOrigin(OriginX, OriginY);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(3416)
inline HRESULT VGCore::IVGHatchPattern::SetProperties ( const _variant_t & Angle, double Spacing, const _variant_t & Shift, const _variant_t & OriginX, const _variant_t & OriginY, double Width, struct IVGColor * Color, struct IVGOutlineStyle * Style, double DashDotLength, double PenWidth ) {
    HRESULT _hr = raw_SetProperties(Angle, Spacing, Shift, OriginX, OriginY, Width, Color, Style, DashDotLength, PenWidth);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(3417)
inline HRESULT VGCore::IVGHatchPattern::Reset ( ) {
    HRESULT _hr = raw_Reset();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface IVGHatchPatterns wrapper method implementations
//

#pragma implementation_key(3418)
inline long VGCore::IVGHatchPatterns::GetCount ( ) {
    long _result = 0;
    HRESULT _hr = get_Count(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3419)
inline VGCore::IVGHatchPatternPtr VGCore::IVGHatchPatterns::GetItem ( long Index ) {
    struct IVGHatchPattern * _result = 0;
    HRESULT _hr = get_Item(Index, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGHatchPatternPtr(_result, false);
}

#pragma implementation_key(3420)
inline IUnknownPtr VGCore::IVGHatchPatterns::Get_NewEnum ( ) {
    IUnknown * _result = 0;
    HRESULT _hr = get__NewEnum(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IUnknownPtr(_result, false);
}

#pragma implementation_key(3421)
inline HRESULT VGCore::IVGHatchPatterns::Reset ( ) {
    HRESULT _hr = raw_Reset();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface IVGImage wrapper method implementations
//

#pragma implementation_key(3422)
inline enum VGCore::cdrImageType VGCore::IVGImage::GetType ( ) {
    enum cdrImageType _result;
    HRESULT _hr = get_Type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3423)
inline long VGCore::IVGImage::GetWidth ( ) {
    long _result = 0;
    HRESULT _hr = get_Width(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3424)
inline long VGCore::IVGImage::GetHeight ( ) {
    long _result = 0;
    HRESULT _hr = get_Height(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3425)
inline VGCore::IVGColorPtr VGCore::IVGImage::GetPixel ( long x, long y ) {
    struct IVGColor * _result = 0;
    HRESULT _hr = get_Pixel(x, y, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGColorPtr(_result, false);
}

#pragma implementation_key(3426)
inline VGCore::IVGImagePtr VGCore::IVGImage::GetCopy ( ) {
    struct IVGImage * _result = 0;
    HRESULT _hr = raw_GetCopy(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGImagePtr(_result, false);
}

#pragma implementation_key(3427)
inline VARIANT_BOOL VGCore::IVGImage::GetReadOnly ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_ReadOnly(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3428)
inline VGCore::IVGImageTilesPtr VGCore::IVGImage::GetTiles ( ) {
    struct IVGImageTiles * _result = 0;
    HRESULT _hr = get_Tiles(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGImageTilesPtr(_result, false);
}

#pragma implementation_key(3429)
inline HRESULT VGCore::IVGImage::Blit ( long DestX, long DestY, long DestWidth, long DestHeight, struct IVGImage * SrcImage, long SrcX, long SrcY, long SrcWidth, long SrcHeight, enum cdrMergeMode MergeMode ) {
    HRESULT _hr = raw_Blit(DestX, DestY, DestWidth, DestHeight, SrcImage, SrcX, SrcY, SrcWidth, SrcHeight, MergeMode);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(3430)
inline HRESULT VGCore::IVGImage::FillArea ( long x, long y, long Width, long Height, struct IVGColor * Color ) {
    HRESULT _hr = raw_FillArea(x, y, Width, Height, Color);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(3431)
inline HRESULT VGCore::IVGImage::FlipArea ( long x, long y, long Width, long Height, enum cdrFlipAxes Axes ) {
    HRESULT _hr = raw_FlipArea(x, y, Width, Height, Axes);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface IVGTransparency wrapper method implementations
//

#pragma implementation_key(3432)
inline IDispatchPtr VGCore::IVGTransparency::GetApplication ( ) {
    IDispatch * _result = 0;
    HRESULT _hr = get_Application(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IDispatchPtr(_result, false);
}

#pragma implementation_key(3433)
inline IDispatchPtr VGCore::IVGTransparency::GetParent ( ) {
    IDispatch * _result = 0;
    HRESULT _hr = get_Parent(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IDispatchPtr(_result, false);
}

#pragma implementation_key(3434)
inline enum VGCore::cdrTransparencyType VGCore::IVGTransparency::GetType ( ) {
    enum cdrTransparencyType _result;
    HRESULT _hr = get_Type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3435)
inline long VGCore::IVGTransparency::GetUniform ( ) {
    long _result = 0;
    HRESULT _hr = get_Uniform(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3436)
inline void VGCore::IVGTransparency::PutUniform ( long pVal ) {
    HRESULT _hr = put_Uniform(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(3437)
inline VGCore::IVGFountainFillPtr VGCore::IVGTransparency::GetFountain ( ) {
    struct IVGFountainFill * _result = 0;
    HRESULT _hr = get_Fountain(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGFountainFillPtr(_result, false);
}

#pragma implementation_key(3438)
inline void VGCore::IVGTransparency::PutFountain ( struct IVGFountainFill * ppVal ) {
    HRESULT _hr = put_Fountain(ppVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(3439)
inline VGCore::IVGPatternFillPtr VGCore::IVGTransparency::GetPattern ( ) {
    struct IVGPatternFill * _result = 0;
    HRESULT _hr = get_Pattern(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGPatternFillPtr(_result, false);
}

#pragma implementation_key(3440)
inline void VGCore::IVGTransparency::PutPattern ( struct IVGPatternFill * ppVal ) {
    HRESULT _hr = put_Pattern(ppVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(3441)
inline VGCore::IVGTextureFillPtr VGCore::IVGTransparency::GetTexture ( ) {
    struct IVGTextureFill * _result = 0;
    HRESULT _hr = get_Texture(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGTextureFillPtr(_result, false);
}

#pragma implementation_key(3442)
inline void VGCore::IVGTransparency::PutTexture ( struct IVGTextureFill * ppVal ) {
    HRESULT _hr = put_Texture(ppVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(3443)
inline long VGCore::IVGTransparency::GetStart ( ) {
    long _result = 0;
    HRESULT _hr = get_Start(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3444)
inline void VGCore::IVGTransparency::PutStart ( long pVal ) {
    HRESULT _hr = put_Start(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(3445)
inline long VGCore::IVGTransparency::GetEnd ( ) {
    long _result = 0;
    HRESULT _hr = get_End(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3446)
inline void VGCore::IVGTransparency::PutEnd ( long pVal ) {
    HRESULT _hr = put_End(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(3447)
inline VARIANT_BOOL VGCore::IVGTransparency::GetFrozen ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_Frozen(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3448)
inline HRESULT VGCore::IVGTransparency::ApplyNoTransparency ( ) {
    HRESULT _hr = raw_ApplyNoTransparency();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(3449)
inline HRESULT VGCore::IVGTransparency::ApplyUniformTransparency ( long Value ) {
    HRESULT _hr = raw_ApplyUniformTransparency(Value);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(3450)
inline VGCore::IVGFountainFillPtr VGCore::IVGTransparency::ApplyFountainTransparency ( long Start, long End, enum cdrFountainFillType Type, double Angle, long Steps, long EdgePad, long MidPoint, double CenterOffsetX, double CenterOffsetY ) {
    struct IVGFountainFill * _result = 0;
    HRESULT _hr = raw_ApplyFountainTransparency(Start, End, Type, Angle, Steps, EdgePad, MidPoint, CenterOffsetX, CenterOffsetY, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGFountainFillPtr(_result, false);
}

#pragma implementation_key(3451)
inline VGCore::IVGPatternFillPtr VGCore::IVGTransparency::ApplyPatternTransparency ( enum cdrPatternFillType Type, _bstr_t FileName, long PatternCanvasIndex, long Front, long Back, VARIANT_BOOL TransformWithShape ) {
    struct IVGPatternFill * _result = 0;
    HRESULT _hr = raw_ApplyPatternTransparency(Type, FileName, PatternCanvasIndex, Front, Back, TransformWithShape, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGPatternFillPtr(_result, false);
}

#pragma implementation_key(3452)
inline VGCore::IVGTextureFillPtr VGCore::IVGTransparency::ApplyTextureTransparency ( _bstr_t TextureName, _bstr_t LibraryName, long Front, long Back ) {
    struct IVGTextureFill * _result = 0;
    HRESULT _hr = raw_ApplyTextureTransparency(TextureName, LibraryName, Front, Back, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGTextureFillPtr(_result, false);
}

#pragma implementation_key(3453)
inline HRESULT VGCore::IVGTransparency::Freeze ( ) {
    HRESULT _hr = raw_Freeze();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(3454)
inline HRESULT VGCore::IVGTransparency::Unfreeze ( ) {
    HRESULT _hr = raw_Unfreeze();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(3455)
inline enum VGCore::cdrTransparencyAppliedTo VGCore::IVGTransparency::GetAppliedTo ( ) {
    enum cdrTransparencyAppliedTo _result;
    HRESULT _hr = get_AppliedTo(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3456)
inline void VGCore::IVGTransparency::PutAppliedTo ( enum cdrTransparencyAppliedTo pVal ) {
    HRESULT _hr = put_AppliedTo(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(3457)
inline enum VGCore::cdrMergeMode VGCore::IVGTransparency::GetMergeMode ( ) {
    enum cdrMergeMode _result;
    HRESULT _hr = get_MergeMode(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3458)
inline void VGCore::IVGTransparency::PutMergeMode ( enum cdrMergeMode pVal ) {
    HRESULT _hr = put_MergeMode(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(3459)
inline VARIANT_BOOL VGCore::IVGTransparency::UserAssign ( enum cdrTransparencyType TransparencyType, enum cdrPatternFillType PatternType, long ParentWindowHandle ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_UserAssign(TransparencyType, PatternType, ParentWindowHandle, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface IVGDimension wrapper method implementations
//

#pragma implementation_key(3460)
inline enum VGCore::cdrDimensionType VGCore::IVGDimension::GetType ( ) {
    enum cdrDimensionType _result;
    HRESULT _hr = get_Type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3461)
inline VGCore::IVGDimensionLinearPtr VGCore::IVGDimension::GetLinear ( ) {
    struct IVGDimensionLinear * _result = 0;
    HRESULT _hr = get_Linear(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGDimensionLinearPtr(_result, false);
}

#pragma implementation_key(3462)
inline VGCore::IVGDimensionAngularPtr VGCore::IVGDimension::GetAngular ( ) {
    struct IVGDimensionAngular * _result = 0;
    HRESULT _hr = get_Angular(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGDimensionAngularPtr(_result, false);
}

#pragma implementation_key(3463)
inline long VGCore::IVGDimension::GetPrecision ( ) {
    long _result = 0;
    HRESULT _hr = get_Precision(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3464)
inline void VGCore::IVGDimension::PutPrecision ( long pVal ) {
    HRESULT _hr = put_Precision(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(3465)
inline VARIANT_BOOL VGCore::IVGDimension::GetBoxedText ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_BoxedText(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3466)
inline void VGCore::IVGDimension::PutBoxedText ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_BoxedText(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(3467)
inline VARIANT_BOOL VGCore::IVGDimension::GetLeadingZero ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_LeadingZero(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3468)
inline void VGCore::IVGDimension::PutLeadingZero ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_LeadingZero(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(3469)
inline VGCore::IVGShapePtr VGCore::IVGDimension::GetTextShape ( ) {
    struct IVGShape * _result = 0;
    HRESULT _hr = get_TextShape(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGShapePtr(_result, false);
}

#pragma implementation_key(3470)
inline _bstr_t VGCore::IVGDimension::GetPrefix ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Prefix(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(3471)
inline void VGCore::IVGDimension::PutPrefix ( _bstr_t pVal ) {
    HRESULT _hr = put_Prefix(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(3472)
inline _bstr_t VGCore::IVGDimension::GetSuffix ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Suffix(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(3473)
inline void VGCore::IVGDimension::PutSuffix ( _bstr_t pVal ) {
    HRESULT _hr = put_Suffix(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(3474)
inline VGCore::IVGOutlinePtr VGCore::IVGDimension::GetOutline ( ) {
    struct IVGOutline * _result = 0;
    HRESULT _hr = get_Outline(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGOutlinePtr(_result, false);
}

#pragma implementation_key(3475)
inline VARIANT_BOOL VGCore::IVGDimension::GetTextCentered ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_TextCentered(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3476)
inline void VGCore::IVGDimension::PutTextCentered ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_TextCentered(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(3477)
inline VARIANT_BOOL VGCore::IVGDimension::GetShowUnits ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_ShowUnits(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3478)
inline void VGCore::IVGDimension::PutShowUnits ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_ShowUnits(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(3479)
inline enum VGCore::cdrDimensionPlacement VGCore::IVGDimension::GetPlacement ( ) {
    enum cdrDimensionPlacement _result;
    HRESULT _hr = get_Placement(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3480)
inline void VGCore::IVGDimension::PutPlacement ( enum cdrDimensionPlacement pVal ) {
    HRESULT _hr = put_Placement(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(3481)
inline VARIANT_BOOL VGCore::IVGDimension::GetHorizontalText ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_HorizontalText(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3482)
inline void VGCore::IVGDimension::PutHorizontalText ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_HorizontalText(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(3483)
inline VARIANT_BOOL VGCore::IVGDimension::GetDynamicText ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_DynamicText(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3484)
inline void VGCore::IVGDimension::PutDynamicText ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_DynamicText(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(3485)
inline double VGCore::IVGDimension::GetDistanceFromObject ( ) {
    double _result = 0;
    HRESULT _hr = get_DistanceFromObject(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3486)
inline VARIANT_BOOL VGCore::IVGDimension::GetUseDistanceFromObject ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_UseDistanceFromObject(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3487)
inline void VGCore::IVGDimension::PutUseDistanceFromObject ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_UseDistanceFromObject(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(3488)
inline HRESULT VGCore::IVGDimension::SetDistanceFromObject ( double Distance ) {
    HRESULT _hr = raw_SetDistanceFromObject(Distance);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(3489)
inline double VGCore::IVGDimension::GetOverhang ( ) {
    double _result = 0;
    HRESULT _hr = get_Overhang(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3490)
inline VARIANT_BOOL VGCore::IVGDimension::GetUseOverhang ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_UseOverhang(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3491)
inline void VGCore::IVGDimension::PutUseOverhang ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_UseOverhang(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(3492)
inline HRESULT VGCore::IVGDimension::SetOverhang ( double Overhang ) {
    HRESULT _hr = raw_SetOverhang(Overhang);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(3493)
inline double VGCore::IVGDimension::GetTextLabelGap ( ) {
    double _result = 0;
    HRESULT _hr = get_TextLabelGap(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3494)
inline VARIANT_BOOL VGCore::IVGDimension::GetUseTextLabelGap ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_UseTextLabelGap(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3495)
inline void VGCore::IVGDimension::PutUseTextLabelGap ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_UseTextLabelGap(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(3496)
inline HRESULT VGCore::IVGDimension::SetTextLabelGap ( double Gap ) {
    HRESULT _hr = raw_SetTextLabelGap(Gap);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(3497)
inline VARIANT_BOOL VGCore::IVGDimension::GetExtensionLinesVisible ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_ExtensionLinesVisible(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3498)
inline void VGCore::IVGDimension::PutExtensionLinesVisible ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_ExtensionLinesVisible(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(3499)
inline VARIANT_BOOL VGCore::IVGDimension::GetInnerExtensionLinesVisible ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_InnerExtensionLinesVisible(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3500)
inline void VGCore::IVGDimension::PutInnerExtensionLinesVisible ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_InnerExtensionLinesVisible(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(3501)
inline VARIANT_BOOL VGCore::IVGDimension::GetGapOnFreeExtensionVisible ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_GapOnFreeExtensionVisible(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3502)
inline void VGCore::IVGDimension::PutGapOnFreeExtensionVisible ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_GapOnFreeExtensionVisible(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IVGCommentAnnotation wrapper method implementations
//

#pragma implementation_key(3503)
inline VARIANT_BOOL VGCore::IVGCommentAnnotation::GetEndArrowVisible ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_EndArrowVisible(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3504)
inline void VGCore::IVGCommentAnnotation::PutEndArrowVisible ( VARIANT_BOOL pRet ) {
    HRESULT _hr = put_EndArrowVisible(pRet);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(3505)
inline VGCore::IVGCurvePtr VGCore::IVGCommentAnnotation::GetCurve ( ) {
    struct IVGCurve * _result = 0;
    HRESULT _hr = get_Curve(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGCurvePtr(_result, false);
}

#pragma implementation_key(3506)
inline void VGCore::IVGCommentAnnotation::PutCurve ( struct IVGCurve * pRet ) {
    HRESULT _hr = put_Curve(pRet);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(3507)
inline long VGCore::IVGCommentAnnotation::GetOutlineWidth ( ) {
    long _result = 0;
    HRESULT _hr = get_OutlineWidth(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3508)
inline void VGCore::IVGCommentAnnotation::PutOutlineWidth ( long pRet ) {
    HRESULT _hr = put_OutlineWidth(pRet);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(3509)
inline VGCore::IVGColorPtr VGCore::IVGCommentAnnotation::GetFillColor ( ) {
    struct IVGColor * _result = 0;
    HRESULT _hr = get_FillColor(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGColorPtr(_result, false);
}

#pragma implementation_key(3510)
inline void VGCore::IVGCommentAnnotation::PutFillColor ( struct IVGColor * pRet ) {
    HRESULT _hr = put_FillColor(pRet);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(3511)
inline VGCore::IVGColorPtr VGCore::IVGCommentAnnotation::GetOutlineColor ( ) {
    struct IVGColor * _result = 0;
    HRESULT _hr = get_OutlineColor(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGColorPtr(_result, false);
}

#pragma implementation_key(3512)
inline void VGCore::IVGCommentAnnotation::PutOutlineColor ( struct IVGColor * pRet ) {
    HRESULT _hr = put_OutlineColor(pRet);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(3513)
inline enum VGCore::cdrCommentAnnotationType VGCore::IVGCommentAnnotation::GetType ( ) {
    enum cdrCommentAnnotationType _result;
    HRESULT _hr = get_Type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3514)
inline VARIANT_BOOL VGCore::IVGCommentAnnotation::GetStartArrowVisible ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_StartArrowVisible(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3515)
inline void VGCore::IVGCommentAnnotation::PutStartArrowVisible ( VARIANT_BOOL pRet ) {
    HRESULT _hr = put_StartArrowVisible(pRet);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(3516)
inline HRESULT VGCore::IVGCommentAnnotation::Move ( double DeltaX, double DeltaY ) {
    HRESULT _hr = raw_Move(DeltaX, DeltaY);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(3517)
inline double VGCore::IVGCommentAnnotation::GetSizeWidth ( ) {
    double _result = 0;
    HRESULT _hr = get_SizeWidth(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3518)
inline void VGCore::IVGCommentAnnotation::PutSizeWidth ( double pVal ) {
    HRESULT _hr = put_SizeWidth(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(3519)
inline double VGCore::IVGCommentAnnotation::GetSizeHeight ( ) {
    double _result = 0;
    HRESULT _hr = get_SizeHeight(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3520)
inline void VGCore::IVGCommentAnnotation::PutSizeHeight ( double pVal ) {
    HRESULT _hr = put_SizeHeight(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(3521)
inline double VGCore::IVGCommentAnnotation::GetLeftX ( ) {
    double _result = 0;
    HRESULT _hr = get_LeftX(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3522)
inline void VGCore::IVGCommentAnnotation::PutLeftX ( double pVal ) {
    HRESULT _hr = put_LeftX(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(3523)
inline double VGCore::IVGCommentAnnotation::GetRightX ( ) {
    double _result = 0;
    HRESULT _hr = get_RightX(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3524)
inline void VGCore::IVGCommentAnnotation::PutRightX ( double pVal ) {
    HRESULT _hr = put_RightX(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(3525)
inline double VGCore::IVGCommentAnnotation::GetTopY ( ) {
    double _result = 0;
    HRESULT _hr = get_TopY(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3526)
inline void VGCore::IVGCommentAnnotation::PutTopY ( double pVal ) {
    HRESULT _hr = put_TopY(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(3527)
inline double VGCore::IVGCommentAnnotation::GetBottomY ( ) {
    double _result = 0;
    HRESULT _hr = get_BottomY(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3528)
inline void VGCore::IVGCommentAnnotation::PutBottomY ( double pVal ) {
    HRESULT _hr = put_BottomY(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(3529)
inline double VGCore::IVGCommentAnnotation::GetCenterX ( ) {
    double _result = 0;
    HRESULT _hr = get_CenterX(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3530)
inline void VGCore::IVGCommentAnnotation::PutCenterX ( double pVal ) {
    HRESULT _hr = put_CenterX(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(3531)
inline double VGCore::IVGCommentAnnotation::GetCenterY ( ) {
    double _result = 0;
    HRESULT _hr = get_CenterY(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3532)
inline void VGCore::IVGCommentAnnotation::PutCenterY ( double pVal ) {
    HRESULT _hr = put_CenterY(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(3533)
inline HRESULT VGCore::IVGCommentAnnotation::SetPosition ( enum cdrReferencePoint ReferencePoint, double x, double y ) {
    HRESULT _hr = raw_SetPosition(ReferencePoint, x, y);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(3534)
inline HRESULT VGCore::IVGCommentAnnotation::GetPosition ( enum cdrReferencePoint ReferencePoint, double * x, double * y ) {
    HRESULT _hr = raw_GetPosition(ReferencePoint, x, y);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(3535)
inline HRESULT VGCore::IVGCommentAnnotation::SetSize ( enum cdrReferencePoint ReferencePoint, double Width, double Height ) {
    HRESULT _hr = raw_SetSize(ReferencePoint, Width, Height);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(3536)
inline HRESULT VGCore::IVGCommentAnnotation::GetSize ( double * Width, double * Height ) {
    HRESULT _hr = raw_GetSize(Width, Height);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(3537)
inline HRESULT VGCore::IVGCommentAnnotation::GetBoundingBox ( double * x, double * y, double * Width, double * Height ) {
    HRESULT _hr = raw_GetBoundingBox(x, y, Width, Height);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(3538)
inline HRESULT VGCore::IVGCommentAnnotation::SetBoundingBox ( double x, double y, double Width, double Height, VARIANT_BOOL KeepAspect, enum cdrReferencePoint ReferencePoint ) {
    HRESULT _hr = raw_SetBoundingBox(x, y, Width, Height, KeepAspect, ReferencePoint);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface IVGColorContext wrapper method implementations
//

#pragma implementation_key(3539)
inline VGCore::IVGColorProfilePtr VGCore::IVGColorContext::GetRGBColorProfile ( ) {
    struct IVGColorProfile * _result = 0;
    HRESULT _hr = get_RGBColorProfile(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGColorProfilePtr(_result, false);
}

#pragma implementation_key(3540)
inline void VGCore::IVGColorContext::PutRGBColorProfile ( struct IVGColorProfile * ppVal ) {
    HRESULT _hr = put_RGBColorProfile(ppVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(3541)
inline VGCore::IVGColorProfilePtr VGCore::IVGColorContext::GetCMYKColorProfile ( ) {
    struct IVGColorProfile * _result = 0;
    HRESULT _hr = get_CMYKColorProfile(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGColorProfilePtr(_result, false);
}

#pragma implementation_key(3542)
inline void VGCore::IVGColorContext::PutCMYKColorProfile ( struct IVGColorProfile * ppVal ) {
    HRESULT _hr = put_CMYKColorProfile(ppVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(3543)
inline VGCore::IVGColorProfilePtr VGCore::IVGColorContext::GetGrayscaleColorProfile ( ) {
    struct IVGColorProfile * _result = 0;
    HRESULT _hr = get_GrayscaleColorProfile(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGColorProfilePtr(_result, false);
}

#pragma implementation_key(3544)
inline void VGCore::IVGColorContext::PutGrayscaleColorProfile ( struct IVGColorProfile * ppVal ) {
    HRESULT _hr = put_GrayscaleColorProfile(ppVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(3545)
inline enum VGCore::clrRenderingIntent VGCore::IVGColorContext::GetRenderingIntent ( ) {
    enum clrRenderingIntent _result;
    HRESULT _hr = get_RenderingIntent(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3546)
inline void VGCore::IVGColorContext::PutRenderingIntent ( enum clrRenderingIntent pVal ) {
    HRESULT _hr = put_RenderingIntent(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(3547)
inline enum VGCore::clrColorModel VGCore::IVGColorContext::GetBlendingColorModel ( ) {
    enum clrColorModel _result;
    HRESULT _hr = get_BlendingColorModel(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3548)
inline void VGCore::IVGColorContext::PutBlendingColorModel ( enum clrColorModel pVal ) {
    HRESULT _hr = put_BlendingColorModel(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(3549)
inline VGCore::IVGColorContextPtr VGCore::IVGColorContext::GetCopy ( ) {
    struct IVGColorContext * _result = 0;
    HRESULT _hr = raw_GetCopy(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGColorContextPtr(_result, false);
}

#pragma implementation_key(3550)
inline HRESULT VGCore::IVGColorContext::CopyAssign ( struct IVGColorContext * ColorContext ) {
    HRESULT _hr = raw_CopyAssign(ColorContext);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(3551)
inline VGCore::IVGColorProfilePtr VGCore::IVGColorContext::GetColorProfile ( enum clrColorModel ColorModel ) {
    struct IVGColorProfile * _result = 0;
    HRESULT _hr = get_ColorProfile(ColorModel, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGColorProfilePtr(_result, false);
}

#pragma implementation_key(3552)
inline void VGCore::IVGColorContext::PutColorProfile ( enum clrColorModel ColorModel, struct IVGColorProfile * ppVal ) {
    HRESULT _hr = put_ColorProfile(ColorModel, ppVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(3553)
inline VARIANT_BOOL VGCore::IVGColorContext::Merge ( struct IVGColorContext * ColorContext ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_Merge(ColorContext, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3554)
inline VARIANT_BOOL VGCore::IVGColorContext::IsSame ( struct IVGColorContext * ColorContext ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_IsSame(ColorContext, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3555)
inline VGCore::IVGColorProfilesPtr VGCore::IVGColorContext::GetColorProfiles ( ) {
    struct IVGColorProfiles * _result = 0;
    HRESULT _hr = get_ColorProfiles(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGColorProfilesPtr(_result, false);
}

#pragma implementation_key(3556)
inline VARIANT_BOOL VGCore::IVGColorContext::GetReadOnly ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_ReadOnly(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3557)
inline _bstr_t VGCore::IVGColorContext::GetColorProfileNameList ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_ColorProfileNameList(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

//
// interface IVGColorProfile wrapper method implementations
//

#pragma implementation_key(3558)
inline _bstr_t VGCore::IVGColorProfile::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(3559)
inline _bstr_t VGCore::IVGColorProfile::GetFileName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_FileName(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(3560)
inline _bstr_t VGCore::IVGColorProfile::GetManufacturer ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Manufacturer(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(3561)
inline _bstr_t VGCore::IVGColorProfile::GetDeviceModel ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_DeviceModel(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(3562)
inline enum VGCore::clrDeviceType VGCore::IVGColorProfile::GetDeviceType ( ) {
    enum clrDeviceType _result;
    HRESULT _hr = get_DeviceType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3563)
inline VARIANT_BOOL VGCore::IVGColorProfile::GetSelected ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_Selected(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3564)
inline HRESULT VGCore::IVGColorProfile::Select ( ) {
    HRESULT _hr = raw_Select();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(3565)
inline VARIANT_BOOL VGCore::IVGColorProfile::GetGeneric ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_Generic(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3566)
inline VARIANT_BOOL VGCore::IVGColorProfile::GetInstalled ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_Installed(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3567)
inline _bstr_t VGCore::IVGColorProfile::GetID ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_ID(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(3568)
inline enum VGCore::clrColorModel VGCore::IVGColorProfile::GetColorModel ( ) {
    enum clrColorModel _result;
    HRESULT _hr = get_ColorModel(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3569)
inline VGCore::IVGColorContextPtr VGCore::IVGColorProfile::CreateColorContext ( enum clrRenderingIntent RenderingIntent ) {
    struct IVGColorContext * _result = 0;
    HRESULT _hr = raw_CreateColorContext(RenderingIntent, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGColorContextPtr(_result, false);
}

#pragma implementation_key(3570)
inline VARIANT_BOOL VGCore::IVGColorProfile::IsSame ( struct IVGColorProfile * ColorProfile ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_IsSame(ColorProfile, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface IVGColorProfiles wrapper method implementations
//

#pragma implementation_key(3571)
inline VGCore::IVGColorProfilePtr VGCore::IVGColorProfiles::GetItem ( const _variant_t & IndexOrName ) {
    struct IVGColorProfile * _result = 0;
    HRESULT _hr = get_Item(IndexOrName, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGColorProfilePtr(_result, false);
}

#pragma implementation_key(3572)
inline long VGCore::IVGColorProfiles::GetCount ( ) {
    long _result = 0;
    HRESULT _hr = get_Count(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3573)
inline IUnknownPtr VGCore::IVGColorProfiles::Get_NewEnum ( ) {
    IUnknown * _result = 0;
    HRESULT _hr = get__NewEnum(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IUnknownPtr(_result, false);
}

#pragma implementation_key(3574)
inline enum VGCore::clrDeviceType VGCore::IVGColorProfiles::GetDeviceType ( ) {
    enum clrDeviceType _result;
    HRESULT _hr = get_DeviceType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3575)
inline VARIANT_BOOL VGCore::IVGColorProfiles::SelectByName ( _bstr_t Name ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_SelectByName(Name, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3576)
inline VARIANT_BOOL VGCore::IVGColorProfiles::Install ( _bstr_t FileName ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_Install(FileName, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3577)
inline VGCore::IVGColorProfilePtr VGCore::IVGColorProfiles::GetGenericProfile ( ) {
    struct IVGColorProfile * _result = 0;
    HRESULT _hr = get_GenericProfile(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGColorProfilePtr(_result, false);
}

//
// interface IVGProofColorSettings wrapper method implementations
//

#pragma implementation_key(3578)
inline VGCore::IVGColorContextPtr VGCore::IVGProofColorSettings::GetColorContext ( ) {
    struct IVGColorContext * _result = 0;
    HRESULT _hr = get_ColorContext(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGColorContextPtr(_result, false);
}

#pragma implementation_key(3579)
inline void VGCore::IVGProofColorSettings::PutColorContext ( struct IVGColorContext * ppVal ) {
    HRESULT _hr = put_ColorContext(ppVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(3580)
inline VARIANT_BOOL VGCore::IVGProofColorSettings::GetShowOutOfGamutWarning ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_ShowOutOfGamutWarning(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3581)
inline void VGCore::IVGProofColorSettings::PutShowOutOfGamutWarning ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_ShowOutOfGamutWarning(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(3582)
inline VGCore::IVGColorPtr VGCore::IVGProofColorSettings::GetOutOfGamutColor ( ) {
    struct IVGColor * _result = 0;
    HRESULT _hr = get_OutOfGamutColor(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGColorPtr(_result, false);
}

#pragma implementation_key(3583)
inline void VGCore::IVGProofColorSettings::PutOutOfGamutColor ( struct IVGColor * ppVal ) {
    HRESULT _hr = put_OutOfGamutColor(ppVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(3584)
inline double VGCore::IVGProofColorSettings::GetOutOfGamutTransparency ( ) {
    double _result = 0;
    HRESULT _hr = get_OutOfGamutTransparency(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3585)
inline void VGCore::IVGProofColorSettings::PutOutOfGamutTransparency ( double pVal ) {
    HRESULT _hr = put_OutOfGamutTransparency(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(3586)
inline VARIANT_BOOL VGCore::IVGProofColorSettings::GetPreserveColorValues ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_PreserveColorValues(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3587)
inline void VGCore::IVGProofColorSettings::PutPreserveColorValues ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_PreserveColorValues(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(3588)
inline VGCore::IVGProofColorSettingsPtr VGCore::IVGProofColorSettings::GetCopy ( ) {
    struct IVGProofColorSettings * _result = 0;
    HRESULT _hr = raw_GetCopy(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGProofColorSettingsPtr(_result, false);
}

#pragma implementation_key(3589)
inline HRESULT VGCore::IVGProofColorSettings::CopyAssign ( struct IVGProofColorSettings * Source ) {
    HRESULT _hr = raw_CopyAssign(Source);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface IVGStructExportOptions wrapper method implementations
//

#pragma implementation_key(3590)
inline void VGCore::IVGStructExportOptions::PutSizeX ( long pVal ) {
    HRESULT _hr = put_SizeX(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(3591)
inline long VGCore::IVGStructExportOptions::GetSizeX ( ) {
    long _result = 0;
    HRESULT _hr = get_SizeX(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3592)
inline void VGCore::IVGStructExportOptions::PutSizeY ( long pVal ) {
    HRESULT _hr = put_SizeY(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(3593)
inline long VGCore::IVGStructExportOptions::GetSizeY ( ) {
    long _result = 0;
    HRESULT _hr = get_SizeY(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3594)
inline void VGCore::IVGStructExportOptions::PutResolutionX ( long pVal ) {
    HRESULT _hr = put_ResolutionX(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(3595)
inline long VGCore::IVGStructExportOptions::GetResolutionX ( ) {
    long _result = 0;
    HRESULT _hr = get_ResolutionX(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3596)
inline void VGCore::IVGStructExportOptions::PutResolutionY ( long pVal ) {
    HRESULT _hr = put_ResolutionY(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(3597)
inline long VGCore::IVGStructExportOptions::GetResolutionY ( ) {
    long _result = 0;
    HRESULT _hr = get_ResolutionY(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3598)
inline void VGCore::IVGStructExportOptions::PutAntiAliasingType ( enum cdrAntiAliasingType pVal ) {
    HRESULT _hr = put_AntiAliasingType(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(3599)
inline enum VGCore::cdrAntiAliasingType VGCore::IVGStructExportOptions::GetAntiAliasingType ( ) {
    enum cdrAntiAliasingType _result;
    HRESULT _hr = get_AntiAliasingType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3600)
inline void VGCore::IVGStructExportOptions::PutOverwrite ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_Overwrite(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(3601)
inline VARIANT_BOOL VGCore::IVGStructExportOptions::GetOverwrite ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_Overwrite(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3602)
inline void VGCore::IVGStructExportOptions::PutImageType ( enum cdrImageType pVal ) {
    HRESULT _hr = put_ImageType(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(3603)
inline enum VGCore::cdrImageType VGCore::IVGStructExportOptions::GetImageType ( ) {
    enum cdrImageType _result;
    HRESULT _hr = get_ImageType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3604)
inline void VGCore::IVGStructExportOptions::PutDithered ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_Dithered(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(3605)
inline VARIANT_BOOL VGCore::IVGStructExportOptions::GetDithered ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_Dithered(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3606)
inline void VGCore::IVGStructExportOptions::PutTransparent ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_Transparent(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(3607)
inline VARIANT_BOOL VGCore::IVGStructExportOptions::GetTransparent ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_Transparent(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3608)
inline void VGCore::IVGStructExportOptions::PutUseColorProfile ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_UseColorProfile(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(3609)
inline VARIANT_BOOL VGCore::IVGStructExportOptions::GetUseColorProfile ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_UseColorProfile(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3610)
inline void VGCore::IVGStructExportOptions::PutCompression ( enum cdrCompressionType pVal ) {
    HRESULT _hr = put_Compression(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(3611)
inline enum VGCore::cdrCompressionType VGCore::IVGStructExportOptions::GetCompression ( ) {
    enum cdrCompressionType _result;
    HRESULT _hr = get_Compression(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3612)
inline void VGCore::IVGStructExportOptions::PutMaintainLayers ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_MaintainLayers(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(3613)
inline VARIANT_BOOL VGCore::IVGStructExportOptions::GetMaintainLayers ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_MaintainLayers(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3614)
inline void VGCore::IVGStructExportOptions::PutMaintainAspect ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_MaintainAspect(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(3615)
inline VARIANT_BOOL VGCore::IVGStructExportOptions::GetMaintainAspect ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_MaintainAspect(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3616)
inline VGCore::IVGRectPtr VGCore::IVGStructExportOptions::GetExportArea ( ) {
    struct IVGRect * _result = 0;
    HRESULT _hr = get_ExportArea(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGRectPtr(_result, false);
}

#pragma implementation_key(3617)
inline void VGCore::IVGStructExportOptions::PutRefExportArea ( struct IVGRect * * ppVal ) {
    HRESULT _hr = putref_ExportArea(ppVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(3618)
inline void VGCore::IVGStructExportOptions::PutMatted ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_Matted(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(3619)
inline VARIANT_BOOL VGCore::IVGStructExportOptions::GetMatted ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_Matted(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3620)
inline VGCore::IVGColorPtr VGCore::IVGStructExportOptions::GetMatteColor ( ) {
    struct IVGColor * _result = 0;
    HRESULT _hr = get_MatteColor(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGColorPtr(_result, false);
}

#pragma implementation_key(3621)
inline void VGCore::IVGStructExportOptions::PutMatteColor ( struct IVGColor * ppVal ) {
    HRESULT _hr = put_MatteColor(ppVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(3622)
inline void VGCore::IVGStructExportOptions::PutMatteMaskedOnly ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_MatteMaskedOnly(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(3623)
inline VARIANT_BOOL VGCore::IVGStructExportOptions::GetMatteMaskedOnly ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_MatteMaskedOnly(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3624)
inline void VGCore::IVGStructExportOptions::PutAlwaysOverprintBlack ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_AlwaysOverprintBlack(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(3625)
inline VARIANT_BOOL VGCore::IVGStructExportOptions::GetAlwaysOverprintBlack ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_AlwaysOverprintBlack(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3626)
inline VGCore::IVGProofColorSettingsPtr VGCore::IVGStructExportOptions::GetProofColorSettings ( ) {
    struct IVGProofColorSettings * _result = 0;
    HRESULT _hr = get_ProofColorSettings(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGProofColorSettingsPtr(_result, false);
}

#pragma implementation_key(3627)
inline void VGCore::IVGStructExportOptions::PutProofColorSettings ( struct IVGProofColorSettings * ppVal ) {
    HRESULT _hr = put_ProofColorSettings(ppVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IVGColorManager wrapper method implementations
//

#pragma implementation_key(3628)
inline VARIANT_BOOL VGCore::IVGColorManager::GetScannerCalibrated ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_ScannerCalibrated(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3629)
inline void VGCore::IVGColorManager::PutScannerCalibrated ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_ScannerCalibrated(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(3630)
inline VARIANT_BOOL VGCore::IVGColorManager::GetSeparationPrinterCalibrated ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_SeparationPrinterCalibrated(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3631)
inline void VGCore::IVGColorManager::PutSeparationPrinterCalibrated ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_SeparationPrinterCalibrated(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(3632)
inline VARIANT_BOOL VGCore::IVGColorManager::GetCompositePrinterCalibrated ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_CompositePrinterCalibrated(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3633)
inline enum VGCore::clrCompPrnCalibration VGCore::IVGColorManager::GetCompositePrinterCalibration ( ) {
    enum clrCompPrnCalibration _result;
    HRESULT _hr = get_CompositePrinterCalibration(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3634)
inline void VGCore::IVGColorManager::PutCompositePrinterCalibration ( enum clrCompPrnCalibration pVal ) {
    HRESULT _hr = put_CompositePrinterCalibration(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(3635)
inline enum VGCore::clrMonitorCalibration VGCore::IVGColorManager::GetMonitorCalibration ( ) {
    enum clrMonitorCalibration _result;
    HRESULT _hr = get_MonitorCalibration(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3636)
inline void VGCore::IVGColorManager::PutMonitorCalibration ( enum clrMonitorCalibration pVal ) {
    HRESULT _hr = put_MonitorCalibration(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(3637)
inline VARIANT_BOOL VGCore::IVGColorManager::GetCompositePrinterSimulatesSeparation ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_CompositePrinterSimulatesSeparation(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3638)
inline VARIANT_BOOL VGCore::IVGColorManager::GetShowOutOfGamut ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_ShowOutOfGamut(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3639)
inline void VGCore::IVGColorManager::PutShowOutOfGamut ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_ShowOutOfGamut(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(3640)
inline VGCore::IVGColorPtr VGCore::IVGColorManager::GetOutOfGamutColor ( ) {
    struct IVGColor * _result = 0;
    HRESULT _hr = get_OutOfGamutColor(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGColorPtr(_result, false);
}

#pragma implementation_key(3641)
inline void VGCore::IVGColorManager::PutOutOfGamutColor ( struct IVGColor * ppVal ) {
    HRESULT _hr = put_OutOfGamutColor(ppVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(3642)
inline long VGCore::IVGColorManager::GetOutOfGamutTransparency ( ) {
    long _result = 0;
    HRESULT _hr = get_OutOfGamutTransparency(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3643)
inline void VGCore::IVGColorManager::PutOutOfGamutTransparency ( long pVal ) {
    HRESULT _hr = put_OutOfGamutTransparency(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(3644)
inline VARIANT_BOOL VGCore::IVGColorManager::GetCMYKInPercents ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_CMYKInPercents(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3645)
inline void VGCore::IVGColorManager::PutCMYKInPercents ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_CMYKInPercents(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(3646)
inline VARIANT_BOOL VGCore::IVGColorManager::GetCMYKGamutForSpotColors ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_CMYKGamutForSpotColors(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3647)
inline void VGCore::IVGColorManager::PutCMYKGamutForSpotColors ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_CMYKGamutForSpotColors(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(3648)
inline enum VGCore::clrRenderingIntent VGCore::IVGColorManager::GetRenderingIntent ( ) {
    enum clrRenderingIntent _result;
    HRESULT _hr = get_RenderingIntent(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3649)
inline void VGCore::IVGColorManager::PutRenderingIntent ( enum clrRenderingIntent pVal ) {
    HRESULT _hr = put_RenderingIntent(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(3650)
inline enum VGCore::clrColorEngine VGCore::IVGColorManager::GetColorEngine ( ) {
    enum clrColorEngine _result;
    HRESULT _hr = get_ColorEngine(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3651)
inline void VGCore::IVGColorManager::PutColorEngine ( enum clrColorEngine pVal ) {
    HRESULT _hr = put_ColorEngine(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(3652)
inline long VGCore::IVGColorManager::GetStyleCount ( ) {
    long _result = 0;
    HRESULT _hr = get_StyleCount(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3653)
inline _bstr_t VGCore::IVGColorManager::GetStyleByIndex ( long Index ) {
    BSTR _result = 0;
    HRESULT _hr = get_StyleByIndex(Index, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(3654)
inline VGCore::IVGColorProfilePtr VGCore::IVGColorManager::GetCurrentProfile ( enum clrDeviceType DeviceType ) {
    struct IVGColorProfile * _result = 0;
    HRESULT _hr = get_CurrentProfile(DeviceType, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGColorProfilePtr(_result, false);
}

#pragma implementation_key(3655)
inline VGCore::IVGColorProfilesPtr VGCore::IVGColorManager::GetInstalledProfiles ( enum clrDeviceType DeviceType ) {
    struct IVGColorProfiles * _result = 0;
    HRESULT _hr = get_InstalledProfiles(DeviceType, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGColorProfilesPtr(_result, false);
}

#pragma implementation_key(3656)
inline VARIANT_BOOL VGCore::IVGColorManager::LoadStyle ( _bstr_t StyleName ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_LoadStyle(StyleName, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3657)
inline VARIANT_BOOL VGCore::IVGColorManager::DeleteStyle ( _bstr_t StyleName ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_DeleteStyle(StyleName, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3658)
inline VARIANT_BOOL VGCore::IVGColorManager::SaveStyle ( _bstr_t StyleName ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_SaveStyle(StyleName, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3659)
inline VARIANT_BOOL VGCore::IVGColorManager::GetIsICM2Available ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsICM2Available(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3660)
inline _bstr_t VGCore::IVGColorManager::GetUnsavedStyleName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_UnsavedStyleName(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(3661)
inline _bstr_t VGCore::IVGColorManager::GetGenericProfileName ( enum clrDeviceType DeviceType ) {
    BSTR _result = 0;
    HRESULT _hr = get_GenericProfileName(DeviceType, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(3662)
inline VARIANT_BOOL VGCore::IVGColorManager::GetIsCompositePrinterCMYK ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsCompositePrinterCMYK(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3663)
inline enum VGCore::clrImportColorCorrection VGCore::IVGColorManager::GetColorCorrectionOnImport ( ) {
    enum clrImportColorCorrection _result;
    HRESULT _hr = get_ColorCorrectionOnImport(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3664)
inline void VGCore::IVGColorManager::PutColorCorrectionOnImport ( enum clrImportColorCorrection pVal ) {
    HRESULT _hr = put_ColorCorrectionOnImport(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(3665)
inline enum VGCore::clrExportColorCorrection VGCore::IVGColorManager::GetColorCorrectionOnExport ( ) {
    enum clrExportColorCorrection _result;
    HRESULT _hr = get_ColorCorrectionOnExport(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3666)
inline void VGCore::IVGColorManager::PutColorCorrectionOnExport ( enum clrExportColorCorrection pVal ) {
    HRESULT _hr = put_ColorCorrectionOnExport(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(3667)
inline VGCore::IVGColorProfilePtr VGCore::IVGColorManager::GetDefaultImportProfile ( ) {
    struct IVGColorProfile * _result = 0;
    HRESULT _hr = get_DefaultImportProfile(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGColorProfilePtr(_result, false);
}

#pragma implementation_key(3668)
inline void VGCore::IVGColorManager::PutRefDefaultImportProfile ( struct IVGColorProfile * * ppVal ) {
    HRESULT _hr = putref_DefaultImportProfile(ppVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(3669)
inline VGCore::IVGColorProfilePtr VGCore::IVGColorManager::GetCustomImportProfile ( ) {
    struct IVGColorProfile * _result = 0;
    HRESULT _hr = get_CustomImportProfile(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGColorProfilePtr(_result, false);
}

#pragma implementation_key(3670)
inline void VGCore::IVGColorManager::PutRefCustomImportProfile ( struct IVGColorProfile * * ppVal ) {
    HRESULT _hr = putref_CustomImportProfile(ppVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(3671)
inline VGCore::IVGColorProfilePtr VGCore::IVGColorManager::GetCustomExportProfile ( ) {
    struct IVGColorProfile * _result = 0;
    HRESULT _hr = get_CustomExportProfile(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGColorProfilePtr(_result, false);
}

#pragma implementation_key(3672)
inline void VGCore::IVGColorManager::PutRefCustomExportProfile ( struct IVGColorProfile * * ppVal ) {
    HRESULT _hr = putref_CustomExportProfile(ppVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(3673)
inline VGCore::IVGColorProfilesPtr VGCore::IVGColorManager::GetMonitorColorProfiles ( ) {
    struct IVGColorProfiles * _result = 0;
    HRESULT _hr = get_MonitorColorProfiles(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGColorProfilesPtr(_result, false);
}

#pragma implementation_key(3674)
inline VGCore::IVGColorProfilesPtr VGCore::IVGColorManager::GetProfilesByColorModel ( enum clrColorModel ColorModel ) {
    struct IVGColorProfiles * _result = 0;
    HRESULT _hr = raw_GetProfilesByColorModel(ColorModel, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGColorProfilesPtr(_result, false);
}

#pragma implementation_key(3675)
inline VGCore::IVGColorProfilesPtr VGCore::IVGColorManager::GetProfilesForDevice ( enum clrDeviceType DeviceType, _bstr_t DeviceName ) {
    struct IVGColorProfiles * _result = 0;
    HRESULT _hr = raw_GetProfilesForDevice(DeviceType, DeviceName, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGColorProfilesPtr(_result, false);
}

#pragma implementation_key(3676)
inline VGCore::IVGColorContextPtr VGCore::IVGColorManager::GetDefaultColorContext ( ) {
    struct IVGColorContext * _result = 0;
    HRESULT _hr = get_DefaultColorContext(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGColorContextPtr(_result, false);
}

#pragma implementation_key(3677)
inline VARIANT_BOOL VGCore::IVGColorManager::ColorEnginePresent ( enum clrColorEngine ColorEngine ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_ColorEnginePresent(ColorEngine, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3678)
inline VARIANT_BOOL VGCore::IVGColorManager::CanDeleteStyle ( _bstr_t StyleName ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_CanDeleteStyle(StyleName, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3679)
inline VARIANT_BOOL VGCore::IVGColorManager::GetMapGrayToCMYKBlack ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_MapGrayToCMYKBlack(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3680)
inline void VGCore::IVGColorManager::PutMapGrayToCMYKBlack ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_MapGrayToCMYKBlack(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(3681)
inline VARIANT_BOOL VGCore::IVGColorManager::GetPreservePureBlack ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_PreservePureBlack(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3682)
inline void VGCore::IVGColorManager::PutPreservePureBlack ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_PreservePureBlack(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(3683)
inline enum VGCore::clrColorModel VGCore::IVGColorManager::GetSpotColorDefinition ( ) {
    enum clrColorModel _result;
    HRESULT _hr = get_SpotColorDefinition(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3684)
inline void VGCore::IVGColorManager::PutSpotColorDefinition ( enum clrColorModel pVal ) {
    HRESULT _hr = put_SpotColorDefinition(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(3685)
inline VGCore::IVGColorProfilesPtr VGCore::IVGColorManager::GetColorProfiles ( ) {
    struct IVGColorProfiles * _result = 0;
    HRESULT _hr = get_ColorProfiles(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGColorProfilesPtr(_result, false);
}

#pragma implementation_key(3686)
inline VGCore::IVGColorManagementPolicyPtr VGCore::IVGColorManager::GetPolicyForOpen ( ) {
    struct IVGColorManagementPolicy * _result = 0;
    HRESULT _hr = get_PolicyForOpen(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGColorManagementPolicyPtr(_result, false);
}

#pragma implementation_key(3687)
inline VGCore::IVGColorManagementPolicyPtr VGCore::IVGColorManager::GetPolicyForImport ( ) {
    struct IVGColorManagementPolicy * _result = 0;
    HRESULT _hr = get_PolicyForImport(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGColorManagementPolicyPtr(_result, false);
}

//
// interface IVGStructCreateOptions wrapper method implementations
//

#pragma implementation_key(3688)
inline VGCore::IVGColorContextPtr VGCore::IVGStructCreateOptions::GetColorContext ( ) {
    struct IVGColorContext * _result = 0;
    HRESULT _hr = get_ColorContext(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGColorContextPtr(_result, false);
}

#pragma implementation_key(3689)
inline void VGCore::IVGStructCreateOptions::PutColorContext ( struct IVGColorContext * ppVal ) {
    HRESULT _hr = put_ColorContext(ppVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(3690)
inline _bstr_t VGCore::IVGStructCreateOptions::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(3691)
inline void VGCore::IVGStructCreateOptions::PutName ( _bstr_t pVal ) {
    HRESULT _hr = put_Name(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(3692)
inline double VGCore::IVGStructCreateOptions::GetPageWidth ( ) {
    double _result = 0;
    HRESULT _hr = get_PageWidth(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3693)
inline void VGCore::IVGStructCreateOptions::PutPageWidth ( double pVal ) {
    HRESULT _hr = put_PageWidth(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(3694)
inline double VGCore::IVGStructCreateOptions::GetPageHeight ( ) {
    double _result = 0;
    HRESULT _hr = get_PageHeight(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3695)
inline void VGCore::IVGStructCreateOptions::PutPageHeight ( double pVal ) {
    HRESULT _hr = put_PageHeight(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(3696)
inline enum VGCore::cdrUnit VGCore::IVGStructCreateOptions::GetUnits ( ) {
    enum cdrUnit _result;
    HRESULT _hr = get_Units(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3697)
inline void VGCore::IVGStructCreateOptions::PutUnits ( enum cdrUnit pVal ) {
    HRESULT _hr = put_Units(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(3698)
inline double VGCore::IVGStructCreateOptions::GetResolution ( ) {
    double _result = 0;
    HRESULT _hr = get_Resolution(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3699)
inline void VGCore::IVGStructCreateOptions::PutResolution ( double pVal ) {
    HRESULT _hr = put_Resolution(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IVGPalette wrapper method implementations
//

#pragma implementation_key(3700)
inline IDispatchPtr VGCore::IVGPalette::GetApplication ( ) {
    IDispatch * _result = 0;
    HRESULT _hr = get_Application(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IDispatchPtr(_result, false);
}

#pragma implementation_key(3701)
inline IDispatchPtr VGCore::IVGPalette::GetParent ( ) {
    IDispatch * _result = 0;
    HRESULT _hr = get_Parent(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IDispatchPtr(_result, false);
}

#pragma implementation_key(3702)
inline _bstr_t VGCore::IVGPalette::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(3703)
inline void VGCore::IVGPalette::PutName ( _bstr_t Name ) {
    HRESULT _hr = put_Name(Name);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(3704)
inline HRESULT VGCore::IVGPalette::Close ( ) {
    HRESULT _hr = raw_Close();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(3705)
inline enum VGCore::cdrPaletteType VGCore::IVGPalette::GetType ( ) {
    enum cdrPaletteType _result;
    HRESULT _hr = get_Type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3706)
inline VGCore::IVGColorsPtr VGCore::IVGPalette::Colors ( ) {
    struct IVGColors * _result = 0;
    HRESULT _hr = raw_Colors(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGColorsPtr(_result, false);
}

#pragma implementation_key(3707)
inline VGCore::IVGColorPtr VGCore::IVGPalette::GetColor ( long Index ) {
    struct IVGColor * _result = 0;
    HRESULT _hr = get_Color(Index, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGColorPtr(_result, false);
}

#pragma implementation_key(3708)
inline void VGCore::IVGPalette::PutColor ( long Index, struct IVGColor * Color ) {
    HRESULT _hr = put_Color(Index, Color);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(3709)
inline HRESULT VGCore::IVGPalette::AddColor ( struct IVGColor * Color ) {
    HRESULT _hr = raw_AddColor(Color);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(3710)
inline HRESULT VGCore::IVGPalette::InsertColor ( long Index, struct IVGColor * Color ) {
    HRESULT _hr = raw_InsertColor(Index, Color);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(3711)
inline HRESULT VGCore::IVGPalette::RemoveColor ( long Index ) {
    HRESULT _hr = raw_RemoveColor(Index);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(3712)
inline long VGCore::IVGPalette::GetIndexOfColor ( struct IVGColor * Color ) {
    long _result = 0;
    HRESULT _hr = raw_GetIndexOfColor(Color, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3713)
inline VARIANT_BOOL VGCore::IVGPalette::GetDuplicatePresent ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_DuplicatePresent(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3714)
inline long VGCore::IVGPalette::GetColorCount ( ) {
    long _result = 0;
    HRESULT _hr = get_ColorCount(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3715)
inline HRESULT VGCore::IVGPalette::Save ( ) {
    HRESULT _hr = raw_Save();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(3716)
inline enum VGCore::cdrPaletteID VGCore::IVGPalette::GetPaletteID ( ) {
    enum cdrPaletteID _result;
    HRESULT _hr = get_PaletteID(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3717)
inline _bstr_t VGCore::IVGPalette::GetFileName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_FileName(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(3718)
inline long VGCore::IVGPalette::MatchColor ( struct IVGColor * Color ) {
    long _result = 0;
    HRESULT _hr = raw_MatchColor(Color, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3719)
inline long VGCore::IVGPalette::FindColor ( _bstr_t Name ) {
    long _result = 0;
    HRESULT _hr = raw_FindColor(Name, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3720)
inline HRESULT VGCore::IVGPalette::SaveAs ( _bstr_t FileName, _bstr_t Name, enum cdrPaletteVersion Version ) {
    HRESULT _hr = raw_SaveAs(FileName, Name, Version);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(3721)
inline VGCore::IVGDocumentPtr VGCore::IVGPalette::GetDocument ( ) {
    struct IVGDocument * _result = 0;
    HRESULT _hr = get_Document(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGDocumentPtr(_result, false);
}

#pragma implementation_key(3722)
inline _bstr_t VGCore::IVGPalette::GetIdentifier ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Identifier(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(3723)
inline VARIANT_BOOL VGCore::IVGPalette::GetIsEmpty ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsEmpty(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3724)
inline VARIANT_BOOL VGCore::IVGPalette::GetLocked ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_Locked(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3725)
inline VARIANT_BOOL VGCore::IVGPalette::GetDefault ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_Default(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3726)
inline VARIANT_BOOL VGCore::IVGPalette::GetIsOpen ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsOpen(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3727)
inline HRESULT VGCore::IVGPalette::Open ( ) {
    HRESULT _hr = raw_Open();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(3728)
inline HRESULT VGCore::IVGPalette::MakeDefault ( ) {
    HRESULT _hr = raw_MakeDefault();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(3729)
inline VARIANT_BOOL VGCore::IVGPalette::Delete ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_Delete(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface IVGColors wrapper method implementations
//

#pragma implementation_key(3730)
inline IDispatchPtr VGCore::IVGColors::GetApplication ( ) {
    IDispatch * _result = 0;
    HRESULT _hr = get_Application(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IDispatchPtr(_result, false);
}

#pragma implementation_key(3731)
inline VGCore::IVGPalettePtr VGCore::IVGColors::GetParent ( ) {
    struct IVGPalette * _result = 0;
    HRESULT _hr = get_Parent(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGPalettePtr(_result, false);
}

#pragma implementation_key(3732)
inline VGCore::IVGColorPtr VGCore::IVGColors::GetItem ( long Index ) {
    struct IVGColor * _result = 0;
    HRESULT _hr = get_Item(Index, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGColorPtr(_result, false);
}

#pragma implementation_key(3733)
inline IUnknownPtr VGCore::IVGColors::Get_NewEnum ( ) {
    IUnknown * _result = 0;
    HRESULT _hr = get__NewEnum(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IUnknownPtr(_result, false);
}

#pragma implementation_key(3734)
inline long VGCore::IVGColors::GetCount ( ) {
    long _result = 0;
    HRESULT _hr = get_Count(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface IVGPalettes wrapper method implementations
//

#pragma implementation_key(3735)
inline IDispatchPtr VGCore::IVGPalettes::GetApplication ( ) {
    IDispatch * _result = 0;
    HRESULT _hr = get_Application(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IDispatchPtr(_result, false);
}

#pragma implementation_key(3736)
inline IDispatchPtr VGCore::IVGPalettes::GetParent ( ) {
    IDispatch * _result = 0;
    HRESULT _hr = get_Parent(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IDispatchPtr(_result, false);
}

#pragma implementation_key(3737)
inline VGCore::IVGPalettePtr VGCore::IVGPalettes::GetItem ( const _variant_t & IndexOrName ) {
    struct IVGPalette * _result = 0;
    HRESULT _hr = get_Item(IndexOrName, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGPalettePtr(_result, false);
}

#pragma implementation_key(3738)
inline IUnknownPtr VGCore::IVGPalettes::Get_NewEnum ( ) {
    IUnknown * _result = 0;
    HRESULT _hr = get__NewEnum(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IUnknownPtr(_result, false);
}

#pragma implementation_key(3739)
inline long VGCore::IVGPalettes::GetCount ( ) {
    long _result = 0;
    HRESULT _hr = get_Count(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3740)
inline VGCore::IVGPalettePtr VGCore::IVGPalettes::Open ( _bstr_t FileName ) {
    struct IVGPalette * _result = 0;
    HRESULT _hr = raw_Open(FileName, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGPalettePtr(_result, false);
}

#pragma implementation_key(3741)
inline VGCore::IVGPalettePtr VGCore::IVGPalettes::OpenFixed ( enum cdrPaletteID PaletteID ) {
    struct IVGPalette * _result = 0;
    HRESULT _hr = raw_OpenFixed(PaletteID, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGPalettePtr(_result, false);
}

#pragma implementation_key(3742)
inline VGCore::IVGPalettePtr VGCore::IVGPalettes::CreateFromDocument ( _bstr_t Name, _bstr_t FileName, VARIANT_BOOL Overwrite ) {
    struct IVGPalette * _result = 0;
    HRESULT _hr = raw_CreateFromDocument(Name, FileName, Overwrite, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGPalettePtr(_result, false);
}

#pragma implementation_key(3743)
inline VGCore::IVGPalettePtr VGCore::IVGPalettes::CreateFromSelection ( _bstr_t Name, _bstr_t FileName, VARIANT_BOOL Overwrite ) {
    struct IVGPalette * _result = 0;
    HRESULT _hr = raw_CreateFromSelection(Name, FileName, Overwrite, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGPalettePtr(_result, false);
}

#pragma implementation_key(3744)
inline VGCore::IVGPalettePtr VGCore::IVGPalettes::Create ( _bstr_t Name, _bstr_t FileName, VARIANT_BOOL Overwrite ) {
    struct IVGPalette * _result = 0;
    HRESULT _hr = raw_Create(Name, FileName, Overwrite, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGPalettePtr(_result, false);
}

//
// interface IVGPaletteManager wrapper method implementations
//

#pragma implementation_key(3745)
inline long VGCore::IVGPaletteManager::GetPaletteCount ( ) {
    long _result = 0;
    HRESULT _hr = get_PaletteCount(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3746)
inline VGCore::IVGPalettePtr VGCore::IVGPaletteManager::GetPalette ( const _variant_t & IndexOrName ) {
    struct IVGPalette * _result = 0;
    HRESULT _hr = raw_GetPalette(IndexOrName, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGPalettePtr(_result, false);
}

#pragma implementation_key(3747)
inline VGCore::IVGPalettePtr VGCore::IVGPaletteManager::GetDefaultPalette ( ) {
    struct IVGPalette * _result = 0;
    HRESULT _hr = get_DefaultPalette(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGPalettePtr(_result, false);
}

#pragma implementation_key(3748)
inline VGCore::IVGPalettesPtr VGCore::IVGPaletteManager::GetOpenPalettes ( ) {
    struct IVGPalettes * _result = 0;
    HRESULT _hr = get_OpenPalettes(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGPalettesPtr(_result, false);
}

#pragma implementation_key(3749)
inline IUnknownPtr VGCore::IVGPaletteManager::Get_NewEnum ( ) {
    IUnknown * _result = 0;
    HRESULT _hr = get__NewEnum(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IUnknownPtr(_result, false);
}

#pragma implementation_key(3750)
inline HRESULT VGCore::IVGPaletteManager::LoadAllPalettes ( ) {
    HRESULT _hr = raw_LoadAllPalettes();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(3751)
inline VGCore::IVGPalettePtr VGCore::IVGPaletteManager::LoadPalette ( _bstr_t FileName ) {
    struct IVGPalette * _result = 0;
    HRESULT _hr = raw_LoadPalette(FileName, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGPalettePtr(_result, false);
}

//
// interface IVGTraceSettings wrapper method implementations
//

#pragma implementation_key(3752)
inline enum VGCore::cdrTraceType VGCore::IVGTraceSettings::GetTraceType ( ) {
    enum cdrTraceType _result;
    HRESULT _hr = get_TraceType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3753)
inline void VGCore::IVGTraceSettings::PutTraceType ( enum cdrTraceType pVal ) {
    HRESULT _hr = put_TraceType(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(3754)
inline short VGCore::IVGTraceSettings::GetSmoothing ( ) {
    short _result = 0;
    HRESULT _hr = get_Smoothing(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3755)
inline void VGCore::IVGTraceSettings::PutSmoothing ( short pVal ) {
    HRESULT _hr = put_Smoothing(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(3756)
inline short VGCore::IVGTraceSettings::GetDetailLevel ( ) {
    short _result = 0;
    HRESULT _hr = get_DetailLevel(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3757)
inline void VGCore::IVGTraceSettings::PutDetailLevel ( short pVal ) {
    HRESULT _hr = put_DetailLevel(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(3758)
inline enum VGCore::cdrColorType VGCore::IVGTraceSettings::GetColorMode ( ) {
    enum cdrColorType _result;
    HRESULT _hr = get_ColorMode(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3759)
inline enum VGCore::cdrPaletteID VGCore::IVGTraceSettings::GetPaletteID ( ) {
    enum cdrPaletteID _result;
    HRESULT _hr = get_PaletteID(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3760)
inline long VGCore::IVGTraceSettings::GetColorCount ( ) {
    long _result = 0;
    HRESULT _hr = get_ColorCount(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3761)
inline VGCore::IVGColorPtr VGCore::IVGTraceSettings::GetColor ( long Index ) {
    struct IVGColor * _result = 0;
    HRESULT _hr = get_Color(Index, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGColorPtr(_result, false);
}

#pragma implementation_key(3762)
inline VARIANT_BOOL VGCore::IVGTraceSettings::GetDeleteOriginalObject ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_DeleteOriginalObject(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3763)
inline void VGCore::IVGTraceSettings::PutDeleteOriginalObject ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_DeleteOriginalObject(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(3764)
inline VARIANT_BOOL VGCore::IVGTraceSettings::GetRemoveBackground ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_RemoveBackground(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3765)
inline void VGCore::IVGTraceSettings::PutRemoveBackground ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_RemoveBackground(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(3766)
inline VARIANT_BOOL VGCore::IVGTraceSettings::GetRemoveEntireBackColor ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_RemoveEntireBackColor(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3767)
inline void VGCore::IVGTraceSettings::PutRemoveEntireBackColor ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_RemoveEntireBackColor(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(3768)
inline enum VGCore::cdrTraceBackgroundMode VGCore::IVGTraceSettings::GetBackgroundRemovalMode ( ) {
    enum cdrTraceBackgroundMode _result;
    HRESULT _hr = get_BackgroundRemovalMode(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3769)
inline void VGCore::IVGTraceSettings::PutBackgroundRemovalMode ( enum cdrTraceBackgroundMode pVal ) {
    HRESULT _hr = put_BackgroundRemovalMode(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(3770)
inline VGCore::IVGColorPtr VGCore::IVGTraceSettings::GetBackgroundColor ( ) {
    struct IVGColor * _result = 0;
    HRESULT _hr = get_BackgroundColor(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGColorPtr(_result, false);
}

#pragma implementation_key(3771)
inline long VGCore::IVGTraceSettings::GetCurveCount ( ) {
    long _result = 0;
    HRESULT _hr = get_CurveCount(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3772)
inline long VGCore::IVGTraceSettings::GetNodeCount ( ) {
    long _result = 0;
    HRESULT _hr = get_NodeCount(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3773)
inline long VGCore::IVGTraceSettings::GetBitmapWidth ( ) {
    long _result = 0;
    HRESULT _hr = get_BitmapWidth(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3774)
inline long VGCore::IVGTraceSettings::GetBitmapHeight ( ) {
    long _result = 0;
    HRESULT _hr = get_BitmapHeight(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3775)
inline long VGCore::IVGTraceSettings::SetColorCount ( long ColorCount ) {
    long _result = 0;
    HRESULT _hr = raw_SetColorCount(ColorCount, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3776)
inline VGCore::IVGShapeRangePtr VGCore::IVGTraceSettings::Finish ( ) {
    struct IVGShapeRange * _result = 0;
    HRESULT _hr = raw_Finish(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGShapeRangePtr(_result, false);
}

#pragma implementation_key(3777)
inline VARIANT_BOOL VGCore::IVGTraceSettings::ShowDialog ( long ParentWindowHandle ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_ShowDialog(ParentWindowHandle, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3778)
inline HRESULT VGCore::IVGTraceSettings::ApplyChanges ( ) {
    HRESULT _hr = raw_ApplyChanges();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(3779)
inline HRESULT VGCore::IVGTraceSettings::SetColorMode ( enum cdrColorType ColorMode, enum cdrPaletteID PaletteID ) {
    HRESULT _hr = raw_SetColorMode(ColorMode, PaletteID);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(3780)
inline short VGCore::IVGTraceSettings::GetDetailLevelPercent ( ) {
    short _result = 0;
    HRESULT _hr = get_DetailLevelPercent(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3781)
inline void VGCore::IVGTraceSettings::PutDetailLevelPercent ( short pVal ) {
    HRESULT _hr = put_DetailLevelPercent(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(3782)
inline short VGCore::IVGTraceSettings::GetMaxDetailLevel ( ) {
    short _result = 0;
    HRESULT _hr = get_MaxDetailLevel(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3783)
inline short VGCore::IVGTraceSettings::GetMinDetailLevel ( ) {
    short _result = 0;
    HRESULT _hr = get_MinDetailLevel(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3784)
inline short VGCore::IVGTraceSettings::GetCornerSmoothness ( ) {
    short _result = 0;
    HRESULT _hr = get_CornerSmoothness(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3785)
inline void VGCore::IVGTraceSettings::PutCornerSmoothness ( short pVal ) {
    HRESULT _hr = put_CornerSmoothness(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(3786)
inline VARIANT_BOOL VGCore::IVGTraceSettings::GetMergeAdjacentObjects ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_MergeAdjacentObjects(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3787)
inline void VGCore::IVGTraceSettings::PutMergeAdjacentObjects ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_MergeAdjacentObjects(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(3788)
inline VARIANT_BOOL VGCore::IVGTraceSettings::GetRemoveOverlap ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_RemoveOverlap(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3789)
inline void VGCore::IVGTraceSettings::PutRemoveOverlap ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_RemoveOverlap(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(3790)
inline VARIANT_BOOL VGCore::IVGTraceSettings::GetGroupObjectsByColor ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_GroupObjectsByColor(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3791)
inline void VGCore::IVGTraceSettings::PutGroupObjectsByColor ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_GroupObjectsByColor(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IVGShapeRange wrapper method implementations
//

#pragma implementation_key(3792)
inline VGCore::IVGApplicationPtr VGCore::IVGShapeRange::GetApplication ( ) {
    struct IVGApplication * _result = 0;
    HRESULT _hr = get_Application(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGApplicationPtr(_result, false);
}

#pragma implementation_key(3793)
inline VGCore::IVGApplicationPtr VGCore::IVGShapeRange::GetParent ( ) {
    struct IVGApplication * _result = 0;
    HRESULT _hr = get_Parent(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGApplicationPtr(_result, false);
}

#pragma implementation_key(3794)
inline VGCore::IVGShapePtr VGCore::IVGShapeRange::GetItem ( const _variant_t & IndexOrName ) {
    struct IVGShape * _result = 0;
    HRESULT _hr = get_Item(IndexOrName, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGShapePtr(_result, false);
}

#pragma implementation_key(3795)
inline IUnknownPtr VGCore::IVGShapeRange::Get_NewEnum ( ) {
    IUnknown * _result = 0;
    HRESULT _hr = get__NewEnum(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IUnknownPtr(_result, false);
}

#pragma implementation_key(3796)
inline long VGCore::IVGShapeRange::GetCount ( ) {
    long _result = 0;
    HRESULT _hr = get_Count(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3797)
inline HRESULT VGCore::IVGShapeRange::Add ( struct IVGShape * Shape ) {
    HRESULT _hr = raw_Add(Shape);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(3798)
inline HRESULT VGCore::IVGShapeRange::Remove ( long Index ) {
    HRESULT _hr = raw_Remove(Index);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(3799)
inline long VGCore::IVGShapeRange::IndexOf ( struct IVGShape * Shape ) {
    long _result = 0;
    HRESULT _hr = raw_IndexOf(Shape, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3800)
inline HRESULT VGCore::IVGShapeRange::AddToSelection ( ) {
    HRESULT _hr = raw_AddToSelection();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(3801)
inline HRESULT VGCore::IVGShapeRange::ConvertToCurves ( ) {
    HRESULT _hr = raw_ConvertToCurves();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(3802)
inline VGCore::IVGShapePtr VGCore::IVGShapeRange::ConvertToBitmap ( long BitDepth, VARIANT_BOOL Grayscale, VARIANT_BOOL Dithered, VARIANT_BOOL TransparentBG, long Resolution, enum cdrAntiAliasingType AntiAliasing, VARIANT_BOOL UseColorProfile, VARIANT_BOOL MultiChannel, VARIANT_BOOL AlwaysOverprintBlack, long OverprintBlackLimit ) {
    struct IVGShape * _result = 0;
    HRESULT _hr = raw_ConvertToBitmap(BitDepth, Grayscale, Dithered, TransparentBG, Resolution, AntiAliasing, UseColorProfile, MultiChannel, AlwaysOverprintBlack, OverprintBlackLimit, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGShapePtr(_result, false);
}

#pragma implementation_key(3803)
inline HRESULT VGCore::IVGShapeRange::Copy ( ) {
    HRESULT _hr = raw_Copy();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(3804)
inline HRESULT VGCore::IVGShapeRange::Cut ( ) {
    HRESULT _hr = raw_Cut();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(3805)
inline HRESULT VGCore::IVGShapeRange::Delete ( ) {
    HRESULT _hr = raw_Delete();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(3806)
inline HRESULT VGCore::IVGShapeRange::GetPosition ( double * PositionX, double * PositionY ) {
    HRESULT _hr = raw_GetPosition(PositionX, PositionY);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(3807)
inline HRESULT VGCore::IVGShapeRange::GetSize ( double * Width, double * Height ) {
    HRESULT _hr = raw_GetSize(Width, Height);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(3808)
inline HRESULT VGCore::IVGShapeRange::Move ( double DeltaX, double DeltaY ) {
    HRESULT _hr = raw_Move(DeltaX, DeltaY);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(3809)
inline VGCore::IVGShapeRangePtr VGCore::IVGShapeRange::Duplicate ( double OffsetX, double OffsetY ) {
    struct IVGShapeRange * _result = 0;
    HRESULT _hr = raw_Duplicate(OffsetX, OffsetY, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGShapeRangePtr(_result, false);
}

#pragma implementation_key(3810)
inline VGCore::IVGShapeRangePtr VGCore::IVGShapeRange::Clone ( double OffsetX, double OffsetY ) {
    struct IVGShapeRange * _result = 0;
    HRESULT _hr = raw_Clone(OffsetX, OffsetY, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGShapeRangePtr(_result, false);
}

#pragma implementation_key(3811)
inline VGCore::IVGShapePtr VGCore::IVGShapeRange::Group ( ) {
    struct IVGShape * _result = 0;
    HRESULT _hr = raw_Group(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGShapePtr(_result, false);
}

#pragma implementation_key(3812)
inline HRESULT VGCore::IVGShapeRange::RemoveAll ( ) {
    HRESULT _hr = raw_RemoveAll();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(3813)
inline HRESULT VGCore::IVGShapeRange::OrderToFront ( ) {
    HRESULT _hr = raw_OrderToFront();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(3814)
inline HRESULT VGCore::IVGShapeRange::OrderToBack ( ) {
    HRESULT _hr = raw_OrderToBack();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(3815)
inline HRESULT VGCore::IVGShapeRange::OrderForwardOne ( ) {
    HRESULT _hr = raw_OrderForwardOne();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(3816)
inline HRESULT VGCore::IVGShapeRange::OrderBackOne ( ) {
    HRESULT _hr = raw_OrderBackOne();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(3817)
inline HRESULT VGCore::IVGShapeRange::OrderFrontOf ( struct IVGShape * Shape ) {
    HRESULT _hr = raw_OrderFrontOf(Shape);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(3818)
inline HRESULT VGCore::IVGShapeRange::OrderBackOf ( struct IVGShape * Shape ) {
    HRESULT _hr = raw_OrderBackOf(Shape);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(3819)
inline HRESULT VGCore::IVGShapeRange::OrderReverse ( ) {
    HRESULT _hr = raw_OrderReverse();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(3820)
inline HRESULT VGCore::IVGShapeRange::Rotate ( double Angle ) {
    HRESULT _hr = raw_Rotate(Angle);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(3821)
inline HRESULT VGCore::IVGShapeRange::RotateEx ( double Angle, double CenterX, double CenterY ) {
    HRESULT _hr = raw_RotateEx(Angle, CenterX, CenterY);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(3822)
inline HRESULT VGCore::IVGShapeRange::Skew ( double AngleX, double AngleY ) {
    HRESULT _hr = raw_Skew(AngleX, AngleY);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(3823)
inline HRESULT VGCore::IVGShapeRange::SkewEx ( double AngleX, double AngleY, double CenterX, double CenterY ) {
    HRESULT _hr = raw_SkewEx(AngleX, AngleY, CenterX, CenterY);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(3824)
inline HRESULT VGCore::IVGShapeRange::UngroupAll ( ) {
    HRESULT _hr = raw_UngroupAll();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(3825)
inline HRESULT VGCore::IVGShapeRange::Flip ( enum cdrFlipAxes Axes ) {
    HRESULT _hr = raw_Flip(Axes);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(3826)
inline double VGCore::IVGShapeRange::GetPositionX ( ) {
    double _result = 0;
    HRESULT _hr = get_PositionX(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3827)
inline void VGCore::IVGShapeRange::PutPositionX ( double pVal ) {
    HRESULT _hr = put_PositionX(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(3828)
inline double VGCore::IVGShapeRange::GetPositionY ( ) {
    double _result = 0;
    HRESULT _hr = get_PositionY(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3829)
inline void VGCore::IVGShapeRange::PutPositionY ( double pVal ) {
    HRESULT _hr = put_PositionY(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(3830)
inline double VGCore::IVGShapeRange::GetSizeWidth ( ) {
    double _result = 0;
    HRESULT _hr = get_SizeWidth(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3831)
inline void VGCore::IVGShapeRange::PutSizeWidth ( double pVal ) {
    HRESULT _hr = put_SizeWidth(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(3832)
inline double VGCore::IVGShapeRange::GetSizeHeight ( ) {
    double _result = 0;
    HRESULT _hr = get_SizeHeight(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3833)
inline void VGCore::IVGShapeRange::PutSizeHeight ( double pVal ) {
    HRESULT _hr = put_SizeHeight(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(3834)
inline double VGCore::IVGShapeRange::GetRotationCenterX ( ) {
    double _result = 0;
    HRESULT _hr = get_RotationCenterX(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3835)
inline void VGCore::IVGShapeRange::PutRotationCenterX ( double pVal ) {
    HRESULT _hr = put_RotationCenterX(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(3836)
inline double VGCore::IVGShapeRange::GetRotationCenterY ( ) {
    double _result = 0;
    HRESULT _hr = get_RotationCenterY(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3837)
inline void VGCore::IVGShapeRange::PutRotationCenterY ( double pVal ) {
    HRESULT _hr = put_RotationCenterY(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(3838)
inline HRESULT VGCore::IVGShapeRange::AddToPowerClip ( struct IVGShape * Shape, enum cdrTriState CenterInContainer ) {
    HRESULT _hr = raw_AddToPowerClip(Shape, CenterInContainer);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(3839)
inline HRESULT VGCore::IVGShapeRange::RemoveFromContainer ( long Level ) {
    HRESULT _hr = raw_RemoveFromContainer(Level);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(3840)
inline HRESULT VGCore::IVGShapeRange::AddRange ( struct IVGShapeRange * ShapeRange ) {
    HRESULT _hr = raw_AddRange(ShapeRange);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(3841)
inline HRESULT VGCore::IVGShapeRange::SetPosition ( double PositionX, double PositionY ) {
    HRESULT _hr = raw_SetPosition(PositionX, PositionY);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(3842)
inline HRESULT VGCore::IVGShapeRange::SetSize ( double Width, double Height ) {
    HRESULT _hr = raw_SetSize(Width, Height);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(3843)
inline VGCore::IVGShapePtr VGCore::IVGShapeRange::ConvertToBitmapEx ( enum cdrImageType Mode, VARIANT_BOOL Dithered, VARIANT_BOOL Transparent, long Resolution, enum cdrAntiAliasingType AntiAliasing, VARIANT_BOOL UseColorProfile, VARIANT_BOOL AlwaysOverprintBlack, long OverprintBlackLimit ) {
    struct IVGShape * _result = 0;
    HRESULT _hr = raw_ConvertToBitmapEx(Mode, Dithered, Transparent, Resolution, AntiAliasing, UseColorProfile, AlwaysOverprintBlack, OverprintBlackLimit, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGShapePtr(_result, false);
}

#pragma implementation_key(3844)
inline VGCore::IVGShapePtr VGCore::IVGShapeRange::Combine ( ) {
    struct IVGShape * _result = 0;
    HRESULT _hr = raw_Combine(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGShapePtr(_result, false);
}

#pragma implementation_key(3845)
inline HRESULT VGCore::IVGShapeRange::SetBoundingBox ( double x, double y, double Width, double Height, VARIANT_BOOL KeepAspect, enum cdrReferencePoint ReferencePoint ) {
    HRESULT _hr = raw_SetBoundingBox(x, y, Width, Height, KeepAspect, ReferencePoint);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(3846)
inline HRESULT VGCore::IVGShapeRange::ApplyNoFill ( ) {
    HRESULT _hr = raw_ApplyNoFill();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(3847)
inline HRESULT VGCore::IVGShapeRange::ApplyUniformFill ( struct IVGColor * Color ) {
    HRESULT _hr = raw_ApplyUniformFill(Color);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(3848)
inline HRESULT VGCore::IVGShapeRange::ApplyFountainFill ( struct IVGColor * StartColor, struct IVGColor * EndColor, enum cdrFountainFillType Type, double Angle, long Steps, long EdgePad, long MidPoint, enum cdrFountainFillBlendType BlendType, double CenterOffsetX, double CenterOffsetY ) {
    HRESULT _hr = raw_ApplyFountainFill(StartColor, EndColor, Type, Angle, Steps, EdgePad, MidPoint, BlendType, CenterOffsetX, CenterOffsetY);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(3849)
inline HRESULT VGCore::IVGShapeRange::ApplyPatternFill ( enum cdrPatternFillType Type, _bstr_t FileName, long PatternCanvasIndex, struct IVGColor * FrontColor, struct IVGColor * EndColor, VARIANT_BOOL TransformWithShape ) {
    HRESULT _hr = raw_ApplyPatternFill(Type, FileName, PatternCanvasIndex, FrontColor, EndColor, TransformWithShape);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(3850)
inline HRESULT VGCore::IVGShapeRange::ApplyTextureFill ( _bstr_t TextureName, _bstr_t LibraryName ) {
    HRESULT _hr = raw_ApplyTextureFill(TextureName, LibraryName);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(3851)
inline HRESULT VGCore::IVGShapeRange::ApplyPostscriptFill ( const _variant_t & IndexOrName ) {
    HRESULT _hr = raw_ApplyPostscriptFill(IndexOrName);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(3852)
inline VGCore::IVGShapeRangePtr VGCore::IVGShapeRange::ConvertOutlineToObject ( ) {
    struct IVGShapeRange * _result = 0;
    HRESULT _hr = raw_ConvertOutlineToObject(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGShapeRangePtr(_result, false);
}

#pragma implementation_key(3853)
inline HRESULT VGCore::IVGShapeRange::SetOutlineProperties ( double Width, struct IVGOutlineStyle * Style, struct IVGColor * Color, struct IVGArrowHead * StartArrow, struct IVGArrowHead * EndArrow, enum cdrTriState BehindFill, enum cdrTriState ScaleWithShape, enum cdrOutlineLineCaps LineCaps, enum cdrOutlineLineJoin LineJoin, double NibAngle, long NibStretch, double DashDotLength, double PenWidth, double MiterLimit ) {
    HRESULT _hr = raw_SetOutlineProperties(Width, Style, Color, StartArrow, EndArrow, BehindFill, ScaleWithShape, LineCaps, LineJoin, NibAngle, NibStretch, DashDotLength, PenWidth, MiterLimit);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(3854)
inline HRESULT VGCore::IVGShapeRange::CreateSelection ( ) {
    HRESULT _hr = raw_CreateSelection();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(3855)
inline HRESULT VGCore::IVGShapeRange::RemoveFromSelection ( ) {
    HRESULT _hr = raw_RemoveFromSelection();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(3856)
inline HRESULT VGCore::IVGShapeRange::SetRotationCenter ( double x, double y ) {
    HRESULT _hr = raw_SetRotationCenter(x, y);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(3857)
inline HRESULT VGCore::IVGShapeRange::Stretch ( double StretchX, double StretchY, VARIANT_BOOL StretchCharactersSize ) {
    HRESULT _hr = raw_Stretch(StretchX, StretchY, StretchCharactersSize);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(3858)
inline HRESULT VGCore::IVGShapeRange::StretchEx ( double CenterX, double CenterY, double StretchX, double StretchY, VARIANT_BOOL StretchCharactersSize ) {
    HRESULT _hr = raw_StretchEx(CenterX, CenterY, StretchX, StretchY, StretchCharactersSize);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(3859)
inline HRESULT VGCore::IVGShapeRange::SetSizeEx ( double CenterX, double CenterY, double Width, double Height ) {
    HRESULT _hr = raw_SetSizeEx(CenterX, CenterY, Width, Height);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(3860)
inline HRESULT VGCore::IVGShapeRange::GetBoundingBox ( double * x, double * y, double * Width, double * Height, VARIANT_BOOL UseOutline ) {
    HRESULT _hr = raw_GetBoundingBox(x, y, Width, Height, UseOutline);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(3861)
inline HRESULT VGCore::IVGShapeRange::RestoreCloneLink ( enum cdrCloneLinkType LinkToRestore ) {
    HRESULT _hr = raw_RestoreCloneLink(LinkToRestore);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(3862)
inline HRESULT VGCore::IVGShapeRange::ClearEffect ( enum cdrEffectType Type ) {
    HRESULT _hr = raw_ClearEffect(Type);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(3863)
inline HRESULT VGCore::IVGShapeRange::RemoveRange ( struct IVGShapeRange * Range ) {
    HRESULT _hr = raw_RemoveRange(Range);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(3864)
inline HRESULT VGCore::IVGShapeRange::DeleteItem ( long Index ) {
    HRESULT _hr = raw_DeleteItem(Index);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(3865)
inline _variant_t VGCore::IVGShapeRange::CustomCommand ( _bstr_t ComponentID, _bstr_t CommandID, SAFEARRAY * * Parameters ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = raw_CustomCommand(ComponentID, CommandID, Parameters, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

#pragma implementation_key(3866)
inline HRESULT VGCore::IVGShapeRange::AlignToShape ( enum cdrAlignType Type, struct IVGShape * Shape, enum cdrTextAlignOrigin TextAlignOrigin ) {
    HRESULT _hr = raw_AlignToShape(Type, Shape, TextAlignOrigin);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(3867)
inline HRESULT VGCore::IVGShapeRange::AlignToShapeRange ( enum cdrAlignType Type, struct IVGShapeRange * ShapeRange, enum cdrTextAlignOrigin TextAlignOrigin ) {
    HRESULT _hr = raw_AlignToShapeRange(Type, ShapeRange, TextAlignOrigin);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(3868)
inline HRESULT VGCore::IVGShapeRange::AlignToPage ( enum cdrAlignType Type, enum cdrTextAlignOrigin TextAlignOrigin ) {
    HRESULT _hr = raw_AlignToPage(Type, TextAlignOrigin);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(3869)
inline HRESULT VGCore::IVGShapeRange::AlignToPageCenter ( enum cdrAlignType Type, enum cdrTextAlignOrigin TextAlignOrigin ) {
    HRESULT _hr = raw_AlignToPageCenter(Type, TextAlignOrigin);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(3870)
inline HRESULT VGCore::IVGShapeRange::AlignToGrid ( enum cdrAlignType Type, enum cdrTextAlignOrigin TextAlignOrigin ) {
    HRESULT _hr = raw_AlignToGrid(Type, TextAlignOrigin);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(3871)
inline HRESULT VGCore::IVGShapeRange::AlignToPoint ( enum cdrAlignType Type, double x, double y, enum cdrTextAlignOrigin TextAlignOrigin ) {
    HRESULT _hr = raw_AlignToPoint(Type, x, y, TextAlignOrigin);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(3872)
inline HRESULT VGCore::IVGShapeRange::Distribute ( enum cdrDistributeType Type, VARIANT_BOOL PageExtent ) {
    HRESULT _hr = raw_Distribute(Type, PageExtent);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(3873)
inline VGCore::IVGShapePtr VGCore::IVGShapeRange::ConvertToSymbol ( _bstr_t Name ) {
    struct IVGShape * _result = 0;
    HRESULT _hr = raw_ConvertToSymbol(Name, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGShapePtr(_result, false);
}

#pragma implementation_key(3874)
inline HRESULT VGCore::IVGShapeRange::Ungroup ( ) {
    HRESULT _hr = raw_Ungroup();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(3875)
inline VGCore::IVGShapeRangePtr VGCore::IVGShapeRange::UngroupEx ( ) {
    struct IVGShapeRange * _result = 0;
    HRESULT _hr = raw_UngroupEx(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGShapeRangePtr(_result, false);
}

#pragma implementation_key(3876)
inline VGCore::IVGShapeRangePtr VGCore::IVGShapeRange::UngroupAllEx ( ) {
    struct IVGShapeRange * _result = 0;
    HRESULT _hr = raw_UngroupAllEx(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGShapeRangePtr(_result, false);
}

#pragma implementation_key(3877)
inline VGCore::IVGShapeRangePtr VGCore::IVGShapeRange::Range ( SAFEARRAY * * IndexArray ) {
    struct IVGShapeRange * _result = 0;
    HRESULT _hr = raw_Range(IndexArray, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGShapeRangePtr(_result, false);
}

#pragma implementation_key(3878)
inline VGCore::IVGShapeRangePtr VGCore::IVGShapeRange::All ( ) {
    struct IVGShapeRange * _result = 0;
    HRESULT _hr = raw_All(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGShapeRangePtr(_result, false);
}

#pragma implementation_key(3879)
inline VGCore::IVGShapeRangePtr VGCore::IVGShapeRange::AllExcluding ( SAFEARRAY * * IndexArray ) {
    struct IVGShapeRange * _result = 0;
    HRESULT _hr = raw_AllExcluding(IndexArray, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGShapeRangePtr(_result, false);
}

#pragma implementation_key(3880)
inline HRESULT VGCore::IVGShapeRange::BreakApart ( ) {
    HRESULT _hr = raw_BreakApart();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(3881)
inline VGCore::IVGShapeRangePtr VGCore::IVGShapeRange::BreakApartEx ( ) {
    struct IVGShapeRange * _result = 0;
    HRESULT _hr = raw_BreakApartEx(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGShapeRangePtr(_result, false);
}

#pragma implementation_key(3882)
inline HRESULT VGCore::IVGShapeRange::MoveToLayer ( struct IVGLayer * Layer ) {
    HRESULT _hr = raw_MoveToLayer(Layer);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(3883)
inline VGCore::IVGShapeRangePtr VGCore::IVGShapeRange::CopyToLayer ( struct IVGLayer * Layer ) {
    struct IVGShapeRange * _result = 0;
    HRESULT _hr = raw_CopyToLayer(Layer, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGShapeRangePtr(_result, false);
}

#pragma implementation_key(3884)
inline HRESULT VGCore::IVGShapeRange::ClearTransformations ( ) {
    HRESULT _hr = raw_ClearTransformations();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(3885)
inline HRESULT VGCore::IVGShapeRange::Lock ( ) {
    HRESULT _hr = raw_Lock();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(3886)
inline HRESULT VGCore::IVGShapeRange::Unlock ( ) {
    HRESULT _hr = raw_Unlock();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(3887)
inline HRESULT VGCore::IVGShapeRange::AlignRangeToShape ( enum cdrAlignType Type, struct IVGShape * Shape ) {
    HRESULT _hr = raw_AlignRangeToShape(Type, Shape);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(3888)
inline HRESULT VGCore::IVGShapeRange::AlignRangeToShapeRange ( enum cdrAlignType Type, struct IVGShapeRange * ShapeRange ) {
    HRESULT _hr = raw_AlignRangeToShapeRange(Type, ShapeRange);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(3889)
inline HRESULT VGCore::IVGShapeRange::AlignRangeToPage ( enum cdrAlignType Type ) {
    HRESULT _hr = raw_AlignRangeToPage(Type);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(3890)
inline HRESULT VGCore::IVGShapeRange::AlignRangeToPageCenter ( enum cdrAlignType Type ) {
    HRESULT _hr = raw_AlignRangeToPageCenter(Type);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(3891)
inline HRESULT VGCore::IVGShapeRange::AlignRangeToGrid ( enum cdrAlignType Type ) {
    HRESULT _hr = raw_AlignRangeToGrid(Type);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(3892)
inline HRESULT VGCore::IVGShapeRange::AlignRangeToPoint ( enum cdrAlignType Type, double x, double y ) {
    HRESULT _hr = raw_AlignRangeToPoint(Type, x, y);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(3893)
inline HRESULT VGCore::IVGShapeRange::ApplyEffectInvert ( ) {
    HRESULT _hr = raw_ApplyEffectInvert();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(3894)
inline HRESULT VGCore::IVGShapeRange::ApplyEffectPosterize ( long Level ) {
    HRESULT _hr = raw_ApplyEffectPosterize(Level);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(3895)
inline HRESULT VGCore::IVGShapeRange::ApplyEffectBCI ( long Brighness, long Contrast, long Intensity ) {
    HRESULT _hr = raw_ApplyEffectBCI(Brighness, Contrast, Intensity);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(3896)
inline HRESULT VGCore::IVGShapeRange::ApplyEffectColorBalance ( long CyanRed, long MagentaGreen, long YellowBlue, VARIANT_BOOL ApplyToShadows, VARIANT_BOOL ApplyToMidtones, VARIANT_BOOL ApplyToHighlights, VARIANT_BOOL PreserveLuminance ) {
    HRESULT _hr = raw_ApplyEffectColorBalance(CyanRed, MagentaGreen, YellowBlue, ApplyToShadows, ApplyToMidtones, ApplyToHighlights, PreserveLuminance);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(3897)
inline HRESULT VGCore::IVGShapeRange::ApplyEffectGamma ( double Gamma ) {
    HRESULT _hr = raw_ApplyEffectGamma(Gamma);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(3898)
inline HRESULT VGCore::IVGShapeRange::ApplyEffectHSL ( const _variant_t & Hue, const _variant_t & Saturation, const _variant_t & Lightness ) {
    HRESULT _hr = raw_ApplyEffectHSL(Hue, Saturation, Lightness);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(3899)
inline HRESULT VGCore::IVGShapeRange::AffineTransform ( double d11, double d12, double d21, double d22, double CenterX, double CenterY ) {
    HRESULT _hr = raw_AffineTransform(d11, d12, d21, d22, CenterX, CenterY);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(3900)
inline HRESULT VGCore::IVGShapeRange::ApplyFill ( struct IVGFill * Fill ) {
    HRESULT _hr = raw_ApplyFill(Fill);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(3901)
inline HRESULT VGCore::IVGShapeRange::ApplyOutline ( struct IVGOutline * Outline ) {
    HRESULT _hr = raw_ApplyOutline(Outline);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(3902)
inline VGCore::IVGShapeRangePtr VGCore::IVGShapeRange::GetReverseRange ( ) {
    struct IVGShapeRange * _result = 0;
    HRESULT _hr = get_ReverseRange(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGShapeRangePtr(_result, false);
}

#pragma implementation_key(3903)
inline HRESULT VGCore::IVGShapeRange::Fillet ( double Radius, VARIANT_BOOL CombineSmoothSegments ) {
    HRESULT _hr = raw_Fillet(Radius, CombineSmoothSegments);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(3904)
inline HRESULT VGCore::IVGShapeRange::Chamfer ( double DistanceA, double DistanceB, VARIANT_BOOL CombineSmoothSegments ) {
    HRESULT _hr = raw_Chamfer(DistanceA, DistanceB, CombineSmoothSegments);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(3905)
inline HRESULT VGCore::IVGShapeRange::Scallop ( double Radius, VARIANT_BOOL CombineSmoothSegments ) {
    HRESULT _hr = raw_Scallop(Radius, CombineSmoothSegments);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(3906)
inline HRESULT VGCore::IVGShapeRange::SetFillMode ( enum cdrFillMode Mode ) {
    HRESULT _hr = raw_SetFillMode(Mode);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(3907)
inline HRESULT VGCore::IVGShapeRange::ApplyCustomHatchFill ( double Angle, double Spacing, double Shift, double OriginX, double OriginY, double Width, struct IVGColor * Color, struct IVGOutlineStyle * Style, double DashDotLength, double PenWidth, struct IVGColor * BackColor, VARIANT_BOOL TransformWithShape, VARIANT_BOOL ScaleLinesWithShape, VARIANT_BOOL UseWorldCoordinates, double FillScale, double LineScale, double FillAngle, double FillSkew ) {
    HRESULT _hr = raw_ApplyCustomHatchFill(Angle, Spacing, Shift, OriginX, OriginY, Width, Color, Style, DashDotLength, PenWidth, BackColor, TransformWithShape, ScaleLinesWithShape, UseWorldCoordinates, FillScale, LineScale, FillAngle, FillSkew);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(3908)
inline HRESULT VGCore::IVGShapeRange::ApplyHatchFill ( _bstr_t LibraryName, const _variant_t & HatchNameOrIndex, struct IVGColor * BackColor, VARIANT_BOOL TransformWithShape, VARIANT_BOOL ScaleLinesWithShape, VARIANT_BOOL UseWorldCoordinates, double FillScale, double LineScale, double FillAngle, double FillSkew ) {
    HRESULT _hr = raw_ApplyHatchFill(LibraryName, HatchNameOrIndex, BackColor, TransformWithShape, ScaleLinesWithShape, UseWorldCoordinates, FillScale, LineScale, FillAngle, FillSkew);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(3909)
inline double VGCore::IVGShapeRange::GetLeftX ( ) {
    double _result = 0;
    HRESULT _hr = get_LeftX(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3910)
inline double VGCore::IVGShapeRange::GetRightX ( ) {
    double _result = 0;
    HRESULT _hr = get_RightX(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3911)
inline double VGCore::IVGShapeRange::GetTopY ( ) {
    double _result = 0;
    HRESULT _hr = get_TopY(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3912)
inline double VGCore::IVGShapeRange::GetBottomY ( ) {
    double _result = 0;
    HRESULT _hr = get_BottomY(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3913)
inline VGCore::IVGShapesPtr VGCore::IVGShapeRange::GetShapes ( ) {
    struct IVGShapes * _result = 0;
    HRESULT _hr = get_Shapes(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGShapesPtr(_result, false);
}

#pragma implementation_key(3914)
inline VGCore::IVGShapePtr VGCore::IVGShapeRange::GetFirstShape ( ) {
    struct IVGShape * _result = 0;
    HRESULT _hr = get_FirstShape(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGShapePtr(_result, false);
}

#pragma implementation_key(3915)
inline VGCore::IVGShapePtr VGCore::IVGShapeRange::GetLastShape ( ) {
    struct IVGShape * _result = 0;
    HRESULT _hr = get_LastShape(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGShapePtr(_result, false);
}

#pragma implementation_key(3916)
inline VGCore::IVGShapeRangePtr VGCore::IVGShapeRange::StepAndRepeat ( long NumCopies, double DistanceX, double DistanceY, enum cdrDistanceMode ModeX, enum cdrDirection DirectionX, enum cdrDistanceMode ModeY, enum cdrDirection DirectionY ) {
    struct IVGShapeRange * _result = 0;
    HRESULT _hr = raw_StepAndRepeat(NumCopies, DistanceX, DistanceY, ModeX, DirectionX, ModeY, DirectionY, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGShapeRangePtr(_result, false);
}

#pragma implementation_key(3917)
inline VARIANT_BOOL VGCore::IVGShapeRange::Exists ( struct IVGShape * Shape ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_Exists(Shape, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3918)
inline VARIANT_BOOL VGCore::IVGShapeRange::ExistsAnyOfType ( SAFEARRAY * * TypeList ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_ExistsAnyOfType(TypeList, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3919)
inline long VGCore::IVGShapeRange::CountAnyOfType ( SAFEARRAY * * TypeList ) {
    long _result = 0;
    HRESULT _hr = raw_CountAnyOfType(TypeList, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3920)
inline VGCore::IVGShapeRangePtr VGCore::IVGShapeRange::FindAnyOfType ( SAFEARRAY * * TypeList ) {
    struct IVGShapeRange * _result = 0;
    HRESULT _hr = raw_FindAnyOfType(TypeList, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGShapeRangePtr(_result, false);
}

#pragma implementation_key(3921)
inline VGCore::IVGShapeRangePtr VGCore::IVGShapeRange::GetLinkedShapes ( enum cdrShapeLinkType LinkType ) {
    struct IVGShapeRange * _result = 0;
    HRESULT _hr = raw_GetLinkedShapes(LinkType, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGShapeRangePtr(_result, false);
}

#pragma implementation_key(3922)
inline VGCore::IVGRectPtr VGCore::IVGShapeRange::GetBoundingBox ( ) {
    struct IVGRect * _result = 0;
    HRESULT _hr = get_BoundingBox(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGRectPtr(_result, false);
}

#pragma implementation_key(3923)
inline HRESULT VGCore::IVGShapeRange::GetPositionEx ( enum cdrReferencePoint ReferencePoint, double * x, double * y ) {
    HRESULT _hr = raw_GetPositionEx(ReferencePoint, x, y);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(3924)
inline HRESULT VGCore::IVGShapeRange::SetPositionEx ( enum cdrReferencePoint ReferencePoint, double x, double y ) {
    HRESULT _hr = raw_SetPositionEx(ReferencePoint, x, y);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(3925)
inline double VGCore::IVGShapeRange::GetCenterX ( ) {
    double _result = 0;
    HRESULT _hr = get_CenterX(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3926)
inline void VGCore::IVGShapeRange::PutCenterX ( double pVal ) {
    HRESULT _hr = put_CenterX(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(3927)
inline double VGCore::IVGShapeRange::GetCenterY ( ) {
    double _result = 0;
    HRESULT _hr = get_CenterY(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3928)
inline void VGCore::IVGShapeRange::PutCenterY ( double pVal ) {
    HRESULT _hr = put_CenterY(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(3929)
inline void VGCore::IVGShapeRange::PutLeftX ( double pVal ) {
    HRESULT _hr = put_LeftX(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(3930)
inline void VGCore::IVGShapeRange::PutRightX ( double pVal ) {
    HRESULT _hr = put_RightX(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(3931)
inline void VGCore::IVGShapeRange::PutTopY ( double pVal ) {
    HRESULT _hr = put_TopY(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(3932)
inline void VGCore::IVGShapeRange::PutBottomY ( double pVal ) {
    HRESULT _hr = put_BottomY(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(3933)
inline VARIANT_BOOL VGCore::IVGShapeRange::CopyPropertiesFrom ( struct IVGShape * Source, enum cdrCopyProperties Properties ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_CopyPropertiesFrom(Source, Properties, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3934)
inline enum VGCore::cdrOverprintState VGCore::IVGShapeRange::GetOverprintFillState ( ) {
    enum cdrOverprintState _result;
    HRESULT _hr = raw_GetOverprintFillState(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3935)
inline enum VGCore::cdrOverprintState VGCore::IVGShapeRange::GetOverprintOutlineState ( ) {
    enum cdrOverprintState _result;
    HRESULT _hr = raw_GetOverprintOutlineState(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3936)
inline HRESULT VGCore::IVGShapeRange::Sort ( _bstr_t CompareExpression, long StartIndex, long EndIndex, const _variant_t & Data ) {
    HRESULT _hr = raw_Sort(CompareExpression, StartIndex, EndIndex, Data);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(3937)
inline HRESULT VGCore::IVGShapeRange::SetPixelAlignedRendering ( VARIANT_BOOL PixelAligned ) {
    HRESULT _hr = raw_SetPixelAlignedRendering(PixelAligned);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(3938)
inline VGCore::IVGDocumentPtr VGCore::IVGShapeRange::CreateDocumentFrom ( VARIANT_BOOL TemporaryDocument ) {
    struct IVGDocument * _result = 0;
    HRESULT _hr = raw_CreateDocumentFrom(TemporaryDocument, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGDocumentPtr(_result, false);
}

#pragma implementation_key(3939)
inline HRESULT VGCore::IVGShapeRange::AlignAndDistribute ( enum cdrAlignDistributeH MethodH, enum cdrAlignDistributeV MethodV, enum cdrAlignShapesTo AlignTo, enum cdrDistributeArea DistributeArea, VARIANT_BOOL UseOutline, enum cdrTextAlignOrigin TextAlignOrigin, double PointX, double PointY, struct IVGRect * DistributeRect ) {
    HRESULT _hr = raw_AlignAndDistribute(MethodH, MethodV, AlignTo, DistributeArea, UseOutline, TextAlignOrigin, PointX, PointY, DistributeRect);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(3940)
inline HRESULT VGCore::IVGShapeRange::SetOutlinePropertiesEx ( double Width, struct IVGOutlineStyle * Style, struct IVGColor * Color, struct IVGArrowHead * StartArrow, struct IVGArrowHead * EndArrow, enum cdrTriState BehindFill, enum cdrTriState ScaleWithShape, enum cdrOutlineLineCaps LineCaps, enum cdrOutlineLineJoin LineJoin, double NibAngle, long NibStretch, double DashDotLength, double PenWidth, double MiterLimit, enum cdrOutlineJustification Justification ) {
    HRESULT _hr = raw_SetOutlinePropertiesEx(Width, Style, Color, StartArrow, EndArrow, BehindFill, ScaleWithShape, LineCaps, LineJoin, NibAngle, NibStretch, DashDotLength, PenWidth, MiterLimit, Justification);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(3941)
inline VGCore::IVGShapePtr VGCore::IVGShapeRange::CreateBoundary ( double x, double y, VARIANT_BOOL PlaceOnTop, VARIANT_BOOL DeleteSource ) {
    struct IVGShape * _result = 0;
    HRESULT _hr = raw_CreateBoundary(x, y, PlaceOnTop, DeleteSource, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGShapePtr(_result, false);
}

#pragma implementation_key(3942)
inline VGCore::IVGShapeRangePtr VGCore::IVGShapeRange::EqualDivide ( long Divisions, double Gap, VARIANT_BOOL Group, VARIANT_BOOL Combine, VARIANT_BOOL DeleteSource ) {
    struct IVGShapeRange * _result = 0;
    HRESULT _hr = raw_EqualDivide(Divisions, Gap, Group, Combine, DeleteSource, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGShapeRangePtr(_result, false);
}

#pragma implementation_key(3943)
inline VGCore::IVGShapeRangePtr VGCore::IVGShapeRange::Project ( enum cdrProjectPlane Plane, enum cdrReferencePoint ReferencePoint, VARIANT_BOOL ApplyToDuplicate ) {
    struct IVGShapeRange * _result = 0;
    HRESULT _hr = raw_Project(Plane, ReferencePoint, ApplyToDuplicate, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGShapeRangePtr(_result, false);
}

#pragma implementation_key(3944)
inline VGCore::IVGShapeRangePtr VGCore::IVGShapeRange::Unproject ( enum cdrProjectPlane Plane, enum cdrReferencePoint ReferencePoint, VARIANT_BOOL ApplyToDuplicate ) {
    struct IVGShapeRange * _result = 0;
    HRESULT _hr = raw_Unproject(Plane, ReferencePoint, ApplyToDuplicate, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGShapeRangePtr(_result, false);
}

#pragma implementation_key(3945)
inline HRESULT VGCore::IVGShapeRange::Show ( ) {
    HRESULT _hr = raw_Show();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(3946)
inline HRESULT VGCore::IVGShapeRange::Hide ( ) {
    HRESULT _hr = raw_Hide();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(3947)
inline VGCore::IVGShapeRangePtr VGCore::IVGShapeRange::GetToolShapes ( _bstr_t ShapeGuid ) {
    struct IVGShapeRange * _result = 0;
    HRESULT _hr = raw_GetToolShapes(ShapeGuid, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGShapeRangePtr(_result, false);
}

#pragma implementation_key(3948)
inline HRESULT VGCore::IVGShapeRange::ModifyToolShapeProperties ( struct IVGProperties * ShapePropertiesToModify ) {
    HRESULT _hr = raw_ModifyToolShapeProperties(ShapePropertiesToModify);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(3949)
inline VGCore::IVGShapeRangePtr VGCore::IVGShapeRange::CreateParallelCurves ( long Count, double distanceBetweenCurves ) {
    struct IVGShapeRange * _result = 0;
    HRESULT _hr = raw_CreateParallelCurves(Count, distanceBetweenCurves, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGShapeRangePtr(_result, false);
}

#pragma implementation_key(3950)
inline SAFEARRAY * VGCore::IVGShapeRange::GetColorTypes ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_GetColorTypes(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3951)
inline SAFEARRAY * VGCore::IVGShapeRange::GetColors ( long MaxBitmapColors ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_GetColors(MaxBitmapColors, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3952)
inline HRESULT VGCore::IVGShapeRange::FlattenEffects ( ) {
    HRESULT _hr = raw_FlattenEffects();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface IVGPowerClip wrapper method implementations
//

#pragma implementation_key(3953)
inline VGCore::IVGApplicationPtr VGCore::IVGPowerClip::GetApplication ( ) {
    struct IVGApplication * _result = 0;
    HRESULT _hr = get_Application(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGApplicationPtr(_result, false);
}

#pragma implementation_key(3954)
inline VGCore::IVGShapePtr VGCore::IVGPowerClip::GetParent ( ) {
    struct IVGShape * _result = 0;
    HRESULT _hr = get_Parent(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGShapePtr(_result, false);
}

#pragma implementation_key(3955)
inline VGCore::IVGShapesPtr VGCore::IVGPowerClip::GetShapes ( ) {
    struct IVGShapes * _result = 0;
    HRESULT _hr = get_Shapes(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGShapesPtr(_result, false);
}

#pragma implementation_key(3956)
inline VARIANT_BOOL VGCore::IVGPowerClip::GetContentsLocked ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_ContentsLocked(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3957)
inline void VGCore::IVGPowerClip::PutContentsLocked ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_ContentsLocked(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(3958)
inline HRESULT VGCore::IVGPowerClip::EnterEditMode ( ) {
    HRESULT _hr = raw_EnterEditMode();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(3959)
inline HRESULT VGCore::IVGPowerClip::LeaveEditMode ( ) {
    HRESULT _hr = raw_LeaveEditMode();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(3960)
inline VGCore::IVGShapeRangePtr VGCore::IVGPowerClip::ExtractShapes ( ) {
    struct IVGShapeRange * _result = 0;
    HRESULT _hr = raw_ExtractShapes(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGShapeRangePtr(_result, false);
}

//
// interface IVGFill wrapper method implementations
//

#pragma implementation_key(3961)
inline enum VGCore::cdrFillType VGCore::IVGFill::GetType ( ) {
    enum cdrFillType _result;
    HRESULT _hr = get_Type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3962)
inline VGCore::IVGColorPtr VGCore::IVGFill::GetUniformColor ( ) {
    struct IVGColor * _result = 0;
    HRESULT _hr = get_UniformColor(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGColorPtr(_result, false);
}

#pragma implementation_key(3963)
inline void VGCore::IVGFill::PutUniformColor ( struct IVGColor * ppVal ) {
    HRESULT _hr = put_UniformColor(ppVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(3964)
inline VGCore::IVGFountainFillPtr VGCore::IVGFill::GetFountain ( ) {
    struct IVGFountainFill * _result = 0;
    HRESULT _hr = get_Fountain(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGFountainFillPtr(_result, false);
}

#pragma implementation_key(3965)
inline void VGCore::IVGFill::PutFountain ( struct IVGFountainFill * ppVal ) {
    HRESULT _hr = put_Fountain(ppVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(3966)
inline VGCore::IVGPatternFillPtr VGCore::IVGFill::GetPattern ( ) {
    struct IVGPatternFill * _result = 0;
    HRESULT _hr = get_Pattern(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGPatternFillPtr(_result, false);
}

#pragma implementation_key(3967)
inline void VGCore::IVGFill::PutPattern ( struct IVGPatternFill * ppVal ) {
    HRESULT _hr = put_Pattern(ppVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(3968)
inline VGCore::IVGTextureFillPtr VGCore::IVGFill::GetTexture ( ) {
    struct IVGTextureFill * _result = 0;
    HRESULT _hr = get_Texture(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGTextureFillPtr(_result, false);
}

#pragma implementation_key(3969)
inline void VGCore::IVGFill::PutTexture ( struct IVGTextureFill * ppVal ) {
    HRESULT _hr = put_Texture(ppVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(3970)
inline VGCore::IVGPostScriptFillPtr VGCore::IVGFill::GetPostScript ( ) {
    struct IVGPostScriptFill * _result = 0;
    HRESULT _hr = get_PostScript(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGPostScriptFillPtr(_result, false);
}

#pragma implementation_key(3971)
inline void VGCore::IVGFill::PutPostScript ( struct IVGPostScriptFill * ppVal ) {
    HRESULT _hr = put_PostScript(ppVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(3972)
inline HRESULT VGCore::IVGFill::ApplyNoFill ( ) {
    HRESULT _hr = raw_ApplyNoFill();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(3973)
inline HRESULT VGCore::IVGFill::ApplyUniformFill ( struct IVGColor * Color ) {
    HRESULT _hr = raw_ApplyUniformFill(Color);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(3974)
inline VGCore::IVGFountainFillPtr VGCore::IVGFill::ApplyFountainFill ( struct IVGColor * StartColor, struct IVGColor * EndColor, enum cdrFountainFillType Type, double Angle, long Steps, long EdgePad, long MidPoint, enum cdrFountainFillBlendType BlendType, double CenterOffsetX, double CenterOffsetY ) {
    struct IVGFountainFill * _result = 0;
    HRESULT _hr = raw_ApplyFountainFill(StartColor, EndColor, Type, Angle, Steps, EdgePad, MidPoint, BlendType, CenterOffsetX, CenterOffsetY, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGFountainFillPtr(_result, false);
}

#pragma implementation_key(3975)
inline VGCore::IVGPatternFillPtr VGCore::IVGFill::ApplyPatternFill ( enum cdrPatternFillType Type, _bstr_t FileName, long PatternCanvasIndex, struct IVGColor * FrontColor, struct IVGColor * EndColor, VARIANT_BOOL TransformWithShape ) {
    struct IVGPatternFill * _result = 0;
    HRESULT _hr = raw_ApplyPatternFill(Type, FileName, PatternCanvasIndex, FrontColor, EndColor, TransformWithShape, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGPatternFillPtr(_result, false);
}

#pragma implementation_key(3976)
inline VGCore::IVGTextureFillPtr VGCore::IVGFill::ApplyTextureFill ( _bstr_t TextureName, _bstr_t LibraryName ) {
    struct IVGTextureFill * _result = 0;
    HRESULT _hr = raw_ApplyTextureFill(TextureName, LibraryName, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGTextureFillPtr(_result, false);
}

#pragma implementation_key(3977)
inline VGCore::IVGPostScriptFillPtr VGCore::IVGFill::ApplyPostscriptFill ( const _variant_t & IndexOrName ) {
    struct IVGPostScriptFill * _result = 0;
    HRESULT _hr = raw_ApplyPostscriptFill(IndexOrName, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGPostScriptFillPtr(_result, false);
}

#pragma implementation_key(3978)
inline VGCore::IVGFillPtr VGCore::IVGFill::GetCopy ( ) {
    struct IVGFill * _result = 0;
    HRESULT _hr = raw_GetCopy(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGFillPtr(_result, false);
}

#pragma implementation_key(3979)
inline HRESULT VGCore::IVGFill::CopyAssign ( struct IVGFill * SourceFill ) {
    HRESULT _hr = raw_CopyAssign(SourceFill);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(3980)
inline VARIANT_BOOL VGCore::IVGFill::UserAssign ( enum cdrFillType FillType, enum cdrPatternFillType PatternType, long ParentWindowHandle ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_UserAssign(FillType, PatternType, ParentWindowHandle, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3981)
inline VGCore::IVGPSScreenOptionsPtr VGCore::IVGFill::GetPSScreen ( ) {
    struct IVGPSScreenOptions * _result = 0;
    HRESULT _hr = get_PSScreen(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGPSScreenOptionsPtr(_result, false);
}

#pragma implementation_key(3982)
inline VGCore::IVGHatchFillPtr VGCore::IVGFill::GetHatch ( ) {
    struct IVGHatchFill * _result = 0;
    HRESULT _hr = get_Hatch(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGHatchFillPtr(_result, false);
}

#pragma implementation_key(3983)
inline void VGCore::IVGFill::PutHatch ( struct IVGHatchFill * ppVal ) {
    HRESULT _hr = put_Hatch(ppVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(3984)
inline VARIANT_BOOL VGCore::IVGFill::CompareWith ( struct IVGFill * Fill ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_CompareWith(Fill, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3985)
inline VGCore::IVGHatchFillPtr VGCore::IVGFill::ApplyCustomHatchFill ( double Angle, double Spacing, double Shift, double OriginX, double OriginY, double Width, struct IVGColor * Color, struct IVGOutlineStyle * Style, double DashDotLength, double PenWidth, struct IVGColor * BackColor, VARIANT_BOOL TransformWithShape, VARIANT_BOOL ScaleLinesWithShape, VARIANT_BOOL UseWorldCoordinates, double FillScale, double LineScale, double FillAngle, double FillSkew ) {
    struct IVGHatchFill * _result = 0;
    HRESULT _hr = raw_ApplyCustomHatchFill(Angle, Spacing, Shift, OriginX, OriginY, Width, Color, Style, DashDotLength, PenWidth, BackColor, TransformWithShape, ScaleLinesWithShape, UseWorldCoordinates, FillScale, LineScale, FillAngle, FillSkew, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGHatchFillPtr(_result, false);
}

#pragma implementation_key(3986)
inline VGCore::IVGHatchFillPtr VGCore::IVGFill::ApplyHatchFill ( _bstr_t LibraryName, const _variant_t & HatchNameOrIndex, struct IVGColor * BackColor, VARIANT_BOOL TransformWithShape, VARIANT_BOOL ScaleLinesWithShape, VARIANT_BOOL UseWorldCoordinates, double FillScale, double LineScale, double FillAngle, double FillSkew ) {
    struct IVGHatchFill * _result = 0;
    HRESULT _hr = raw_ApplyHatchFill(LibraryName, HatchNameOrIndex, BackColor, TransformWithShape, ScaleLinesWithShape, UseWorldCoordinates, FillScale, LineScale, FillAngle, FillSkew, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGHatchFillPtr(_result, false);
}

#pragma implementation_key(3987)
inline _bstr_t VGCore::IVGFill::ToString ( ) {
    BSTR _result = 0;
    HRESULT _hr = raw_ToString(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(3988)
inline VARIANT_BOOL VGCore::IVGFill::StringAssign ( _bstr_t FillString ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_StringAssign(FillString, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface IVGHatchFills wrapper method implementations
//

#pragma implementation_key(3989)
inline VGCore::IVGFillPtr VGCore::IVGHatchFills::GetItem ( const _variant_t & IndexOrName ) {
    struct IVGFill * _result = 0;
    HRESULT _hr = get_Item(IndexOrName, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGFillPtr(_result, false);
}

#pragma implementation_key(3990)
inline long VGCore::IVGHatchFills::GetCount ( ) {
    long _result = 0;
    HRESULT _hr = get_Count(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3991)
inline IUnknownPtr VGCore::IVGHatchFills::Get_NewEnum ( ) {
    IUnknown * _result = 0;
    HRESULT _hr = get__NewEnum(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IUnknownPtr(_result, false);
}

#pragma implementation_key(3992)
inline VGCore::IVGFillPtr VGCore::IVGHatchFills::Find ( _bstr_t Name ) {
    struct IVGFill * _result = 0;
    HRESULT _hr = raw_Find(Name, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGFillPtr(_result, false);
}

//
// interface IVGHatchLibrary wrapper method implementations
//

#pragma implementation_key(3993)
inline _bstr_t VGCore::IVGHatchLibrary::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(3994)
inline VGCore::IVGHatchFillsPtr VGCore::IVGHatchLibrary::GetFills ( ) {
    struct IVGHatchFills * _result = 0;
    HRESULT _hr = get_Fills(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGHatchFillsPtr(_result, false);
}

#pragma implementation_key(3995)
inline VARIANT_BOOL VGCore::IVGHatchLibrary::GetActive ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_Active(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3996)
inline long VGCore::IVGHatchLibrary::GetIndex ( ) {
    long _result = 0;
    HRESULT _hr = get_Index(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(3997)
inline HRESULT VGCore::IVGHatchLibrary::Activate ( ) {
    HRESULT _hr = raw_Activate();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(3998)
inline _bstr_t VGCore::IVGHatchLibrary::GetDisplayName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_DisplayName(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

//
// interface IVGHatchFill wrapper method implementations
//

#pragma implementation_key(3999)
inline VGCore::IVGColorPtr VGCore::IVGHatchFill::GetBackColor ( ) {
    struct IVGColor * _result = 0;
    HRESULT _hr = get_BackColor(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGColorPtr(_result, false);
}

#pragma implementation_key(4000)
inline void VGCore::IVGHatchFill::PutBackColor ( struct IVGColor * ppVal ) {
    HRESULT _hr = put_BackColor(ppVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(4001)
inline VARIANT_BOOL VGCore::IVGHatchFill::GetHasBackground ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_HasBackground(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4002)
inline VARIANT_BOOL VGCore::IVGHatchFill::GetTransformWithShape ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_TransformWithShape(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4003)
inline void VGCore::IVGHatchFill::PutTransformWithShape ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_TransformWithShape(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(4004)
inline VARIANT_BOOL VGCore::IVGHatchFill::GetScaleLinesWithShape ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_ScaleLinesWithShape(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4005)
inline void VGCore::IVGHatchFill::PutScaleLinesWithShape ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_ScaleLinesWithShape(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(4006)
inline VARIANT_BOOL VGCore::IVGHatchFill::GetUseWorldCoordinates ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_UseWorldCoordinates(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4007)
inline void VGCore::IVGHatchFill::PutUseWorldCoordinates ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_UseWorldCoordinates(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(4008)
inline _bstr_t VGCore::IVGHatchFill::GetLibraryName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_LibraryName(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(4009)
inline _bstr_t VGCore::IVGHatchFill::GetHatchName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_HatchName(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(4010)
inline VGCore::IVGHatchPatternsPtr VGCore::IVGHatchFill::GetPatterns ( ) {
    struct IVGHatchPatterns * _result = 0;
    HRESULT _hr = get_Patterns(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGHatchPatternsPtr(_result, false);
}

#pragma implementation_key(4011)
inline double VGCore::IVGHatchFill::GetFillScaleX ( ) {
    double _result = 0;
    HRESULT _hr = get_FillScaleX(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4012)
inline void VGCore::IVGHatchFill::PutFillScaleX ( double pVal ) {
    HRESULT _hr = put_FillScaleX(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(4013)
inline double VGCore::IVGHatchFill::GetFillScaleY ( ) {
    double _result = 0;
    HRESULT _hr = get_FillScaleY(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4014)
inline void VGCore::IVGHatchFill::PutFillScaleY ( double pVal ) {
    HRESULT _hr = put_FillScaleY(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(4015)
inline double VGCore::IVGHatchFill::GetRotationAngle ( ) {
    double _result = 0;
    HRESULT _hr = get_RotationAngle(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4016)
inline void VGCore::IVGHatchFill::PutRotationAngle ( double pVal ) {
    HRESULT _hr = put_RotationAngle(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(4017)
inline double VGCore::IVGHatchFill::GetSkewAngle ( ) {
    double _result = 0;
    HRESULT _hr = get_SkewAngle(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4018)
inline void VGCore::IVGHatchFill::PutSkewAngle ( double pVal ) {
    HRESULT _hr = put_SkewAngle(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(4019)
inline HRESULT VGCore::IVGHatchFill::SetNoBackColor ( ) {
    HRESULT _hr = raw_SetNoBackColor();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(4020)
inline HRESULT VGCore::IVGHatchFill::SetFillScale ( double FillScale ) {
    HRESULT _hr = raw_SetFillScale(FillScale);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(4021)
inline double VGCore::IVGHatchFill::GetFillScale ( ) {
    double _result = 0;
    HRESULT _hr = raw_GetFillScale(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4022)
inline HRESULT VGCore::IVGHatchFill::SetLineScale ( double LineScale ) {
    HRESULT _hr = raw_SetLineScale(LineScale);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(4023)
inline double VGCore::IVGHatchFill::GetLineScale ( ) {
    double _result = 0;
    HRESULT _hr = raw_GetLineScale(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4024)
inline VGCore::IVGHatchPatternPtr VGCore::IVGHatchFill::AddPattern ( double Angle, double Spacing, double Shift, double OriginX, double OriginY, double Width, struct IVGColor * Color, struct IVGOutlineStyle * Style, double DashDotLength, double PenWidth ) {
    struct IVGHatchPattern * _result = 0;
    HRESULT _hr = raw_AddPattern(Angle, Spacing, Shift, OriginX, OriginY, Width, Color, Style, DashDotLength, PenWidth, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGHatchPatternPtr(_result, false);
}

#pragma implementation_key(4025)
inline HRESULT VGCore::IVGHatchFill::AddToLibrary ( _bstr_t LibraryName, _bstr_t HatchName ) {
    HRESULT _hr = raw_AddToLibrary(LibraryName, HatchName);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(4026)
inline HRESULT VGCore::IVGHatchFill::Select ( _bstr_t LibraryName, const _variant_t & HatchNameOrIndex, struct IVGColor * BackColor, VARIANT_BOOL TransformWithShape, VARIANT_BOOL ScaleLinesWithShape, VARIANT_BOOL UseWorldCoordinates, double FillScale, double LineScale, double FillAngle, double FillSkew ) {
    HRESULT _hr = raw_Select(LibraryName, HatchNameOrIndex, BackColor, TransformWithShape, ScaleLinesWithShape, UseWorldCoordinates, FillScale, LineScale, FillAngle, FillSkew);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(4027)
inline VARIANT_BOOL VGCore::IVGHatchFill::GetIsFromLibrary ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsFromLibrary(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4028)
inline long VGCore::IVGHatchFill::GetIndex ( ) {
    long _result = 0;
    HRESULT _hr = get_Index(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4029)
inline VGCore::IVGHatchLibraryPtr VGCore::IVGHatchFill::GetLibrary ( ) {
    struct IVGHatchLibrary * _result = 0;
    HRESULT _hr = get_Library(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGHatchLibraryPtr(_result, false);
}

//
// interface IVGStructFontProperties wrapper method implementations
//

#pragma implementation_key(4030)
inline void VGCore::IVGStructFontProperties::PutName ( _bstr_t pVal ) {
    HRESULT _hr = put_Name(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(4031)
inline _bstr_t VGCore::IVGStructFontProperties::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(4032)
inline void VGCore::IVGStructFontProperties::PutStyle ( enum cdrFontStyle pVal ) {
    HRESULT _hr = put_Style(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(4033)
inline enum VGCore::cdrFontStyle VGCore::IVGStructFontProperties::GetStyle ( ) {
    enum cdrFontStyle _result;
    HRESULT _hr = get_Style(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4034)
inline void VGCore::IVGStructFontProperties::PutSize ( float pVal ) {
    HRESULT _hr = put_Size(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(4035)
inline float VGCore::IVGStructFontProperties::GetSize ( ) {
    float _result = 0;
    HRESULT _hr = get_Size(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4036)
inline void VGCore::IVGStructFontProperties::PutUnderline ( enum cdrFontLine pVal ) {
    HRESULT _hr = put_Underline(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(4037)
inline enum VGCore::cdrFontLine VGCore::IVGStructFontProperties::GetUnderline ( ) {
    enum cdrFontLine _result;
    HRESULT _hr = get_Underline(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4038)
inline void VGCore::IVGStructFontProperties::PutOverscore ( enum cdrFontLine pVal ) {
    HRESULT _hr = put_Overscore(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(4039)
inline enum VGCore::cdrFontLine VGCore::IVGStructFontProperties::GetOverscore ( ) {
    enum cdrFontLine _result;
    HRESULT _hr = get_Overscore(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4040)
inline void VGCore::IVGStructFontProperties::PutStrikethru ( enum cdrFontLine pVal ) {
    HRESULT _hr = put_Strikethru(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(4041)
inline enum VGCore::cdrFontLine VGCore::IVGStructFontProperties::GetStrikethru ( ) {
    enum cdrFontLine _result;
    HRESULT _hr = get_Strikethru(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4042)
inline void VGCore::IVGStructFontProperties::PutUppercase ( enum cdrFontCase pVal ) {
    HRESULT _hr = put_Uppercase(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(4043)
inline enum VGCore::cdrFontCase VGCore::IVGStructFontProperties::GetUppercase ( ) {
    enum cdrFontCase _result;
    HRESULT _hr = get_Uppercase(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4044)
inline void VGCore::IVGStructFontProperties::PutPosition ( enum cdrFontPosition pVal ) {
    HRESULT _hr = put_Position(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(4045)
inline enum VGCore::cdrFontPosition VGCore::IVGStructFontProperties::GetPosition ( ) {
    enum cdrFontPosition _result;
    HRESULT _hr = get_Position(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4046)
inline void VGCore::IVGStructFontProperties::PutRangeKerning ( long pVal ) {
    HRESULT _hr = put_RangeKerning(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(4047)
inline long VGCore::IVGStructFontProperties::GetRangeKerning ( ) {
    long _result = 0;
    HRESULT _hr = get_RangeKerning(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4048)
inline void VGCore::IVGStructFontProperties::PutFill ( struct IVGFill * ppVal ) {
    HRESULT _hr = put_Fill(ppVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(4049)
inline VGCore::IVGFillPtr VGCore::IVGStructFontProperties::GetFill ( ) {
    struct IVGFill * _result = 0;
    HRESULT _hr = get_Fill(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGFillPtr(_result, false);
}

#pragma implementation_key(4050)
inline void VGCore::IVGStructFontProperties::PutOutline ( struct IVGOutline * ppVal ) {
    HRESULT _hr = put_Outline(ppVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(4051)
inline VGCore::IVGOutlinePtr VGCore::IVGStructFontProperties::GetOutline ( ) {
    struct IVGOutline * _result = 0;
    HRESULT _hr = get_Outline(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGOutlinePtr(_result, false);
}

//
// interface IVGHatchLibraries wrapper method implementations
//

#pragma implementation_key(4052)
inline VGCore::IVGHatchLibraryPtr VGCore::IVGHatchLibraries::GetItem ( const _variant_t & IndexOrName ) {
    struct IVGHatchLibrary * _result = 0;
    HRESULT _hr = get_Item(IndexOrName, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGHatchLibraryPtr(_result, false);
}

#pragma implementation_key(4053)
inline long VGCore::IVGHatchLibraries::GetCount ( ) {
    long _result = 0;
    HRESULT _hr = get_Count(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4054)
inline VGCore::IVGHatchLibraryPtr VGCore::IVGHatchLibraries::Find ( _bstr_t Name ) {
    struct IVGHatchLibrary * _result = 0;
    HRESULT _hr = raw_Find(Name, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGHatchLibraryPtr(_result, false);
}

#pragma implementation_key(4055)
inline IUnknownPtr VGCore::IVGHatchLibraries::Get_NewEnum ( ) {
    IUnknown * _result = 0;
    HRESULT _hr = get__NewEnum(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IUnknownPtr(_result, false);
}

#pragma implementation_key(4056)
inline VGCore::IVGHatchLibraryPtr VGCore::IVGHatchLibraries::GetActiveLibrary ( ) {
    struct IVGHatchLibrary * _result = 0;
    HRESULT _hr = get_ActiveLibrary(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGHatchLibraryPtr(_result, false);
}

#pragma implementation_key(4057)
inline VGCore::IVGHatchLibraryPtr VGCore::IVGHatchLibraries::GetDefaultLibrary ( ) {
    struct IVGHatchLibrary * _result = 0;
    HRESULT _hr = get_DefaultLibrary(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGHatchLibraryPtr(_result, false);
}

//
// interface IVGText wrapper method implementations
//

#pragma implementation_key(4058)
inline enum VGCore::cdrTextType VGCore::IVGText::GetType ( ) {
    enum cdrTextType _result;
    HRESULT _hr = get_Type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4059)
inline long VGCore::IVGText::GetFramesInLink ( ) {
    long _result = 0;
    HRESULT _hr = get_FramesInLink(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4060)
inline long VGCore::IVGText::GetUnusedFramesInLink ( ) {
    long _result = 0;
    HRESULT _hr = get_UnusedFramesInLink(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4061)
inline VARIANT_BOOL VGCore::IVGText::GetOverflow ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_Overflow(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4062)
inline VGCore::IVGStructFontPropertiesPtr VGCore::IVGText::GetFontProperties ( enum cdrTextFrames Frames ) {
    struct IVGStructFontProperties * _result = 0;
    HRESULT _hr = get_FontProperties(Frames, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGStructFontPropertiesPtr(_result, false);
}

#pragma implementation_key(4063)
inline void VGCore::IVGText::PutFontProperties ( enum cdrTextFrames Frames, struct IVGStructFontProperties * ppVal ) {
    HRESULT _hr = put_FontProperties(Frames, ppVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(4064)
inline VGCore::IVGStructFontPropertiesPtr VGCore::IVGText::GetFontPropertiesInRange ( long StartIndex, long Count, enum cdrTextIndexingType IndexingType ) {
    struct IVGStructFontProperties * _result = 0;
    HRESULT _hr = get_FontPropertiesInRange(StartIndex, Count, IndexingType, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGStructFontPropertiesPtr(_result, false);
}

#pragma implementation_key(4065)
inline void VGCore::IVGText::PutFontPropertiesInRange ( long StartIndex, long Count, enum cdrTextIndexingType IndexingType, struct IVGStructFontProperties * ppVal ) {
    HRESULT _hr = put_FontPropertiesInRange(StartIndex, Count, IndexingType, ppVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(4066)
inline VGCore::IVGStructAlignPropertiesPtr VGCore::IVGText::GetAlignProperties ( enum cdrTextFrames Frames ) {
    struct IVGStructAlignProperties * _result = 0;
    HRESULT _hr = get_AlignProperties(Frames, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGStructAlignPropertiesPtr(_result, false);
}

#pragma implementation_key(4067)
inline void VGCore::IVGText::PutAlignProperties ( enum cdrTextFrames Frames, struct IVGStructAlignProperties * ppVal ) {
    HRESULT _hr = put_AlignProperties(Frames, ppVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(4068)
inline VGCore::IVGStructAlignPropertiesPtr VGCore::IVGText::GetAlignPropertiesInRange ( long StartIndex, long Count, enum cdrTextIndexingType IndexingType ) {
    struct IVGStructAlignProperties * _result = 0;
    HRESULT _hr = get_AlignPropertiesInRange(StartIndex, Count, IndexingType, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGStructAlignPropertiesPtr(_result, false);
}

#pragma implementation_key(4069)
inline void VGCore::IVGText::PutAlignPropertiesInRange ( long StartIndex, long Count, enum cdrTextIndexingType IndexingType, struct IVGStructAlignProperties * ppVal ) {
    HRESULT _hr = put_AlignPropertiesInRange(StartIndex, Count, IndexingType, ppVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(4070)
inline VGCore::IVGStructSpacePropertiesPtr VGCore::IVGText::GetSpaceProperties ( enum cdrTextFrames Frames ) {
    struct IVGStructSpaceProperties * _result = 0;
    HRESULT _hr = get_SpaceProperties(Frames, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGStructSpacePropertiesPtr(_result, false);
}

#pragma implementation_key(4071)
inline void VGCore::IVGText::PutSpaceProperties ( enum cdrTextFrames Frames, struct IVGStructSpaceProperties * ppVal ) {
    HRESULT _hr = put_SpaceProperties(Frames, ppVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(4072)
inline VGCore::IVGStructSpacePropertiesPtr VGCore::IVGText::GetSpacePropertiesInRange ( long StartIndex, long Count, enum cdrTextIndexingType IndexingType ) {
    struct IVGStructSpaceProperties * _result = 0;
    HRESULT _hr = get_SpacePropertiesInRange(StartIndex, Count, IndexingType, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGStructSpacePropertiesPtr(_result, false);
}

#pragma implementation_key(4073)
inline void VGCore::IVGText::PutSpacePropertiesInRange ( long StartIndex, long Count, enum cdrTextIndexingType IndexingType, struct IVGStructSpaceProperties * ppVal ) {
    HRESULT _hr = put_SpacePropertiesInRange(StartIndex, Count, IndexingType, ppVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(4074)
inline VGCore::IVGStructHyphenationSettingsPtr VGCore::IVGText::GetHyphenationSettings ( enum cdrTextFrames Frames ) {
    struct IVGStructHyphenationSettings * _result = 0;
    HRESULT _hr = get_HyphenationSettings(Frames, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGStructHyphenationSettingsPtr(_result, false);
}

#pragma implementation_key(4075)
inline void VGCore::IVGText::PutHyphenationSettings ( enum cdrTextFrames Frames, struct IVGStructHyphenationSettings * ppVal ) {
    HRESULT _hr = put_HyphenationSettings(Frames, ppVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(4076)
inline VGCore::IVGStructHyphenationSettingsPtr VGCore::IVGText::GetHyphenationSettingsInRange ( long StartIndex, long Count, enum cdrTextIndexingType IndexingType ) {
    struct IVGStructHyphenationSettings * _result = 0;
    HRESULT _hr = get_HyphenationSettingsInRange(StartIndex, Count, IndexingType, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGStructHyphenationSettingsPtr(_result, false);
}

#pragma implementation_key(4077)
inline void VGCore::IVGText::PutHyphenationSettingsInRange ( long StartIndex, long Count, enum cdrTextIndexingType IndexingType, struct IVGStructHyphenationSettings * ppVal ) {
    HRESULT _hr = put_HyphenationSettingsInRange(StartIndex, Count, IndexingType, ppVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(4078)
inline _bstr_t VGCore::IVGText::GetContents ( enum cdrTextFrames Frames ) {
    BSTR _result = 0;
    HRESULT _hr = get_Contents(Frames, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(4079)
inline void VGCore::IVGText::PutContents ( enum cdrTextFrames Frames, _bstr_t pVal ) {
    HRESULT _hr = put_Contents(Frames, pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(4080)
inline VGCore::IVGEffectPtr VGCore::IVGText::FitToPath ( struct IVGShape * Path ) {
    struct IVGEffect * _result = 0;
    HRESULT _hr = raw_FitToPath(Path, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGEffectPtr(_result, false);
}

#pragma implementation_key(4081)
inline long VGCore::IVGText::Find ( _bstr_t Text, VARIANT_BOOL CaseSensitive, long StartIndex, VARIANT_BOOL WrapAround, enum cdrTextIndexingType IndexingType ) {
    long _result = 0;
    HRESULT _hr = raw_Find(Text, CaseSensitive, StartIndex, WrapAround, IndexingType, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4082)
inline HRESULT VGCore::IVGText::Replace ( _bstr_t OldText, _bstr_t NewText, VARIANT_BOOL CaseSensitive, long StartIndex, VARIANT_BOOL ReplaceAll, VARIANT_BOOL WrapAround, enum cdrTextIndexingType IndexingType ) {
    HRESULT _hr = raw_Replace(OldText, NewText, CaseSensitive, StartIndex, ReplaceAll, WrapAround, IndexingType);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(4083)
inline HRESULT VGCore::IVGText::ImportFromFile ( _bstr_t FileName, long StartIndex, enum cdrTextIndexingType IndexingType ) {
    HRESULT _hr = raw_ImportFromFile(FileName, StartIndex, IndexingType);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(4084)
inline HRESULT VGCore::IVGText::ExportToFile ( _bstr_t FileName, long StartIndex, long Count, enum cdrTextIndexingType IndexingType ) {
    HRESULT _hr = raw_ExportToFile(FileName, StartIndex, Count, IndexingType);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(4085)
inline HRESULT VGCore::IVGText::ConvertToArtistic ( ) {
    HRESULT _hr = raw_ConvertToArtistic();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(4086)
inline HRESULT VGCore::IVGText::ConvertToParagraph ( ) {
    HRESULT _hr = raw_ConvertToParagraph();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(4087)
inline VARIANT_BOOL VGCore::IVGText::GetIsHTMLCompatible ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsHTMLCompatible(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4088)
inline VARIANT_BOOL VGCore::IVGText::MakeHTMLCompatible ( VARIANT_BOOL HTML ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_MakeHTMLCompatible(HTML, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4089)
inline VGCore::IVGTextRangePtr VGCore::IVGText::GetStory ( ) {
    struct IVGTextRange * _result = 0;
    HRESULT _hr = get_Story(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGTextRangePtr(_result, false);
}

#pragma implementation_key(4090)
inline VGCore::IVGTextRangePtr VGCore::IVGText::GetSelection ( ) {
    struct IVGTextRange * _result = 0;
    HRESULT _hr = get_Selection(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGTextRangePtr(_result, false);
}

#pragma implementation_key(4091)
inline VGCore::IVGTextRangePtr VGCore::IVGText::Range ( long Start, long End ) {
    struct IVGTextRange * _result = 0;
    HRESULT _hr = raw_Range(Start, End, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGTextRangePtr(_result, false);
}

#pragma implementation_key(4092)
inline VARIANT_BOOL VGCore::IVGText::GetIsEditing ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsEditing(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4093)
inline HRESULT VGCore::IVGText::BeginEdit ( ) {
    HRESULT _hr = raw_BeginEdit();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(4094)
inline VGCore::IVGTextFramePtr VGCore::IVGText::GetFrame ( ) {
    struct IVGTextFrame * _result = 0;
    HRESULT _hr = get_Frame(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGTextFramePtr(_result, false);
}

#pragma implementation_key(4095)
inline VGCore::IVGTextFramesPtr VGCore::IVGText::GetFrames ( ) {
    struct IVGTextFrames * _result = 0;
    HRESULT _hr = get_Frames(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGTextFramesPtr(_result, false);
}

#pragma implementation_key(4096)
inline VARIANT_BOOL VGCore::IVGText::GetIsArtisticText ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsArtisticText(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4097)
inline HRESULT VGCore::IVGText::FitTextToFrame ( ) {
    HRESULT _hr = raw_FitTextToFrame();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface IVGEffect wrapper method implementations
//

#pragma implementation_key(4098)
inline VGCore::IVGApplicationPtr VGCore::IVGEffect::GetApplication ( ) {
    struct IVGApplication * _result = 0;
    HRESULT _hr = get_Application(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGApplicationPtr(_result, false);
}

#pragma implementation_key(4099)
inline VGCore::IVGEffectsPtr VGCore::IVGEffect::GetParent ( ) {
    struct IVGEffects * _result = 0;
    HRESULT _hr = get_Parent(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGEffectsPtr(_result, false);
}

#pragma implementation_key(4100)
inline enum VGCore::cdrEffectType VGCore::IVGEffect::GetType ( ) {
    enum cdrEffectType _result;
    HRESULT _hr = get_Type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4101)
inline VGCore::IVGEffectBlendPtr VGCore::IVGEffect::GetBlend ( ) {
    struct IVGEffectBlend * _result = 0;
    HRESULT _hr = get_Blend(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGEffectBlendPtr(_result, false);
}

#pragma implementation_key(4102)
inline VGCore::IVGEffectControlPathPtr VGCore::IVGEffect::GetControlPath ( ) {
    struct IVGEffectControlPath * _result = 0;
    HRESULT _hr = get_ControlPath(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGEffectControlPathPtr(_result, false);
}

#pragma implementation_key(4103)
inline VGCore::IVGEffectExtrudePtr VGCore::IVGEffect::GetExtrude ( ) {
    struct IVGEffectExtrude * _result = 0;
    HRESULT _hr = get_Extrude(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGEffectExtrudePtr(_result, false);
}

#pragma implementation_key(4104)
inline VGCore::IVGEffectEnvelopePtr VGCore::IVGEffect::GetEnvelope ( ) {
    struct IVGEffectEnvelope * _result = 0;
    HRESULT _hr = get_Envelope(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGEffectEnvelopePtr(_result, false);
}

#pragma implementation_key(4105)
inline VGCore::IVGEffectTextOnPathPtr VGCore::IVGEffect::GetTextOnPath ( ) {
    struct IVGEffectTextOnPath * _result = 0;
    HRESULT _hr = get_TextOnPath(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGEffectTextOnPathPtr(_result, false);
}

#pragma implementation_key(4106)
inline VGCore::IVGEffectDropShadowPtr VGCore::IVGEffect::GetDropShadow ( ) {
    struct IVGEffectDropShadow * _result = 0;
    HRESULT _hr = get_DropShadow(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGEffectDropShadowPtr(_result, false);
}

#pragma implementation_key(4107)
inline VGCore::IVGEffectContourPtr VGCore::IVGEffect::GetContour ( ) {
    struct IVGEffectContour * _result = 0;
    HRESULT _hr = get_Contour(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGEffectContourPtr(_result, false);
}

#pragma implementation_key(4108)
inline VGCore::IVGEffectDistortionPtr VGCore::IVGEffect::GetDistortion ( ) {
    struct IVGEffectDistortion * _result = 0;
    HRESULT _hr = get_Distortion(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGEffectDistortionPtr(_result, false);
}

#pragma implementation_key(4109)
inline VGCore::IVGEffectLensPtr VGCore::IVGEffect::GetLens ( ) {
    struct IVGEffectLens * _result = 0;
    HRESULT _hr = get_Lens(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGEffectLensPtr(_result, false);
}

#pragma implementation_key(4110)
inline VGCore::IVGEffectPerspectivePtr VGCore::IVGEffect::GetPerspective ( ) {
    struct IVGEffectPerspective * _result = 0;
    HRESULT _hr = get_Perspective(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGEffectPerspectivePtr(_result, false);
}

#pragma implementation_key(4111)
inline VGCore::IVGEffectsPtr VGCore::IVGEffect::GetClones ( ) {
    struct IVGEffects * _result = 0;
    HRESULT _hr = get_Clones(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGEffectsPtr(_result, false);
}

#pragma implementation_key(4112)
inline VGCore::IVGEffectPtr VGCore::IVGEffect::GetCloneParent ( ) {
    struct IVGEffect * _result = 0;
    HRESULT _hr = get_CloneParent(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGEffectPtr(_result, false);
}

#pragma implementation_key(4113)
inline HRESULT VGCore::IVGEffect::Clear ( ) {
    HRESULT _hr = raw_Clear();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(4114)
inline VGCore::IVGShapeRangePtr VGCore::IVGEffect::Separate ( ) {
    struct IVGShapeRange * _result = 0;
    HRESULT _hr = raw_Separate(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGShapeRangePtr(_result, false);
}

#pragma implementation_key(4115)
inline VGCore::IVGCustomEffectPtr VGCore::IVGEffect::GetCustom ( ) {
    struct IVGCustomEffect * _result = 0;
    HRESULT _hr = get_Custom(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGCustomEffectPtr(_result, false);
}

#pragma implementation_key(4116)
inline VGCore::IVGEffectInnerShadowPtr VGCore::IVGEffect::GetInnerShadow ( ) {
    struct IVGEffectInnerShadow * _result = 0;
    HRESULT _hr = get_InnerShadow(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGEffectInnerShadowPtr(_result, false);
}

//
// interface IVGEffects wrapper method implementations
//

#pragma implementation_key(4117)
inline VGCore::IVGApplicationPtr VGCore::IVGEffects::GetApplication ( ) {
    struct IVGApplication * _result = 0;
    HRESULT _hr = get_Application(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGApplicationPtr(_result, false);
}

#pragma implementation_key(4118)
inline VGCore::IVGShapePtr VGCore::IVGEffects::GetParent ( ) {
    struct IVGShape * _result = 0;
    HRESULT _hr = get_Parent(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGShapePtr(_result, false);
}

#pragma implementation_key(4119)
inline VGCore::IVGEffectPtr VGCore::IVGEffects::GetItem ( long Index ) {
    struct IVGEffect * _result = 0;
    HRESULT _hr = get_Item(Index, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGEffectPtr(_result, false);
}

#pragma implementation_key(4120)
inline IUnknownPtr VGCore::IVGEffects::Get_NewEnum ( ) {
    IUnknown * _result = 0;
    HRESULT _hr = get__NewEnum(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IUnknownPtr(_result, false);
}

#pragma implementation_key(4121)
inline long VGCore::IVGEffects::GetCount ( ) {
    long _result = 0;
    HRESULT _hr = get_Count(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4122)
inline VGCore::IVGEffectsPtr VGCore::IVGEffects::GetBlendEffects ( ) {
    struct IVGEffects * _result = 0;
    HRESULT _hr = get_BlendEffects(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGEffectsPtr(_result, false);
}

#pragma implementation_key(4123)
inline VGCore::IVGEffectsPtr VGCore::IVGEffects::GetCustomEffects ( ) {
    struct IVGEffects * _result = 0;
    HRESULT _hr = get_CustomEffects(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGEffectsPtr(_result, false);
}

#pragma implementation_key(4124)
inline VGCore::IVGEffectsPtr VGCore::IVGEffects::GetDistortionEffects ( ) {
    struct IVGEffects * _result = 0;
    HRESULT _hr = get_DistortionEffects(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGEffectsPtr(_result, false);
}

#pragma implementation_key(4125)
inline VGCore::IVGEffectsPtr VGCore::IVGEffects::GetEnvelopeEffects ( ) {
    struct IVGEffects * _result = 0;
    HRESULT _hr = get_EnvelopeEffects(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGEffectsPtr(_result, false);
}

#pragma implementation_key(4126)
inline VGCore::IVGEffectsPtr VGCore::IVGEffects::GetPerspectiveEffects ( ) {
    struct IVGEffects * _result = 0;
    HRESULT _hr = get_PerspectiveEffects(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGEffectsPtr(_result, false);
}

#pragma implementation_key(4127)
inline VGCore::IVGEffectPtr VGCore::IVGEffects::GetContourEffect ( ) {
    struct IVGEffect * _result = 0;
    HRESULT _hr = get_ContourEffect(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGEffectPtr(_result, false);
}

#pragma implementation_key(4128)
inline VGCore::IVGEffectPtr VGCore::IVGEffects::GetControlPathEffect ( ) {
    struct IVGEffect * _result = 0;
    HRESULT _hr = get_ControlPathEffect(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGEffectPtr(_result, false);
}

#pragma implementation_key(4129)
inline VGCore::IVGEffectPtr VGCore::IVGEffects::GetDropShadowEffect ( ) {
    struct IVGEffect * _result = 0;
    HRESULT _hr = get_DropShadowEffect(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGEffectPtr(_result, false);
}

#pragma implementation_key(4130)
inline VGCore::IVGEffectPtr VGCore::IVGEffects::GetExtrudeEffect ( ) {
    struct IVGEffect * _result = 0;
    HRESULT _hr = get_ExtrudeEffect(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGEffectPtr(_result, false);
}

#pragma implementation_key(4131)
inline VGCore::IVGEffectPtr VGCore::IVGEffects::GetLensEffect ( ) {
    struct IVGEffect * _result = 0;
    HRESULT _hr = get_LensEffect(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGEffectPtr(_result, false);
}

#pragma implementation_key(4132)
inline VGCore::IVGEffectPtr VGCore::IVGEffects::GetTextOnPathEffect ( ) {
    struct IVGEffect * _result = 0;
    HRESULT _hr = get_TextOnPathEffect(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGEffectPtr(_result, false);
}

#pragma implementation_key(4133)
inline VGCore::IVGEffectPtr VGCore::IVGEffects::GetInnerShadowEffect ( ) {
    struct IVGEffect * _result = 0;
    HRESULT _hr = get_InnerShadowEffect(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGEffectPtr(_result, false);
}

//
// interface IVGEffectBlend wrapper method implementations
//

#pragma implementation_key(4134)
inline VGCore::IVGApplicationPtr VGCore::IVGEffectBlend::GetApplication ( ) {
    struct IVGApplication * _result = 0;
    HRESULT _hr = get_Application(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGApplicationPtr(_result, false);
}

#pragma implementation_key(4135)
inline VGCore::IVGEffectPtr VGCore::IVGEffectBlend::GetParent ( ) {
    struct IVGEffect * _result = 0;
    HRESULT _hr = get_Parent(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGEffectPtr(_result, false);
}

#pragma implementation_key(4136)
inline VGCore::IVGShapePtr VGCore::IVGEffectBlend::GetStartShape ( ) {
    struct IVGShape * _result = 0;
    HRESULT _hr = get_StartShape(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGShapePtr(_result, false);
}

#pragma implementation_key(4137)
inline void VGCore::IVGEffectBlend::PutStartShape ( struct IVGShape * ppVal ) {
    HRESULT _hr = put_StartShape(ppVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(4138)
inline VGCore::IVGShapePtr VGCore::IVGEffectBlend::GetEndShape ( ) {
    struct IVGShape * _result = 0;
    HRESULT _hr = get_EndShape(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGShapePtr(_result, false);
}

#pragma implementation_key(4139)
inline void VGCore::IVGEffectBlend::PutEndShape ( struct IVGShape * ppVal ) {
    HRESULT _hr = put_EndShape(ppVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(4140)
inline VGCore::IVGShapePtr VGCore::IVGEffectBlend::GetBlendGroup ( ) {
    struct IVGShape * _result = 0;
    HRESULT _hr = get_BlendGroup(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGShapePtr(_result, false);
}

#pragma implementation_key(4141)
inline VGCore::IVGShapePtr VGCore::IVGEffectBlend::GetPath ( ) {
    struct IVGShape * _result = 0;
    HRESULT _hr = get_Path(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGShapePtr(_result, false);
}

#pragma implementation_key(4142)
inline void VGCore::IVGEffectBlend::PutPath ( struct IVGShape * ppVal ) {
    HRESULT _hr = put_Path(ppVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(4143)
inline double VGCore::IVGEffectBlend::GetStartShapeOffset ( ) {
    double _result = 0;
    HRESULT _hr = get_StartShapeOffset(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4144)
inline void VGCore::IVGEffectBlend::PutStartShapeOffset ( double pVal ) {
    HRESULT _hr = put_StartShapeOffset(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(4145)
inline double VGCore::IVGEffectBlend::GetEndShapeOffset ( ) {
    double _result = 0;
    HRESULT _hr = get_EndShapeOffset(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4146)
inline void VGCore::IVGEffectBlend::PutEndShapeOffset ( double pVal ) {
    HRESULT _hr = put_EndShapeOffset(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(4147)
inline enum VGCore::cdrBlendMode VGCore::IVGEffectBlend::GetMode ( ) {
    enum cdrBlendMode _result;
    HRESULT _hr = get_Mode(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4148)
inline void VGCore::IVGEffectBlend::PutMode ( enum cdrBlendMode pVal ) {
    HRESULT _hr = put_Mode(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(4149)
inline long VGCore::IVGEffectBlend::GetSteps ( ) {
    long _result = 0;
    HRESULT _hr = get_Steps(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4150)
inline void VGCore::IVGEffectBlend::PutSteps ( long pVal ) {
    HRESULT _hr = put_Steps(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(4151)
inline double VGCore::IVGEffectBlend::GetSpacing ( ) {
    double _result = 0;
    HRESULT _hr = get_Spacing(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4152)
inline void VGCore::IVGEffectBlend::PutSpacing ( double pVal ) {
    HRESULT _hr = put_Spacing(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(4153)
inline double VGCore::IVGEffectBlend::GetAngle ( ) {
    double _result = 0;
    HRESULT _hr = get_Angle(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4154)
inline void VGCore::IVGEffectBlend::PutAngle ( double pVal ) {
    HRESULT _hr = put_Angle(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(4155)
inline VARIANT_BOOL VGCore::IVGEffectBlend::GetLoop ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_Loop(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4156)
inline void VGCore::IVGEffectBlend::PutLoop ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_Loop(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(4157)
inline VARIANT_BOOL VGCore::IVGEffectBlend::GetFullPath ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_FullPath(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4158)
inline void VGCore::IVGEffectBlend::PutFullPath ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_FullPath(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(4159)
inline VARIANT_BOOL VGCore::IVGEffectBlend::GetRotateShapes ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_RotateShapes(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4160)
inline void VGCore::IVGEffectBlend::PutRotateShapes ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_RotateShapes(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(4161)
inline enum VGCore::cdrFountainFillBlendType VGCore::IVGEffectBlend::GetColorBlendType ( ) {
    enum cdrFountainFillBlendType _result;
    HRESULT _hr = get_ColorBlendType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4162)
inline void VGCore::IVGEffectBlend::PutColorBlendType ( enum cdrFountainFillBlendType pVal ) {
    HRESULT _hr = put_ColorBlendType(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(4163)
inline long VGCore::IVGEffectBlend::GetSpacingAcceleration ( ) {
    long _result = 0;
    HRESULT _hr = get_SpacingAcceleration(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4164)
inline void VGCore::IVGEffectBlend::PutSpacingAcceleration ( long pVal ) {
    HRESULT _hr = put_SpacingAcceleration(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(4165)
inline long VGCore::IVGEffectBlend::GetColorAcceleration ( ) {
    long _result = 0;
    HRESULT _hr = get_ColorAcceleration(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4166)
inline void VGCore::IVGEffectBlend::PutColorAcceleration ( long pVal ) {
    HRESULT _hr = put_ColorAcceleration(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(4167)
inline VARIANT_BOOL VGCore::IVGEffectBlend::GetLinkAcceleration ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_LinkAcceleration(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4168)
inline void VGCore::IVGEffectBlend::PutLinkAcceleration ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_LinkAcceleration(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(4169)
inline VARIANT_BOOL VGCore::IVGEffectBlend::GetAccelerateSize ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_AccelerateSize(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4170)
inline void VGCore::IVGEffectBlend::PutAccelerateSize ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_AccelerateSize(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(4171)
inline VARIANT_BOOL VGCore::IVGEffectBlend::GetMapNodes ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_MapNodes(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4172)
inline void VGCore::IVGEffectBlend::PutMapNodes ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_MapNodes(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(4173)
inline VGCore::IVGSnapPointPtr VGCore::IVGEffectBlend::GetStartPoint ( ) {
    struct IVGSnapPoint * _result = 0;
    HRESULT _hr = get_StartPoint(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGSnapPointPtr(_result, false);
}

#pragma implementation_key(4174)
inline void VGCore::IVGEffectBlend::PutStartPoint ( struct IVGSnapPoint * ppVal ) {
    HRESULT _hr = put_StartPoint(ppVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(4175)
inline VGCore::IVGSnapPointPtr VGCore::IVGEffectBlend::GetEndPoint ( ) {
    struct IVGSnapPoint * _result = 0;
    HRESULT _hr = get_EndPoint(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGSnapPointPtr(_result, false);
}

#pragma implementation_key(4176)
inline void VGCore::IVGEffectBlend::PutEndPoint ( struct IVGSnapPoint * ppVal ) {
    HRESULT _hr = put_EndPoint(ppVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(4177)
inline VGCore::IVGShapePtr VGCore::IVGEffectBlend::Split ( long StepNo ) {
    struct IVGShape * _result = 0;
    HRESULT _hr = raw_Split(StepNo, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGShapePtr(_result, false);
}

#pragma implementation_key(4178)
inline VARIANT_BOOL VGCore::IVGEffectBlend::FuseStart ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_FuseStart(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4179)
inline VARIANT_BOOL VGCore::IVGEffectBlend::FuseEnd ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_FuseEnd(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4180)
inline VARIANT_BOOL VGCore::IVGEffectBlend::CopyFrom ( struct IVGEffectBlend * Source ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_CopyFrom(Source, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface IVGEffectControlPath wrapper method implementations
//

#pragma implementation_key(4181)
inline VGCore::IVGApplicationPtr VGCore::IVGEffectControlPath::GetApplication ( ) {
    struct IVGApplication * _result = 0;
    HRESULT _hr = get_Application(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGApplicationPtr(_result, false);
}

#pragma implementation_key(4182)
inline VGCore::IVGEffectPtr VGCore::IVGEffectControlPath::GetParent ( ) {
    struct IVGEffect * _result = 0;
    HRESULT _hr = get_Parent(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGEffectPtr(_result, false);
}

#pragma implementation_key(4183)
inline VGCore::IVGEffectsPtr VGCore::IVGEffectControlPath::GetEffects ( ) {
    struct IVGEffects * _result = 0;
    HRESULT _hr = get_Effects(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGEffectsPtr(_result, false);
}

//
// interface IVGEffectEnvelope wrapper method implementations
//

#pragma implementation_key(4184)
inline VGCore::IVGApplicationPtr VGCore::IVGEffectEnvelope::GetApplication ( ) {
    struct IVGApplication * _result = 0;
    HRESULT _hr = get_Application(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGApplicationPtr(_result, false);
}

#pragma implementation_key(4185)
inline VGCore::IVGEffectPtr VGCore::IVGEffectEnvelope::GetParent ( ) {
    struct IVGEffect * _result = 0;
    HRESULT _hr = get_Parent(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGEffectPtr(_result, false);
}

#pragma implementation_key(4186)
inline VGCore::IVGCurvePtr VGCore::IVGEffectEnvelope::GetContainer ( ) {
    struct IVGCurve * _result = 0;
    HRESULT _hr = get_Container(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGCurvePtr(_result, false);
}

#pragma implementation_key(4187)
inline void VGCore::IVGEffectEnvelope::PutContainer ( struct IVGCurve * pVal ) {
    HRESULT _hr = put_Container(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(4188)
inline enum VGCore::cdrEnvelopeMode VGCore::IVGEffectEnvelope::GetMode ( ) {
    enum cdrEnvelopeMode _result;
    HRESULT _hr = get_Mode(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4189)
inline void VGCore::IVGEffectEnvelope::PutMode ( enum cdrEnvelopeMode pVal ) {
    HRESULT _hr = put_Mode(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(4190)
inline VARIANT_BOOL VGCore::IVGEffectEnvelope::GetKeepLines ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_KeepLines(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4191)
inline void VGCore::IVGEffectEnvelope::PutKeepLines ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_KeepLines(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(4192)
inline HRESULT VGCore::IVGEffectEnvelope::Select ( long PresetIndex ) {
    HRESULT _hr = raw_Select(PresetIndex);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(4193)
inline HRESULT VGCore::IVGEffectEnvelope::CopyFrom ( struct IVGEffectEnvelope * Source ) {
    HRESULT _hr = raw_CopyFrom(Source);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(4194)
inline VARIANT_BOOL VGCore::IVGEffectEnvelope::CreateFrom ( struct IVGShape * Shape ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_CreateFrom(Shape, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4195)
inline VARIANT_BOOL VGCore::IVGEffectEnvelope::CopyFromShape ( struct IVGShape * Source, enum cdrEnvelopeMode Mode, VARIANT_BOOL KeepLines, enum cdrEnvelopeCopyMode CopyMode, const _variant_t & CornerIndices ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_CopyFromShape(Source, Mode, KeepLines, CopyMode, CornerIndices, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4196)
inline VARIANT_BOOL VGCore::IVGEffectEnvelope::CopyFromCurve ( struct IVGCurve * Source, enum cdrEnvelopeMode Mode, VARIANT_BOOL KeepLines, enum cdrEnvelopeCopyMode CopyMode, const _variant_t & CornerIndices ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_CopyFromCurve(Source, Mode, KeepLines, CopyMode, CornerIndices, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4197)
inline _variant_t VGCore::IVGEffectEnvelope::GetCornerIndices ( ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = get_CornerIndices(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

#pragma implementation_key(4198)
inline void VGCore::IVGEffectEnvelope::PutCornerIndices ( const _variant_t & pVal ) {
    HRESULT _hr = put_CornerIndices(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IVGEffectTextOnPath wrapper method implementations
//

#pragma implementation_key(4199)
inline VGCore::IVGApplicationPtr VGCore::IVGEffectTextOnPath::GetApplication ( ) {
    struct IVGApplication * _result = 0;
    HRESULT _hr = get_Application(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGApplicationPtr(_result, false);
}

#pragma implementation_key(4200)
inline VGCore::IVGEffectPtr VGCore::IVGEffectTextOnPath::GetParent ( ) {
    struct IVGEffect * _result = 0;
    HRESULT _hr = get_Parent(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGEffectPtr(_result, false);
}

#pragma implementation_key(4201)
inline VGCore::IVGShapePtr VGCore::IVGEffectTextOnPath::GetText ( ) {
    struct IVGShape * _result = 0;
    HRESULT _hr = get_Text(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGShapePtr(_result, false);
}

#pragma implementation_key(4202)
inline void VGCore::IVGEffectTextOnPath::PutText ( struct IVGShape * ppVal ) {
    HRESULT _hr = put_Text(ppVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(4203)
inline VGCore::IVGShapePtr VGCore::IVGEffectTextOnPath::GetPath ( ) {
    struct IVGShape * _result = 0;
    HRESULT _hr = get_Path(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGShapePtr(_result, false);
}

#pragma implementation_key(4204)
inline void VGCore::IVGEffectTextOnPath::PutPath ( struct IVGShape * ppVal ) {
    HRESULT _hr = put_Path(ppVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(4205)
inline double VGCore::IVGEffectTextOnPath::GetDistanceFromPath ( ) {
    double _result = 0;
    HRESULT _hr = get_DistanceFromPath(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4206)
inline void VGCore::IVGEffectTextOnPath::PutDistanceFromPath ( double pVal ) {
    HRESULT _hr = put_DistanceFromPath(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(4207)
inline double VGCore::IVGEffectTextOnPath::GetOffset ( ) {
    double _result = 0;
    HRESULT _hr = get_Offset(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4208)
inline void VGCore::IVGEffectTextOnPath::PutOffset ( double pVal ) {
    HRESULT _hr = put_Offset(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(4209)
inline enum VGCore::cdrFittedOrientation VGCore::IVGEffectTextOnPath::GetOrientation ( ) {
    enum cdrFittedOrientation _result;
    HRESULT _hr = get_Orientation(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4210)
inline void VGCore::IVGEffectTextOnPath::PutOrientation ( enum cdrFittedOrientation pVal ) {
    HRESULT _hr = put_Orientation(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(4211)
inline enum VGCore::cdrFittedPlacement VGCore::IVGEffectTextOnPath::GetPlacement ( ) {
    enum cdrFittedPlacement _result;
    HRESULT _hr = get_Placement(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4212)
inline void VGCore::IVGEffectTextOnPath::PutPlacement ( enum cdrFittedPlacement pVal ) {
    HRESULT _hr = put_Placement(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(4213)
inline VARIANT_BOOL VGCore::IVGEffectTextOnPath::GetPlaceOnOtherSide ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_PlaceOnOtherSide(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4214)
inline void VGCore::IVGEffectTextOnPath::PutPlaceOnOtherSide ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_PlaceOnOtherSide(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(4215)
inline enum VGCore::cdrFittedQuadrant VGCore::IVGEffectTextOnPath::GetQuadrant ( ) {
    enum cdrFittedQuadrant _result;
    HRESULT _hr = get_Quadrant(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4216)
inline void VGCore::IVGEffectTextOnPath::PutQuadrant ( enum cdrFittedQuadrant pVal ) {
    HRESULT _hr = put_Quadrant(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(4217)
inline enum VGCore::cdrFittedVertPlacement VGCore::IVGEffectTextOnPath::GetVertPlacement ( ) {
    enum cdrFittedVertPlacement _result;
    HRESULT _hr = get_VertPlacement(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4218)
inline void VGCore::IVGEffectTextOnPath::PutVertPlacement ( enum cdrFittedVertPlacement pVal ) {
    HRESULT _hr = put_VertPlacement(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IVGEffectDropShadow wrapper method implementations
//

#pragma implementation_key(4219)
inline VGCore::IVGApplicationPtr VGCore::IVGEffectDropShadow::GetApplication ( ) {
    struct IVGApplication * _result = 0;
    HRESULT _hr = get_Application(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGApplicationPtr(_result, false);
}

#pragma implementation_key(4220)
inline VGCore::IVGEffectPtr VGCore::IVGEffectDropShadow::GetParent ( ) {
    struct IVGEffect * _result = 0;
    HRESULT _hr = get_Parent(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGEffectPtr(_result, false);
}

#pragma implementation_key(4221)
inline double VGCore::IVGEffectDropShadow::GetOffsetX ( ) {
    double _result = 0;
    HRESULT _hr = get_OffsetX(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4222)
inline void VGCore::IVGEffectDropShadow::PutOffsetX ( double pVal ) {
    HRESULT _hr = put_OffsetX(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(4223)
inline double VGCore::IVGEffectDropShadow::GetOffsetY ( ) {
    double _result = 0;
    HRESULT _hr = get_OffsetY(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4224)
inline void VGCore::IVGEffectDropShadow::PutOffsetY ( double pVal ) {
    HRESULT _hr = put_OffsetY(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(4225)
inline long VGCore::IVGEffectDropShadow::GetOpacity ( ) {
    long _result = 0;
    HRESULT _hr = get_Opacity(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4226)
inline void VGCore::IVGEffectDropShadow::PutOpacity ( long pVal ) {
    HRESULT _hr = put_Opacity(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(4227)
inline long VGCore::IVGEffectDropShadow::GetFeather ( ) {
    long _result = 0;
    HRESULT _hr = get_Feather(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4228)
inline void VGCore::IVGEffectDropShadow::PutFeather ( long pVal ) {
    HRESULT _hr = put_Feather(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(4229)
inline enum VGCore::cdrFeatherType VGCore::IVGEffectDropShadow::GetFeatherType ( ) {
    enum cdrFeatherType _result;
    HRESULT _hr = get_FeatherType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4230)
inline void VGCore::IVGEffectDropShadow::PutFeatherType ( enum cdrFeatherType pVal ) {
    HRESULT _hr = put_FeatherType(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(4231)
inline enum VGCore::cdrEdgeType VGCore::IVGEffectDropShadow::GetFeatherEdge ( ) {
    enum cdrEdgeType _result;
    HRESULT _hr = get_FeatherEdge(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4232)
inline void VGCore::IVGEffectDropShadow::PutFeatherEdge ( enum cdrEdgeType pVal ) {
    HRESULT _hr = put_FeatherEdge(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(4233)
inline enum VGCore::cdrDropShadowType VGCore::IVGEffectDropShadow::GetType ( ) {
    enum cdrDropShadowType _result;
    HRESULT _hr = get_Type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4234)
inline void VGCore::IVGEffectDropShadow::PutType ( enum cdrDropShadowType pVal ) {
    HRESULT _hr = put_Type(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(4235)
inline double VGCore::IVGEffectDropShadow::GetPerspectiveAngle ( ) {
    double _result = 0;
    HRESULT _hr = get_PerspectiveAngle(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4236)
inline void VGCore::IVGEffectDropShadow::PutPerspectiveAngle ( double pVal ) {
    HRESULT _hr = put_PerspectiveAngle(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(4237)
inline double VGCore::IVGEffectDropShadow::GetPerspectiveStretch ( ) {
    double _result = 0;
    HRESULT _hr = get_PerspectiveStretch(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4238)
inline void VGCore::IVGEffectDropShadow::PutPerspectiveStretch ( double pVal ) {
    HRESULT _hr = put_PerspectiveStretch(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(4239)
inline long VGCore::IVGEffectDropShadow::GetFade ( ) {
    long _result = 0;
    HRESULT _hr = get_Fade(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4240)
inline void VGCore::IVGEffectDropShadow::PutFade ( long pVal ) {
    HRESULT _hr = put_Fade(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(4241)
inline VGCore::IVGColorPtr VGCore::IVGEffectDropShadow::GetColor ( ) {
    struct IVGColor * _result = 0;
    HRESULT _hr = get_Color(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGColorPtr(_result, false);
}

#pragma implementation_key(4242)
inline void VGCore::IVGEffectDropShadow::PutColor ( struct IVGColor * ppVal ) {
    HRESULT _hr = put_Color(ppVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(4243)
inline HRESULT VGCore::IVGEffectDropShadow::SetOffset ( double OffsetX, double OffsetY ) {
    HRESULT _hr = raw_SetOffset(OffsetX, OffsetY);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(4244)
inline VGCore::IVGShapePtr VGCore::IVGEffectDropShadow::GetShadowGroup ( ) {
    struct IVGShape * _result = 0;
    HRESULT _hr = get_ShadowGroup(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGShapePtr(_result, false);
}

#pragma implementation_key(4245)
inline enum VGCore::cdrMergeMode VGCore::IVGEffectDropShadow::GetMergeMode ( ) {
    enum cdrMergeMode _result;
    HRESULT _hr = get_MergeMode(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4246)
inline void VGCore::IVGEffectDropShadow::PutMergeMode ( enum cdrMergeMode pVal ) {
    HRESULT _hr = put_MergeMode(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IVGEffectContour wrapper method implementations
//

#pragma implementation_key(4247)
inline VGCore::IVGApplicationPtr VGCore::IVGEffectContour::GetApplication ( ) {
    struct IVGApplication * _result = 0;
    HRESULT _hr = get_Application(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGApplicationPtr(_result, false);
}

#pragma implementation_key(4248)
inline VGCore::IVGEffectPtr VGCore::IVGEffectContour::GetParent ( ) {
    struct IVGEffect * _result = 0;
    HRESULT _hr = get_Parent(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGEffectPtr(_result, false);
}

#pragma implementation_key(4249)
inline enum VGCore::cdrContourDirection VGCore::IVGEffectContour::GetDirection ( ) {
    enum cdrContourDirection _result;
    HRESULT _hr = get_Direction(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4250)
inline void VGCore::IVGEffectContour::PutDirection ( enum cdrContourDirection pVal ) {
    HRESULT _hr = put_Direction(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(4251)
inline double VGCore::IVGEffectContour::GetOffset ( ) {
    double _result = 0;
    HRESULT _hr = get_Offset(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4252)
inline void VGCore::IVGEffectContour::PutOffset ( double pVal ) {
    HRESULT _hr = put_Offset(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(4253)
inline long VGCore::IVGEffectContour::GetSteps ( ) {
    long _result = 0;
    HRESULT _hr = get_Steps(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4254)
inline void VGCore::IVGEffectContour::PutSteps ( long pVal ) {
    HRESULT _hr = put_Steps(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(4255)
inline enum VGCore::cdrFountainFillBlendType VGCore::IVGEffectContour::GetColorBlendType ( ) {
    enum cdrFountainFillBlendType _result;
    HRESULT _hr = get_ColorBlendType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4256)
inline void VGCore::IVGEffectContour::PutColorBlendType ( enum cdrFountainFillBlendType pVal ) {
    HRESULT _hr = put_ColorBlendType(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(4257)
inline VGCore::IVGColorPtr VGCore::IVGEffectContour::GetOutlineColor ( ) {
    struct IVGColor * _result = 0;
    HRESULT _hr = get_OutlineColor(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGColorPtr(_result, false);
}

#pragma implementation_key(4258)
inline void VGCore::IVGEffectContour::PutOutlineColor ( struct IVGColor * ppVal ) {
    HRESULT _hr = put_OutlineColor(ppVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(4259)
inline VGCore::IVGColorPtr VGCore::IVGEffectContour::GetFillColor ( ) {
    struct IVGColor * _result = 0;
    HRESULT _hr = get_FillColor(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGColorPtr(_result, false);
}

#pragma implementation_key(4260)
inline void VGCore::IVGEffectContour::PutFillColor ( struct IVGColor * ppVal ) {
    HRESULT _hr = put_FillColor(ppVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(4261)
inline VGCore::IVGColorPtr VGCore::IVGEffectContour::GetFillColorTo ( ) {
    struct IVGColor * _result = 0;
    HRESULT _hr = get_FillColorTo(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGColorPtr(_result, false);
}

#pragma implementation_key(4262)
inline void VGCore::IVGEffectContour::PutFillColorTo ( struct IVGColor * ppVal ) {
    HRESULT _hr = put_FillColorTo(ppVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(4263)
inline VARIANT_BOOL VGCore::IVGEffectContour::GetLinkAcceleration ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_LinkAcceleration(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4264)
inline void VGCore::IVGEffectContour::PutLinkAcceleration ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_LinkAcceleration(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(4265)
inline long VGCore::IVGEffectContour::GetColorAcceleration ( ) {
    long _result = 0;
    HRESULT _hr = get_ColorAcceleration(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4266)
inline void VGCore::IVGEffectContour::PutColorAcceleration ( long pVal ) {
    HRESULT _hr = put_ColorAcceleration(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(4267)
inline long VGCore::IVGEffectContour::GetSpacingAcceleration ( ) {
    long _result = 0;
    HRESULT _hr = get_SpacingAcceleration(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4268)
inline void VGCore::IVGEffectContour::PutSpacingAcceleration ( long pVal ) {
    HRESULT _hr = put_SpacingAcceleration(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(4269)
inline VGCore::IVGShapePtr VGCore::IVGEffectContour::GetContourGroup ( ) {
    struct IVGShape * _result = 0;
    HRESULT _hr = get_ContourGroup(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGShapePtr(_result, false);
}

#pragma implementation_key(4270)
inline enum VGCore::cdrContourEndCapType VGCore::IVGEffectContour::GetEndCapType ( ) {
    enum cdrContourEndCapType _result;
    HRESULT _hr = get_EndCapType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4271)
inline void VGCore::IVGEffectContour::PutEndCapType ( enum cdrContourEndCapType pVal ) {
    HRESULT _hr = put_EndCapType(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(4272)
inline enum VGCore::cdrContourCornerType VGCore::IVGEffectContour::GetCornerType ( ) {
    enum cdrContourCornerType _result;
    HRESULT _hr = get_CornerType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4273)
inline void VGCore::IVGEffectContour::PutCornerType ( enum cdrContourCornerType pVal ) {
    HRESULT _hr = put_CornerType(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(4274)
inline double VGCore::IVGEffectContour::GetMiterLimit ( ) {
    double _result = 0;
    HRESULT _hr = get_MiterLimit(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4275)
inline void VGCore::IVGEffectContour::PutMiterLimit ( double pVal ) {
    HRESULT _hr = put_MiterLimit(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IVGEffectLens wrapper method implementations
//

#pragma implementation_key(4276)
inline VGCore::IVGApplicationPtr VGCore::IVGEffectLens::GetApplication ( ) {
    struct IVGApplication * _result = 0;
    HRESULT _hr = get_Application(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGApplicationPtr(_result, false);
}

#pragma implementation_key(4277)
inline VGCore::IVGEffectPtr VGCore::IVGEffectLens::GetParent ( ) {
    struct IVGEffect * _result = 0;
    HRESULT _hr = get_Parent(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGEffectPtr(_result, false);
}

#pragma implementation_key(4278)
inline HRESULT VGCore::IVGEffectLens::Freeze ( ) {
    HRESULT _hr = raw_Freeze();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(4279)
inline HRESULT VGCore::IVGEffectLens::Unfreeze ( ) {
    HRESULT _hr = raw_Unfreeze();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(4280)
inline VGCore::IVGShapeRangePtr VGCore::IVGEffectLens::Ungroup ( ) {
    struct IVGShapeRange * _result = 0;
    HRESULT _hr = raw_Ungroup(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGShapeRangePtr(_result, false);
}

#pragma implementation_key(4281)
inline VGCore::IVGShapesPtr VGCore::IVGEffectLens::GetShapes ( ) {
    struct IVGShapes * _result = 0;
    HRESULT _hr = get_Shapes(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGShapesPtr(_result, false);
}

#pragma implementation_key(4282)
inline VARIANT_BOOL VGCore::IVGEffectLens::GetFrozen ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_Frozen(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4283)
inline enum VGCore::cdrLensType VGCore::IVGEffectLens::GetType ( ) {
    enum cdrLensType _result;
    HRESULT _hr = get_Type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4284)
inline void VGCore::IVGEffectLens::PutType ( enum cdrLensType pVal ) {
    HRESULT _hr = put_Type(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(4285)
inline long VGCore::IVGEffectLens::GetRate ( ) {
    long _result = 0;
    HRESULT _hr = get_Rate(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4286)
inline void VGCore::IVGEffectLens::PutRate ( long pVal ) {
    HRESULT _hr = put_Rate(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(4287)
inline VGCore::IVGColorPtr VGCore::IVGEffectLens::GetColor ( ) {
    struct IVGColor * _result = 0;
    HRESULT _hr = get_Color(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGColorPtr(_result, false);
}

#pragma implementation_key(4288)
inline void VGCore::IVGEffectLens::PutColor ( struct IVGColor * ppVal ) {
    HRESULT _hr = put_Color(ppVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(4289)
inline VGCore::IVGColorPtr VGCore::IVGEffectLens::GetOutlineColor ( ) {
    struct IVGColor * _result = 0;
    HRESULT _hr = get_OutlineColor(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGColorPtr(_result, false);
}

#pragma implementation_key(4290)
inline void VGCore::IVGEffectLens::PutOutlineColor ( struct IVGColor * ppVal ) {
    HRESULT _hr = put_OutlineColor(ppVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(4291)
inline VGCore::IVGColorPtr VGCore::IVGEffectLens::GetFillColor ( ) {
    struct IVGColor * _result = 0;
    HRESULT _hr = get_FillColor(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGColorPtr(_result, false);
}

#pragma implementation_key(4292)
inline void VGCore::IVGEffectLens::PutFillColor ( struct IVGColor * ppVal ) {
    HRESULT _hr = put_FillColor(ppVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(4293)
inline VGCore::IVGColorPtr VGCore::IVGEffectLens::GetFromColor ( ) {
    struct IVGColor * _result = 0;
    HRESULT _hr = get_FromColor(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGColorPtr(_result, false);
}

#pragma implementation_key(4294)
inline void VGCore::IVGEffectLens::PutFromColor ( struct IVGColor * ppVal ) {
    HRESULT _hr = put_FromColor(ppVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(4295)
inline VGCore::IVGColorPtr VGCore::IVGEffectLens::GetToColor ( ) {
    struct IVGColor * _result = 0;
    HRESULT _hr = get_ToColor(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGColorPtr(_result, false);
}

#pragma implementation_key(4296)
inline void VGCore::IVGEffectLens::PutToColor ( struct IVGColor * ppVal ) {
    HRESULT _hr = put_ToColor(ppVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(4297)
inline VARIANT_BOOL VGCore::IVGEffectLens::GetUseOutlineColor ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_UseOutlineColor(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4298)
inline void VGCore::IVGEffectLens::PutUseOutlineColor ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_UseOutlineColor(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(4299)
inline VARIANT_BOOL VGCore::IVGEffectLens::GetUseFillColor ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_UseFillColor(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4300)
inline void VGCore::IVGEffectLens::PutUseFillColor ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_UseFillColor(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(4301)
inline enum VGCore::cdrFountainFillBlendType VGCore::IVGEffectLens::GetColorMapPalette ( ) {
    enum cdrFountainFillBlendType _result;
    HRESULT _hr = get_ColorMapPalette(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4302)
inline void VGCore::IVGEffectLens::PutColorMapPalette ( enum cdrFountainFillBlendType pVal ) {
    HRESULT _hr = put_ColorMapPalette(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(4303)
inline double VGCore::IVGEffectLens::GetMagnification ( ) {
    double _result = 0;
    HRESULT _hr = get_Magnification(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4304)
inline void VGCore::IVGEffectLens::PutMagnification ( double pVal ) {
    HRESULT _hr = put_Magnification(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(4305)
inline VARIANT_BOOL VGCore::IVGEffectLens::GetUseViewPoint ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_UseViewPoint(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4306)
inline void VGCore::IVGEffectLens::PutUseViewPoint ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_UseViewPoint(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(4307)
inline double VGCore::IVGEffectLens::GetViewPointX ( ) {
    double _result = 0;
    HRESULT _hr = get_ViewPointX(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4308)
inline void VGCore::IVGEffectLens::PutViewPointX ( double pVal ) {
    HRESULT _hr = put_ViewPointX(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(4309)
inline double VGCore::IVGEffectLens::GetViewPointY ( ) {
    double _result = 0;
    HRESULT _hr = get_ViewPointY(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4310)
inline void VGCore::IVGEffectLens::PutViewPointY ( double pVal ) {
    HRESULT _hr = put_ViewPointY(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(4311)
inline VARIANT_BOOL VGCore::IVGEffectLens::GetRemoveFace ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_RemoveFace(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4312)
inline void VGCore::IVGEffectLens::PutRemoveFace ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_RemoveFace(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(4313)
inline long VGCore::IVGEffectLens::GetPaletteRotation ( ) {
    long _result = 0;
    HRESULT _hr = get_PaletteRotation(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4314)
inline void VGCore::IVGEffectLens::PutPaletteRotation ( long pVal ) {
    HRESULT _hr = put_PaletteRotation(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IVGEffectPerspective wrapper method implementations
//

#pragma implementation_key(4315)
inline VGCore::IVGApplicationPtr VGCore::IVGEffectPerspective::GetApplication ( ) {
    struct IVGApplication * _result = 0;
    HRESULT _hr = get_Application(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGApplicationPtr(_result, false);
}

#pragma implementation_key(4316)
inline VGCore::IVGEffectPtr VGCore::IVGEffectPerspective::GetParent ( ) {
    struct IVGEffect * _result = 0;
    HRESULT _hr = get_Parent(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGEffectPtr(_result, false);
}

#pragma implementation_key(4317)
inline VARIANT_BOOL VGCore::IVGEffectPerspective::GetUseHorizVanishingPoint ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_UseHorizVanishingPoint(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4318)
inline void VGCore::IVGEffectPerspective::PutUseHorizVanishingPoint ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_UseHorizVanishingPoint(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(4319)
inline VARIANT_BOOL VGCore::IVGEffectPerspective::GetUseVertVanishingPoint ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_UseVertVanishingPoint(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4320)
inline void VGCore::IVGEffectPerspective::PutUseVertVanishingPoint ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_UseVertVanishingPoint(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(4321)
inline double VGCore::IVGEffectPerspective::GetHorizVanishingPointX ( ) {
    double _result = 0;
    HRESULT _hr = get_HorizVanishingPointX(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4322)
inline void VGCore::IVGEffectPerspective::PutHorizVanishingPointX ( double pVal ) {
    HRESULT _hr = put_HorizVanishingPointX(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(4323)
inline double VGCore::IVGEffectPerspective::GetHorizVanishingPointY ( ) {
    double _result = 0;
    HRESULT _hr = get_HorizVanishingPointY(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4324)
inline void VGCore::IVGEffectPerspective::PutHorizVanishingPointY ( double pVal ) {
    HRESULT _hr = put_HorizVanishingPointY(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(4325)
inline double VGCore::IVGEffectPerspective::GetVertVanishingPointX ( ) {
    double _result = 0;
    HRESULT _hr = get_VertVanishingPointX(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4326)
inline void VGCore::IVGEffectPerspective::PutVertVanishingPointX ( double pVal ) {
    HRESULT _hr = put_VertVanishingPointX(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(4327)
inline double VGCore::IVGEffectPerspective::GetVertVanishingPointY ( ) {
    double _result = 0;
    HRESULT _hr = get_VertVanishingPointY(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4328)
inline void VGCore::IVGEffectPerspective::PutVertVanishingPointY ( double pVal ) {
    HRESULT _hr = put_VertVanishingPointY(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IVGEffectInnerShadow wrapper method implementations
//

#pragma implementation_key(4329)
inline VGCore::IVGApplicationPtr VGCore::IVGEffectInnerShadow::GetApplication ( ) {
    struct IVGApplication * _result = 0;
    HRESULT _hr = get_Application(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGApplicationPtr(_result, false);
}

#pragma implementation_key(4330)
inline VGCore::IVGEffectPtr VGCore::IVGEffectInnerShadow::GetParent ( ) {
    struct IVGEffect * _result = 0;
    HRESULT _hr = get_Parent(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGEffectPtr(_result, false);
}

#pragma implementation_key(4331)
inline double VGCore::IVGEffectInnerShadow::GetOffsetX ( ) {
    double _result = 0;
    HRESULT _hr = get_OffsetX(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4332)
inline void VGCore::IVGEffectInnerShadow::PutOffsetX ( double pVal ) {
    HRESULT _hr = put_OffsetX(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(4333)
inline double VGCore::IVGEffectInnerShadow::GetOffsetY ( ) {
    double _result = 0;
    HRESULT _hr = get_OffsetY(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4334)
inline void VGCore::IVGEffectInnerShadow::PutOffsetY ( double pVal ) {
    HRESULT _hr = put_OffsetY(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(4335)
inline long VGCore::IVGEffectInnerShadow::GetOpacity ( ) {
    long _result = 0;
    HRESULT _hr = get_Opacity(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4336)
inline void VGCore::IVGEffectInnerShadow::PutOpacity ( long pVal ) {
    HRESULT _hr = put_Opacity(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(4337)
inline long VGCore::IVGEffectInnerShadow::GetFeather ( ) {
    long _result = 0;
    HRESULT _hr = get_Feather(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4338)
inline void VGCore::IVGEffectInnerShadow::PutFeather ( long pVal ) {
    HRESULT _hr = put_Feather(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(4339)
inline enum VGCore::cdrFeatherType VGCore::IVGEffectInnerShadow::GetFeatherType ( ) {
    enum cdrFeatherType _result;
    HRESULT _hr = get_FeatherType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4340)
inline void VGCore::IVGEffectInnerShadow::PutFeatherType ( enum cdrFeatherType pVal ) {
    HRESULT _hr = put_FeatherType(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(4341)
inline enum VGCore::cdrEdgeType VGCore::IVGEffectInnerShadow::GetFeatherEdge ( ) {
    enum cdrEdgeType _result;
    HRESULT _hr = get_FeatherEdge(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4342)
inline void VGCore::IVGEffectInnerShadow::PutFeatherEdge ( enum cdrEdgeType pVal ) {
    HRESULT _hr = put_FeatherEdge(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(4343)
inline VGCore::IVGColorPtr VGCore::IVGEffectInnerShadow::GetColor ( ) {
    struct IVGColor * _result = 0;
    HRESULT _hr = get_Color(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGColorPtr(_result, false);
}

#pragma implementation_key(4344)
inline void VGCore::IVGEffectInnerShadow::PutColor ( struct IVGColor * ppVal ) {
    HRESULT _hr = put_Color(ppVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(4345)
inline HRESULT VGCore::IVGEffectInnerShadow::SetOffset ( double OffsetX, double OffsetY ) {
    HRESULT _hr = raw_SetOffset(OffsetX, OffsetY);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(4346)
inline VGCore::IVGShapePtr VGCore::IVGEffectInnerShadow::GetShadowGroup ( ) {
    struct IVGShape * _result = 0;
    HRESULT _hr = get_ShadowGroup(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGShapePtr(_result, false);
}

#pragma implementation_key(4347)
inline enum VGCore::cdrMergeMode VGCore::IVGEffectInnerShadow::GetMergeMode ( ) {
    enum cdrMergeMode _result;
    HRESULT _hr = get_MergeMode(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4348)
inline void VGCore::IVGEffectInnerShadow::PutMergeMode ( enum cdrMergeMode pVal ) {
    HRESULT _hr = put_MergeMode(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(4349)
inline double VGCore::IVGEffectInnerShadow::GetDepth ( ) {
    double _result = 0;
    HRESULT _hr = get_Depth(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4350)
inline void VGCore::IVGEffectInnerShadow::PutDepth ( double pVal ) {
    HRESULT _hr = put_Depth(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IVGEffectExtrude wrapper method implementations
//

#pragma implementation_key(4351)
inline VGCore::IVGApplicationPtr VGCore::IVGEffectExtrude::GetApplication ( ) {
    struct IVGApplication * _result = 0;
    HRESULT _hr = get_Application(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGApplicationPtr(_result, false);
}

#pragma implementation_key(4352)
inline VGCore::IVGEffectPtr VGCore::IVGEffectExtrude::GetParent ( ) {
    struct IVGEffect * _result = 0;
    HRESULT _hr = get_Parent(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGEffectPtr(_result, false);
}

#pragma implementation_key(4353)
inline enum VGCore::cdrExtrudeType VGCore::IVGEffectExtrude::GetType ( ) {
    enum cdrExtrudeType _result;
    HRESULT _hr = get_Type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4354)
inline void VGCore::IVGEffectExtrude::PutType ( enum cdrExtrudeType pVal ) {
    HRESULT _hr = put_Type(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(4355)
inline VGCore::IVGExtrudeVanishingPointPtr VGCore::IVGEffectExtrude::GetVanishingPoint ( ) {
    struct IVGExtrudeVanishingPoint * _result = 0;
    HRESULT _hr = get_VanishingPoint(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGExtrudeVanishingPointPtr(_result, false);
}

#pragma implementation_key(4356)
inline void VGCore::IVGEffectExtrude::PutVanishingPoint ( struct IVGExtrudeVanishingPoint * ppVal ) {
    HRESULT _hr = put_VanishingPoint(ppVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(4357)
inline long VGCore::IVGEffectExtrude::GetDepth ( ) {
    long _result = 0;
    HRESULT _hr = get_Depth(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4358)
inline void VGCore::IVGEffectExtrude::PutDepth ( long pVal ) {
    HRESULT _hr = put_Depth(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(4359)
inline double VGCore::IVGEffectExtrude::GetAngleX ( ) {
    double _result = 0;
    HRESULT _hr = get_AngleX(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4360)
inline void VGCore::IVGEffectExtrude::PutAngleX ( double pVal ) {
    HRESULT _hr = put_AngleX(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(4361)
inline double VGCore::IVGEffectExtrude::GetAngleY ( ) {
    double _result = 0;
    HRESULT _hr = get_AngleY(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4362)
inline void VGCore::IVGEffectExtrude::PutAngleY ( double pVal ) {
    HRESULT _hr = put_AngleY(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(4363)
inline double VGCore::IVGEffectExtrude::GetAngleZ ( ) {
    double _result = 0;
    HRESULT _hr = get_AngleZ(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4364)
inline void VGCore::IVGEffectExtrude::PutAngleZ ( double pVal ) {
    HRESULT _hr = put_AngleZ(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(4365)
inline enum VGCore::cdrExtrudeShading VGCore::IVGEffectExtrude::GetShading ( ) {
    enum cdrExtrudeShading _result;
    HRESULT _hr = get_Shading(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4366)
inline void VGCore::IVGEffectExtrude::PutShading ( enum cdrExtrudeShading pVal ) {
    HRESULT _hr = put_Shading(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(4367)
inline VGCore::IVGColorPtr VGCore::IVGEffectExtrude::GetBaseColor ( ) {
    struct IVGColor * _result = 0;
    HRESULT _hr = get_BaseColor(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGColorPtr(_result, false);
}

#pragma implementation_key(4368)
inline void VGCore::IVGEffectExtrude::PutBaseColor ( struct IVGColor * ppVal ) {
    HRESULT _hr = put_BaseColor(ppVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(4369)
inline VGCore::IVGColorPtr VGCore::IVGEffectExtrude::GetShadingColor ( ) {
    struct IVGColor * _result = 0;
    HRESULT _hr = get_ShadingColor(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGColorPtr(_result, false);
}

#pragma implementation_key(4370)
inline void VGCore::IVGEffectExtrude::PutShadingColor ( struct IVGColor * ppVal ) {
    HRESULT _hr = put_ShadingColor(ppVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(4371)
inline VARIANT_BOOL VGCore::IVGEffectExtrude::GetUseBevel ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_UseBevel(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4372)
inline void VGCore::IVGEffectExtrude::PutUseBevel ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_UseBevel(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(4373)
inline VARIANT_BOOL VGCore::IVGEffectExtrude::GetShowBevelOnly ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_ShowBevelOnly(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4374)
inline void VGCore::IVGEffectExtrude::PutShowBevelOnly ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_ShowBevelOnly(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(4375)
inline double VGCore::IVGEffectExtrude::GetBevelDepth ( ) {
    double _result = 0;
    HRESULT _hr = get_BevelDepth(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4376)
inline void VGCore::IVGEffectExtrude::PutBevelDepth ( double pVal ) {
    HRESULT _hr = put_BevelDepth(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(4377)
inline double VGCore::IVGEffectExtrude::GetBevelAngle ( ) {
    double _result = 0;
    HRESULT _hr = get_BevelAngle(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4378)
inline void VGCore::IVGEffectExtrude::PutBevelAngle ( double pVal ) {
    HRESULT _hr = put_BevelAngle(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(4379)
inline VARIANT_BOOL VGCore::IVGEffectExtrude::GetUseExtrudeColorForBevel ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_UseExtrudeColorForBevel(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4380)
inline void VGCore::IVGEffectExtrude::PutUseExtrudeColorForBevel ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_UseExtrudeColorForBevel(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(4381)
inline VGCore::IVGColorPtr VGCore::IVGEffectExtrude::GetBevelColor ( ) {
    struct IVGColor * _result = 0;
    HRESULT _hr = get_BevelColor(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGColorPtr(_result, false);
}

#pragma implementation_key(4382)
inline void VGCore::IVGEffectExtrude::PutBevelColor ( struct IVGColor * ppVal ) {
    HRESULT _hr = put_BevelColor(ppVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(4383)
inline VARIANT_BOOL VGCore::IVGEffectExtrude::GetLightPresent ( long Index ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_LightPresent(Index, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4384)
inline void VGCore::IVGEffectExtrude::PutLightPresent ( long Index, VARIANT_BOOL pVal ) {
    HRESULT _hr = put_LightPresent(Index, pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(4385)
inline enum VGCore::cdrExtrudeLightPosition VGCore::IVGEffectExtrude::GetLightPosition ( long Index ) {
    enum cdrExtrudeLightPosition _result;
    HRESULT _hr = get_LightPosition(Index, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4386)
inline void VGCore::IVGEffectExtrude::PutLightPosition ( long Index, enum cdrExtrudeLightPosition pVal ) {
    HRESULT _hr = put_LightPosition(Index, pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(4387)
inline long VGCore::IVGEffectExtrude::GetLightIntensity ( long Index ) {
    long _result = 0;
    HRESULT _hr = get_LightIntensity(Index, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4388)
inline void VGCore::IVGEffectExtrude::PutLightIntensity ( long Index, long pVal ) {
    HRESULT _hr = put_LightIntensity(Index, pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(4389)
inline VARIANT_BOOL VGCore::IVGEffectExtrude::GetUseFullColorRange ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_UseFullColorRange(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4390)
inline void VGCore::IVGEffectExtrude::PutUseFullColorRange ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_UseFullColorRange(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(4391)
inline VARIANT_BOOL VGCore::IVGEffectExtrude::GetFaceVisible ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_FaceVisible(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4392)
inline VGCore::IVGShapePtr VGCore::IVGEffectExtrude::GetFaceShape ( ) {
    struct IVGShape * _result = 0;
    HRESULT _hr = get_FaceShape(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGShapePtr(_result, false);
}

#pragma implementation_key(4393)
inline VGCore::IVGShapePtr VGCore::IVGEffectExtrude::GetBevelGroup ( ) {
    struct IVGShape * _result = 0;
    HRESULT _hr = get_BevelGroup(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGShapePtr(_result, false);
}

#pragma implementation_key(4394)
inline VGCore::IVGShapePtr VGCore::IVGEffectExtrude::GetExtrudeGroup ( ) {
    struct IVGShape * _result = 0;
    HRESULT _hr = get_ExtrudeGroup(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGShapePtr(_result, false);
}

#pragma implementation_key(4395)
inline HRESULT VGCore::IVGEffectExtrude::Rotate ( double AngleX, double AngleY, double AngleZ ) {
    HRESULT _hr = raw_Rotate(AngleX, AngleY, AngleZ);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(4396)
inline HRESULT VGCore::IVGEffectExtrude::SetBevel ( double Depth, double Angle, VARIANT_BOOL ShowBevelOnly ) {
    HRESULT _hr = raw_SetBevel(Depth, Angle, ShowBevelOnly);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(4397)
inline HRESULT VGCore::IVGEffectExtrude::SetLight ( long Index, enum cdrExtrudeLightPosition Position, long LightIntensity ) {
    HRESULT _hr = raw_SetLight(Index, Position, LightIntensity);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(4398)
inline HRESULT VGCore::IVGEffectExtrude::CopyFrom ( struct IVGEffectExtrude * Source ) {
    HRESULT _hr = raw_CopyFrom(Source);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface IVGExtrudeVanishingPoint wrapper method implementations
//

#pragma implementation_key(4399)
inline VGCore::IVGApplicationPtr VGCore::IVGExtrudeVanishingPoint::GetApplication ( ) {
    struct IVGApplication * _result = 0;
    HRESULT _hr = get_Application(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGApplicationPtr(_result, false);
}

#pragma implementation_key(4400)
inline VGCore::IVGEffectExtrudePtr VGCore::IVGExtrudeVanishingPoint::GetParent ( ) {
    struct IVGEffectExtrude * _result = 0;
    HRESULT _hr = get_Parent(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGEffectExtrudePtr(_result, false);
}

#pragma implementation_key(4401)
inline enum VGCore::cdrExtrudeVPType VGCore::IVGExtrudeVanishingPoint::GetType ( ) {
    enum cdrExtrudeVPType _result;
    HRESULT _hr = get_Type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4402)
inline void VGCore::IVGExtrudeVanishingPoint::PutType ( enum cdrExtrudeVPType pVal ) {
    HRESULT _hr = put_Type(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(4403)
inline double VGCore::IVGExtrudeVanishingPoint::GetPositionX ( ) {
    double _result = 0;
    HRESULT _hr = get_PositionX(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4404)
inline void VGCore::IVGExtrudeVanishingPoint::PutPositionX ( double pVal ) {
    HRESULT _hr = put_PositionX(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(4405)
inline double VGCore::IVGExtrudeVanishingPoint::GetPositionY ( ) {
    double _result = 0;
    HRESULT _hr = get_PositionY(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4406)
inline void VGCore::IVGExtrudeVanishingPoint::PutPositionY ( double pVal ) {
    HRESULT _hr = put_PositionY(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(4407)
inline VGCore::IVGEffectsPtr VGCore::IVGExtrudeVanishingPoint::GetEffects ( ) {
    struct IVGEffects * _result = 0;
    HRESULT _hr = get_Effects(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGEffectsPtr(_result, false);
}

#pragma implementation_key(4408)
inline VARIANT_BOOL VGCore::IVGExtrudeVanishingPoint::Share ( struct IVGEffectExtrude * Source ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_Share(Source, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface IVGEffectDistortion wrapper method implementations
//

#pragma implementation_key(4409)
inline VGCore::IVGApplicationPtr VGCore::IVGEffectDistortion::GetApplication ( ) {
    struct IVGApplication * _result = 0;
    HRESULT _hr = get_Application(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGApplicationPtr(_result, false);
}

#pragma implementation_key(4410)
inline VGCore::IVGEffectPtr VGCore::IVGEffectDistortion::GetParent ( ) {
    struct IVGEffect * _result = 0;
    HRESULT _hr = get_Parent(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGEffectPtr(_result, false);
}

#pragma implementation_key(4411)
inline enum VGCore::cdrDistortionType VGCore::IVGEffectDistortion::GetType ( ) {
    enum cdrDistortionType _result;
    HRESULT _hr = get_Type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4412)
inline void VGCore::IVGEffectDistortion::PutType ( enum cdrDistortionType pVal ) {
    HRESULT _hr = put_Type(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(4413)
inline double VGCore::IVGEffectDistortion::GetOriginX ( ) {
    double _result = 0;
    HRESULT _hr = get_OriginX(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4414)
inline void VGCore::IVGEffectDistortion::PutOriginX ( double pVal ) {
    HRESULT _hr = put_OriginX(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(4415)
inline double VGCore::IVGEffectDistortion::GetOriginY ( ) {
    double _result = 0;
    HRESULT _hr = get_OriginY(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4416)
inline void VGCore::IVGEffectDistortion::PutOriginY ( double pVal ) {
    HRESULT _hr = put_OriginY(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(4417)
inline VGCore::IVGEffectPushPullDistortionPtr VGCore::IVGEffectDistortion::GetPushPull ( ) {
    struct IVGEffectPushPullDistortion * _result = 0;
    HRESULT _hr = get_PushPull(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGEffectPushPullDistortionPtr(_result, false);
}

#pragma implementation_key(4418)
inline void VGCore::IVGEffectDistortion::PutPushPull ( struct IVGEffectPushPullDistortion * ppVal ) {
    HRESULT _hr = put_PushPull(ppVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(4419)
inline VGCore::IVGEffectZipperDistortionPtr VGCore::IVGEffectDistortion::GetZipper ( ) {
    struct IVGEffectZipperDistortion * _result = 0;
    HRESULT _hr = get_Zipper(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGEffectZipperDistortionPtr(_result, false);
}

#pragma implementation_key(4420)
inline void VGCore::IVGEffectDistortion::PutZipper ( struct IVGEffectZipperDistortion * ppVal ) {
    HRESULT _hr = put_Zipper(ppVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(4421)
inline VGCore::IVGEffectTwisterDistortionPtr VGCore::IVGEffectDistortion::GetTwister ( ) {
    struct IVGEffectTwisterDistortion * _result = 0;
    HRESULT _hr = get_Twister(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGEffectTwisterDistortionPtr(_result, false);
}

#pragma implementation_key(4422)
inline void VGCore::IVGEffectDistortion::PutTwister ( struct IVGEffectTwisterDistortion * ppVal ) {
    HRESULT _hr = put_Twister(ppVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(4423)
inline HRESULT VGCore::IVGEffectDistortion::CenterDistortion ( ) {
    HRESULT _hr = raw_CenterDistortion();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(4424)
inline VGCore::IVGEffectCustomDistortionPtr VGCore::IVGEffectDistortion::GetCustom ( ) {
    struct IVGEffectCustomDistortion * _result = 0;
    HRESULT _hr = get_Custom(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGEffectCustomDistortionPtr(_result, false);
}

//
// interface IVGEffectPushPullDistortion wrapper method implementations
//

#pragma implementation_key(4425)
inline VGCore::IVGApplicationPtr VGCore::IVGEffectPushPullDistortion::GetApplication ( ) {
    struct IVGApplication * _result = 0;
    HRESULT _hr = get_Application(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGApplicationPtr(_result, false);
}

#pragma implementation_key(4426)
inline VGCore::IVGEffectDistortionPtr VGCore::IVGEffectPushPullDistortion::GetParent ( ) {
    struct IVGEffectDistortion * _result = 0;
    HRESULT _hr = get_Parent(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGEffectDistortionPtr(_result, false);
}

#pragma implementation_key(4427)
inline long VGCore::IVGEffectPushPullDistortion::GetAmplitude ( ) {
    long _result = 0;
    HRESULT _hr = get_Amplitude(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4428)
inline void VGCore::IVGEffectPushPullDistortion::PutAmplitude ( long pVal ) {
    HRESULT _hr = put_Amplitude(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IVGEffectZipperDistortion wrapper method implementations
//

#pragma implementation_key(4429)
inline VGCore::IVGApplicationPtr VGCore::IVGEffectZipperDistortion::GetApplication ( ) {
    struct IVGApplication * _result = 0;
    HRESULT _hr = get_Application(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGApplicationPtr(_result, false);
}

#pragma implementation_key(4430)
inline VGCore::IVGEffectDistortionPtr VGCore::IVGEffectZipperDistortion::GetParent ( ) {
    struct IVGEffectDistortion * _result = 0;
    HRESULT _hr = get_Parent(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGEffectDistortionPtr(_result, false);
}

#pragma implementation_key(4431)
inline long VGCore::IVGEffectZipperDistortion::GetAmplitude ( ) {
    long _result = 0;
    HRESULT _hr = get_Amplitude(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4432)
inline void VGCore::IVGEffectZipperDistortion::PutAmplitude ( long pVal ) {
    HRESULT _hr = put_Amplitude(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(4433)
inline long VGCore::IVGEffectZipperDistortion::GetFrequency ( ) {
    long _result = 0;
    HRESULT _hr = get_Frequency(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4434)
inline void VGCore::IVGEffectZipperDistortion::PutFrequency ( long pVal ) {
    HRESULT _hr = put_Frequency(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(4435)
inline VARIANT_BOOL VGCore::IVGEffectZipperDistortion::GetRandom ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_Random(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4436)
inline void VGCore::IVGEffectZipperDistortion::PutRandom ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_Random(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(4437)
inline VARIANT_BOOL VGCore::IVGEffectZipperDistortion::GetSmooth ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_Smooth(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4438)
inline void VGCore::IVGEffectZipperDistortion::PutSmooth ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_Smooth(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(4439)
inline VARIANT_BOOL VGCore::IVGEffectZipperDistortion::GetLocal ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_Local(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4440)
inline void VGCore::IVGEffectZipperDistortion::PutLocal ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_Local(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IVGEffectTwisterDistortion wrapper method implementations
//

#pragma implementation_key(4441)
inline VGCore::IVGApplicationPtr VGCore::IVGEffectTwisterDistortion::GetApplication ( ) {
    struct IVGApplication * _result = 0;
    HRESULT _hr = get_Application(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGApplicationPtr(_result, false);
}

#pragma implementation_key(4442)
inline VGCore::IVGEffectDistortionPtr VGCore::IVGEffectTwisterDistortion::GetParent ( ) {
    struct IVGEffectDistortion * _result = 0;
    HRESULT _hr = get_Parent(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGEffectDistortionPtr(_result, false);
}

#pragma implementation_key(4443)
inline double VGCore::IVGEffectTwisterDistortion::GetAngle ( ) {
    double _result = 0;
    HRESULT _hr = get_Angle(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4444)
inline void VGCore::IVGEffectTwisterDistortion::PutAngle ( double pVal ) {
    HRESULT _hr = put_Angle(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IVGTextRange wrapper method implementations
//

#pragma implementation_key(4445)
inline _bstr_t VGCore::IVGTextRange::GetText ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Text(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(4446)
inline void VGCore::IVGTextRange::PutText ( _bstr_t ppVal ) {
    HRESULT _hr = put_Text(ppVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(4447)
inline _bstr_t VGCore::IVGTextRange::GetWideText ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_WideText(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(4448)
inline void VGCore::IVGTextRange::PutWideText ( _bstr_t ppVal ) {
    HRESULT _hr = put_WideText(ppVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(4449)
inline VGCore::IVGTextCharactersPtr VGCore::IVGTextRange::GetCharacters ( ) {
    struct IVGTextCharacters * _result = 0;
    HRESULT _hr = get_Characters(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGTextCharactersPtr(_result, false);
}

#pragma implementation_key(4450)
inline VGCore::IVGTextWordsPtr VGCore::IVGTextRange::GetWords ( ) {
    struct IVGTextWords * _result = 0;
    HRESULT _hr = get_Words(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGTextWordsPtr(_result, false);
}

#pragma implementation_key(4451)
inline VGCore::IVGTextLinesPtr VGCore::IVGTextRange::GetLines ( ) {
    struct IVGTextLines * _result = 0;
    HRESULT _hr = get_Lines(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGTextLinesPtr(_result, false);
}

#pragma implementation_key(4452)
inline VGCore::IVGTextParagraphsPtr VGCore::IVGTextRange::GetParagraphs ( ) {
    struct IVGTextParagraphs * _result = 0;
    HRESULT _hr = get_Paragraphs(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGTextParagraphsPtr(_result, false);
}

#pragma implementation_key(4453)
inline long VGCore::IVGTextRange::GetStart ( ) {
    long _result = 0;
    HRESULT _hr = get_Start(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4454)
inline void VGCore::IVGTextRange::PutStart ( long pVal ) {
    HRESULT _hr = put_Start(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(4455)
inline long VGCore::IVGTextRange::GetEnd ( ) {
    long _result = 0;
    HRESULT _hr = get_End(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4456)
inline void VGCore::IVGTextRange::PutEnd ( long pVal ) {
    HRESULT _hr = put_End(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(4457)
inline long VGCore::IVGTextRange::GetLength ( ) {
    long _result = 0;
    HRESULT _hr = get_Length(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4458)
inline void VGCore::IVGTextRange::PutLength ( long pVal ) {
    HRESULT _hr = put_Length(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(4459)
inline VGCore::IVGTextRangePtr VGCore::IVGTextRange::Duplicate ( ) {
    struct IVGTextRange * _result = 0;
    HRESULT _hr = raw_Duplicate(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGTextRangePtr(_result, false);
}

#pragma implementation_key(4460)
inline enum VGCore::cdrFontStyle VGCore::IVGTextRange::GetStyle ( ) {
    enum cdrFontStyle _result;
    HRESULT _hr = get_Style(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4461)
inline void VGCore::IVGTextRange::PutStyle ( enum cdrFontStyle pVal ) {
    HRESULT _hr = put_Style(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(4462)
inline VARIANT_BOOL VGCore::IVGTextRange::GetBold ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_Bold(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4463)
inline void VGCore::IVGTextRange::PutBold ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_Bold(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(4464)
inline VARIANT_BOOL VGCore::IVGTextRange::GetItalic ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_Italic(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4465)
inline void VGCore::IVGTextRange::PutItalic ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_Italic(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(4466)
inline enum VGCore::cdrFontLine VGCore::IVGTextRange::GetUnderline ( ) {
    enum cdrFontLine _result;
    HRESULT _hr = get_Underline(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4467)
inline void VGCore::IVGTextRange::PutUnderline ( enum cdrFontLine pVal ) {
    HRESULT _hr = put_Underline(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(4468)
inline enum VGCore::cdrFontLine VGCore::IVGTextRange::GetStrikethru ( ) {
    enum cdrFontLine _result;
    HRESULT _hr = get_Strikethru(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4469)
inline void VGCore::IVGTextRange::PutStrikethru ( enum cdrFontLine pVal ) {
    HRESULT _hr = put_Strikethru(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(4470)
inline enum VGCore::cdrFontLine VGCore::IVGTextRange::GetOverscore ( ) {
    enum cdrFontLine _result;
    HRESULT _hr = get_Overscore(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4471)
inline void VGCore::IVGTextRange::PutOverscore ( enum cdrFontLine pVal ) {
    HRESULT _hr = put_Overscore(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(4472)
inline _bstr_t VGCore::IVGTextRange::GetFont ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Font(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(4473)
inline void VGCore::IVGTextRange::PutFont ( _bstr_t pVal ) {
    HRESULT _hr = put_Font(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(4474)
inline float VGCore::IVGTextRange::GetSize ( ) {
    float _result = 0;
    HRESULT _hr = get_Size(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4475)
inline void VGCore::IVGTextRange::PutSize ( float pVal ) {
    HRESULT _hr = put_Size(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(4476)
inline enum VGCore::cdrFontPosition VGCore::IVGTextRange::GetPosition ( ) {
    enum cdrFontPosition _result;
    HRESULT _hr = get_Position(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4477)
inline void VGCore::IVGTextRange::PutPosition ( enum cdrFontPosition pVal ) {
    HRESULT _hr = put_Position(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(4478)
inline enum VGCore::cdrFontCase VGCore::IVGTextRange::GetCase ( ) {
    enum cdrFontCase _result;
    HRESULT _hr = get_Case(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4479)
inline void VGCore::IVGTextRange::PutCase ( enum cdrFontCase pVal ) {
    HRESULT _hr = put_Case(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(4480)
inline float VGCore::IVGTextRange::GetCharAngle ( ) {
    float _result = 0;
    HRESULT _hr = get_CharAngle(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4481)
inline void VGCore::IVGTextRange::PutCharAngle ( float pVal ) {
    HRESULT _hr = put_CharAngle(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(4482)
inline enum VGCore::cdrAlignment VGCore::IVGTextRange::GetAlignment ( ) {
    enum cdrAlignment _result;
    HRESULT _hr = get_Alignment(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4483)
inline void VGCore::IVGTextRange::PutAlignment ( enum cdrAlignment pVal ) {
    HRESULT _hr = put_Alignment(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(4484)
inline double VGCore::IVGTextRange::GetFirstLineIndent ( ) {
    double _result = 0;
    HRESULT _hr = get_FirstLineIndent(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4485)
inline void VGCore::IVGTextRange::PutFirstLineIndent ( double pVal ) {
    HRESULT _hr = put_FirstLineIndent(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(4486)
inline long VGCore::IVGTextRange::GetHorizShift ( ) {
    long _result = 0;
    HRESULT _hr = get_HorizShift(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4487)
inline void VGCore::IVGTextRange::PutHorizShift ( long pVal ) {
    HRESULT _hr = put_HorizShift(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(4488)
inline long VGCore::IVGTextRange::GetVertShift ( ) {
    long _result = 0;
    HRESULT _hr = get_VertShift(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4489)
inline void VGCore::IVGTextRange::PutVertShift ( long pVal ) {
    HRESULT _hr = put_VertShift(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(4490)
inline double VGCore::IVGTextRange::GetLeftIndent ( ) {
    double _result = 0;
    HRESULT _hr = get_LeftIndent(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4491)
inline void VGCore::IVGTextRange::PutLeftIndent ( double pVal ) {
    HRESULT _hr = put_LeftIndent(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(4492)
inline double VGCore::IVGTextRange::GetRightIndent ( ) {
    double _result = 0;
    HRESULT _hr = get_RightIndent(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4493)
inline void VGCore::IVGTextRange::PutRightIndent ( double pVal ) {
    HRESULT _hr = put_RightIndent(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(4494)
inline float VGCore::IVGTextRange::GetMinWordSpacing ( ) {
    float _result = 0;
    HRESULT _hr = get_MinWordSpacing(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4495)
inline void VGCore::IVGTextRange::PutMinWordSpacing ( float pVal ) {
    HRESULT _hr = put_MinWordSpacing(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(4496)
inline float VGCore::IVGTextRange::GetMaxWordSpacing ( ) {
    float _result = 0;
    HRESULT _hr = get_MaxWordSpacing(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4497)
inline void VGCore::IVGTextRange::PutMaxWordSpacing ( float pVal ) {
    HRESULT _hr = put_MaxWordSpacing(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(4498)
inline float VGCore::IVGTextRange::GetMaxCharSpacing ( ) {
    float _result = 0;
    HRESULT _hr = get_MaxCharSpacing(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4499)
inline void VGCore::IVGTextRange::PutMaxCharSpacing ( float pVal ) {
    HRESULT _hr = put_MaxCharSpacing(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(4500)
inline float VGCore::IVGTextRange::GetParaSpacingBefore ( ) {
    float _result = 0;
    HRESULT _hr = get_ParaSpacingBefore(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4501)
inline void VGCore::IVGTextRange::PutParaSpacingBefore ( float pVal ) {
    HRESULT _hr = put_ParaSpacingBefore(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(4502)
inline float VGCore::IVGTextRange::GetParaSpacingAfter ( ) {
    float _result = 0;
    HRESULT _hr = get_ParaSpacingAfter(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4503)
inline void VGCore::IVGTextRange::PutParaSpacingAfter ( float pVal ) {
    HRESULT _hr = put_ParaSpacingAfter(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(4504)
inline float VGCore::IVGTextRange::GetCharSpacing ( ) {
    float _result = 0;
    HRESULT _hr = get_CharSpacing(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4505)
inline void VGCore::IVGTextRange::PutCharSpacing ( float pVal ) {
    HRESULT _hr = put_CharSpacing(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(4506)
inline float VGCore::IVGTextRange::GetLineSpacing ( ) {
    float _result = 0;
    HRESULT _hr = get_LineSpacing(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4507)
inline void VGCore::IVGTextRange::PutLineSpacing ( float pVal ) {
    HRESULT _hr = put_LineSpacing(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(4508)
inline enum VGCore::cdrLineSpacingType VGCore::IVGTextRange::GetLineSpacingType ( ) {
    enum cdrLineSpacingType _result;
    HRESULT _hr = get_LineSpacingType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4509)
inline float VGCore::IVGTextRange::GetWordSpacing ( ) {
    float _result = 0;
    HRESULT _hr = get_WordSpacing(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4510)
inline void VGCore::IVGTextRange::PutWordSpacing ( float pVal ) {
    HRESULT _hr = put_WordSpacing(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(4511)
inline enum VGCore::cdrTriState VGCore::IVGTextRange::GetAutoHyphenate ( ) {
    enum cdrTriState _result;
    HRESULT _hr = get_AutoHyphenate(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4512)
inline void VGCore::IVGTextRange::PutAutoHyphenate ( enum cdrTriState pVal ) {
    HRESULT _hr = put_AutoHyphenate(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(4513)
inline double VGCore::IVGTextRange::GetHyphenHotZone ( ) {
    double _result = 0;
    HRESULT _hr = get_HyphenHotZone(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4514)
inline void VGCore::IVGTextRange::PutHyphenHotZone ( double pVal ) {
    HRESULT _hr = put_HyphenHotZone(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(4515)
inline long VGCore::IVGTextRange::GetHyphenMinCharsBefore ( ) {
    long _result = 0;
    HRESULT _hr = get_HyphenMinCharsBefore(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4516)
inline void VGCore::IVGTextRange::PutHyphenMinCharsBefore ( long pVal ) {
    HRESULT _hr = put_HyphenMinCharsBefore(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(4517)
inline long VGCore::IVGTextRange::GetHyphenMinCharsAfter ( ) {
    long _result = 0;
    HRESULT _hr = get_HyphenMinCharsAfter(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4518)
inline void VGCore::IVGTextRange::PutHyphenMinCharsAfter ( long pVal ) {
    HRESULT _hr = put_HyphenMinCharsAfter(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(4519)
inline long VGCore::IVGTextRange::GetHyphenMinWordLength ( ) {
    long _result = 0;
    HRESULT _hr = get_HyphenMinWordLength(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4520)
inline void VGCore::IVGTextRange::PutHyphenMinWordLength ( long pVal ) {
    HRESULT _hr = put_HyphenMinWordLength(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(4521)
inline VARIANT_BOOL VGCore::IVGTextRange::GetHyphenateCapitals ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_HyphenateCapitals(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4522)
inline void VGCore::IVGTextRange::PutHyphenateCapitals ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_HyphenateCapitals(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(4523)
inline HRESULT VGCore::IVGTextRange::Delete ( ) {
    HRESULT _hr = raw_Delete();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(4524)
inline HRESULT VGCore::IVGTextRange::Select ( ) {
    HRESULT _hr = raw_Select();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(4525)
inline HRESULT VGCore::IVGTextRange::Copy ( ) {
    HRESULT _hr = raw_Copy();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(4526)
inline VGCore::IVGTextRangePtr VGCore::IVGTextRange::Paste ( ) {
    struct IVGTextRange * _result = 0;
    HRESULT _hr = raw_Paste(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGTextRangePtr(_result, false);
}

#pragma implementation_key(4527)
inline HRESULT VGCore::IVGTextRange::ChangeCase ( enum cdrTextChangeCase Case ) {
    HRESULT _hr = raw_ChangeCase(Case);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(4528)
inline HRESULT VGCore::IVGTextRange::SetRange ( long Start, long End ) {
    HRESULT _hr = raw_SetRange(Start, End);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(4529)
inline enum VGCore::cdrTextLanguage VGCore::IVGTextRange::GetLanguageID ( ) {
    enum cdrTextLanguage _result;
    HRESULT _hr = get_LanguageID(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4530)
inline void VGCore::IVGTextRange::PutLanguageID ( enum cdrTextLanguage pVal ) {
    HRESULT _hr = put_LanguageID(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(4531)
inline enum VGCore::cdrTextCharSet VGCore::IVGTextRange::GetCharSet ( ) {
    enum cdrTextCharSet _result;
    HRESULT _hr = get_CharSet(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4532)
inline void VGCore::IVGTextRange::PutCharSet ( enum cdrTextCharSet pVal ) {
    HRESULT _hr = put_CharSet(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(4533)
inline VGCore::IVGTextRangePtr VGCore::IVGTextRange::InsertBefore ( _bstr_t Text, enum cdrTextLanguage LanguageID, enum cdrTextCharSet CharSet, _bstr_t Font ) {
    struct IVGTextRange * _result = 0;
    HRESULT _hr = raw_InsertBefore(Text, LanguageID, CharSet, Font, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGTextRangePtr(_result, false);
}

#pragma implementation_key(4534)
inline VGCore::IVGTextRangePtr VGCore::IVGTextRange::InsertBeforeWide ( _bstr_t Text, enum cdrTextLanguage LanguageID, enum cdrTextCharSet CharSet, _bstr_t Font ) {
    struct IVGTextRange * _result = 0;
    HRESULT _hr = raw_InsertBeforeWide(Text, LanguageID, CharSet, Font, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGTextRangePtr(_result, false);
}

#pragma implementation_key(4535)
inline VGCore::IVGTextRangePtr VGCore::IVGTextRange::InsertAfter ( _bstr_t Text, enum cdrTextLanguage LanguageID, enum cdrTextCharSet CharSet, _bstr_t Font ) {
    struct IVGTextRange * _result = 0;
    HRESULT _hr = raw_InsertAfter(Text, LanguageID, CharSet, Font, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGTextRangePtr(_result, false);
}

#pragma implementation_key(4536)
inline VGCore::IVGTextRangePtr VGCore::IVGTextRange::InsertAfterWide ( _bstr_t Text, enum cdrTextLanguage LanguageID, enum cdrTextCharSet CharSet, _bstr_t Font ) {
    struct IVGTextRange * _result = 0;
    HRESULT _hr = raw_InsertAfterWide(Text, LanguageID, CharSet, Font, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGTextRangePtr(_result, false);
}

#pragma implementation_key(4537)
inline VGCore::IVGTextRangePtr VGCore::IVGTextRange::Replace ( _bstr_t Text, enum cdrTextLanguage LanguageID, enum cdrTextCharSet CharSet, _bstr_t Font ) {
    struct IVGTextRange * _result = 0;
    HRESULT _hr = raw_Replace(Text, LanguageID, CharSet, Font, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGTextRangePtr(_result, false);
}

#pragma implementation_key(4538)
inline VGCore::IVGTextRangePtr VGCore::IVGTextRange::ReplaceWide ( _bstr_t Text, enum cdrTextLanguage LanguageID, enum cdrTextCharSet CharSet, _bstr_t Font ) {
    struct IVGTextRange * _result = 0;
    HRESULT _hr = raw_ReplaceWide(Text, LanguageID, CharSet, Font, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGTextRangePtr(_result, false);
}

#pragma implementation_key(4539)
inline VGCore::IVGTextRangePtr VGCore::IVGTextRange::Range ( long Start, long End ) {
    struct IVGTextRange * _result = 0;
    HRESULT _hr = raw_Range(Start, End, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGTextRangePtr(_result, false);
}

#pragma implementation_key(4540)
inline HRESULT VGCore::IVGTextRange::SetLineSpacing ( enum cdrLineSpacingType Type, float LineSpacing, float ParaBefore, float ParaAfter ) {
    HRESULT _hr = raw_SetLineSpacing(Type, LineSpacing, ParaBefore, ParaAfter);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(4541)
inline VGCore::IVGTextColumnsPtr VGCore::IVGTextRange::GetColumns ( ) {
    struct IVGTextColumns * _result = 0;
    HRESULT _hr = get_Columns(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGTextColumnsPtr(_result, false);
}

#pragma implementation_key(4542)
inline VGCore::IVGTextFramesPtr VGCore::IVGTextRange::GetFrames ( ) {
    struct IVGTextFrames * _result = 0;
    HRESULT _hr = get_Frames(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGTextFramesPtr(_result, false);
}

#pragma implementation_key(4543)
inline HRESULT VGCore::IVGTextRange::Collapse ( VARIANT_BOOL ToEnd ) {
    HRESULT _hr = raw_Collapse(ToEnd);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(4544)
inline HRESULT VGCore::IVGTextRange::Combine ( struct IVGTextRange * Range ) {
    HRESULT _hr = raw_Combine(Range);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(4545)
inline VARIANT_BOOL VGCore::IVGTextRange::InRange ( struct IVGTextRange * Range ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_InRange(Range, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4546)
inline VARIANT_BOOL VGCore::IVGTextRange::IsSame ( struct IVGTextRange * Range ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_IsSame(Range, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4547)
inline VGCore::IVGFillPtr VGCore::IVGTextRange::GetFill ( ) {
    struct IVGFill * _result = 0;
    HRESULT _hr = get_Fill(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGFillPtr(_result, false);
}

#pragma implementation_key(4548)
inline VGCore::IVGOutlinePtr VGCore::IVGTextRange::GetOutline ( ) {
    struct IVGOutline * _result = 0;
    HRESULT _hr = get_Outline(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGOutlinePtr(_result, false);
}

#pragma implementation_key(4549)
inline long VGCore::IVGTextRange::GetRangeKerning ( ) {
    long _result = 0;
    HRESULT _hr = get_RangeKerning(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4550)
inline void VGCore::IVGTextRange::PutRangeKerning ( long pVal ) {
    HRESULT _hr = put_RangeKerning(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(4551)
inline VGCore::IVGTextTabPositionsPtr VGCore::IVGTextRange::GetTabs ( ) {
    struct IVGTextTabPositions * _result = 0;
    HRESULT _hr = get_Tabs(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGTextTabPositionsPtr(_result, false);
}

#pragma implementation_key(4552)
inline enum VGCore::cdrTextEffect VGCore::IVGTextRange::GetEffect ( ) {
    enum cdrTextEffect _result;
    HRESULT _hr = get_Effect(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4553)
inline long VGCore::IVGTextRange::GetDropCapLinesDropped ( ) {
    long _result = 0;
    HRESULT _hr = get_DropCapLinesDropped(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4554)
inline void VGCore::IVGTextRange::PutDropCapLinesDropped ( long pVal ) {
    HRESULT _hr = put_DropCapLinesDropped(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(4555)
inline double VGCore::IVGTextRange::GetDropCapDistanceFromText ( ) {
    double _result = 0;
    HRESULT _hr = get_DropCapDistanceFromText(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4556)
inline void VGCore::IVGTextRange::PutDropCapDistanceFromText ( double pVal ) {
    HRESULT _hr = put_DropCapDistanceFromText(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(4557)
inline VARIANT_BOOL VGCore::IVGTextRange::GetDropCapHangingIndent ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_DropCapHangingIndent(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4558)
inline void VGCore::IVGTextRange::PutDropCapHangingIndent ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_DropCapHangingIndent(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(4559)
inline _bstr_t VGCore::IVGTextRange::GetBulletFont ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_BulletFont(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(4560)
inline void VGCore::IVGTextRange::PutBulletFont ( _bstr_t pVal ) {
    HRESULT _hr = put_BulletFont(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(4561)
inline _bstr_t VGCore::IVGTextRange::GetBulletSymbol ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_BulletSymbol(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(4562)
inline void VGCore::IVGTextRange::PutBulletSymbol ( _bstr_t pVal ) {
    HRESULT _hr = put_BulletSymbol(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(4563)
inline float VGCore::IVGTextRange::GetBulletSize ( ) {
    float _result = 0;
    HRESULT _hr = get_BulletSize(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4564)
inline void VGCore::IVGTextRange::PutBulletSize ( float pVal ) {
    HRESULT _hr = put_BulletSize(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(4565)
inline float VGCore::IVGTextRange::GetBulletBaselineShift ( ) {
    float _result = 0;
    HRESULT _hr = get_BulletBaselineShift(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4566)
inline void VGCore::IVGTextRange::PutBulletBaselineShift ( float pVal ) {
    HRESULT _hr = put_BulletBaselineShift(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(4567)
inline double VGCore::IVGTextRange::GetBulletHorizontalPosition ( ) {
    double _result = 0;
    HRESULT _hr = get_BulletHorizontalPosition(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4568)
inline void VGCore::IVGTextRange::PutBulletHorizontalPosition ( double pVal ) {
    HRESULT _hr = put_BulletHorizontalPosition(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(4569)
inline VARIANT_BOOL VGCore::IVGTextRange::GetBulletHangingIndent ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_BulletHangingIndent(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4570)
inline void VGCore::IVGTextRange::PutBulletHangingIndent ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_BulletHangingIndent(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(4571)
inline VARIANT_BOOL VGCore::IVGTextRange::GetIsEmpty ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsEmpty(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4572)
inline HRESULT VGCore::IVGTextRange::ApplyNoEffect ( ) {
    HRESULT _hr = raw_ApplyNoEffect();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(4573)
inline HRESULT VGCore::IVGTextRange::ApplyBulletEffect ( _bstr_t Symbol, _bstr_t Font, float Size, float BaselineShift, double HorizontalPosition, VARIANT_BOOL HangingIndent ) {
    HRESULT _hr = raw_ApplyBulletEffect(Symbol, Font, Size, BaselineShift, HorizontalPosition, HangingIndent);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(4574)
inline HRESULT VGCore::IVGTextRange::ApplyDropCapEffect ( long LinesDropped, double DistanceFromText, VARIANT_BOOL HangingIndent ) {
    HRESULT _hr = raw_ApplyDropCapEffect(LinesDropped, DistanceFromText, HangingIndent);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(4575)
inline VARIANT_BOOL VGCore::IVGTextRange::GetHyphenateAllCapWords ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_HyphenateAllCapWords(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4576)
inline void VGCore::IVGTextRange::PutHyphenateAllCapWords ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_HyphenateAllCapWords(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(4577)
inline VGCore::IVGTextRangesPtr VGCore::IVGTextRange::EnumRanges ( enum cdrTextPropertySet PropertyFilter ) {
    struct IVGTextRanges * _result = 0;
    HRESULT _hr = raw_EnumRanges(PropertyFilter, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGTextRangesPtr(_result, false);
}

#pragma implementation_key(4578)
inline _variant_t VGCore::IVGTextRange::Evaluate ( _bstr_t Expression ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = raw_Evaluate(Expression, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

#pragma implementation_key(4579)
inline VGCore::IVGTextRangesPtr VGCore::IVGTextRange::FindRanges ( _bstr_t Query ) {
    struct IVGTextRanges * _result = 0;
    HRESULT _hr = raw_FindRanges(Query, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGTextRangesPtr(_result, false);
}

#pragma implementation_key(4580)
inline VGCore::IVGCurvePtr VGCore::IVGTextRange::GetBaselines ( ) {
    struct IVGCurve * _result = 0;
    HRESULT _hr = get_Baselines(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGCurvePtr(_result, false);
}

#pragma implementation_key(4581)
inline HRESULT VGCore::IVGTextRange::Straighten ( ) {
    HRESULT _hr = raw_Straighten();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(4582)
inline HRESULT VGCore::IVGTextRange::AlignToBaseline ( ) {
    HRESULT _hr = raw_AlignToBaseline();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(4583)
inline VGCore::IVGCurvePtr VGCore::IVGTextRange::GetTextLineRects ( ) {
    struct IVGCurve * _result = 0;
    HRESULT _hr = get_TextLineRects(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGCurvePtr(_result, false);
}

#pragma implementation_key(4584)
inline VGCore::IVGFillPtr VGCore::IVGTextRange::GetCharBackFill ( ) {
    struct IVGFill * _result = 0;
    HRESULT _hr = get_CharBackFill(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGFillPtr(_result, false);
}

#pragma implementation_key(4585)
inline HRESULT VGCore::IVGTextRange::CopyAttributes ( struct IVGTextRange * SourceRange ) {
    HRESULT _hr = raw_CopyAttributes(SourceRange);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(4586)
inline long VGCore::IVGTextRange::GetOpenTypeFeature ( _bstr_t Feature ) {
    long _result = 0;
    HRESULT _hr = raw_GetOpenTypeFeature(Feature, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4587)
inline HRESULT VGCore::IVGTextRange::SetOpenTypeFeature ( _bstr_t Feature, long State ) {
    HRESULT _hr = raw_SetOpenTypeFeature(Feature, State);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(4588)
inline long VGCore::IVGTextRange::GetTextFormatter ( ) {
    long _result = 0;
    HRESULT _hr = get_TextFormatter(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4589)
inline void VGCore::IVGTextRange::PutTextFormatter ( long pVal ) {
    HRESULT _hr = put_TextFormatter(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(4590)
inline HRESULT VGCore::IVGTextRange::ApplyStyle ( _bstr_t StyleName ) {
    HRESULT _hr = raw_ApplyStyle(StyleName);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(4591)
inline VGCore::IVGStylePtr VGCore::IVGTextRange::GetObjectStyle ( ) {
    struct IVGStyle * _result = 0;
    HRESULT _hr = get_ObjectStyle(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGStylePtr(_result, false);
}

#pragma implementation_key(4592)
inline VGCore::IVGTextIndentLevelStylesPtr VGCore::IVGTextRange::GetIndentLevelStyles ( ) {
    struct IVGTextIndentLevelStyles * _result = 0;
    HRESULT _hr = get_IndentLevelStyles(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGTextIndentLevelStylesPtr(_result, false);
}

#pragma implementation_key(4593)
inline long VGCore::IVGTextRange::GetIndentLevel ( ) {
    long _result = 0;
    HRESULT _hr = get_IndentLevel(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4594)
inline void VGCore::IVGTextRange::PutIndentLevel ( long pVal ) {
    HRESULT _hr = put_IndentLevel(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(4595)
inline VGCore::IVGTextVariableAxesPtr VGCore::IVGTextRange::GetVariableAxes ( ) {
    struct IVGTextVariableAxes * _result = 0;
    HRESULT _hr = get_VariableAxes(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGTextVariableAxesPtr(_result, false);
}

//
// interface IVGTextCharacters wrapper method implementations
//

#pragma implementation_key(4596)
inline IUnknownPtr VGCore::IVGTextCharacters::Get_NewEnum ( ) {
    IUnknown * _result = 0;
    HRESULT _hr = get__NewEnum(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IUnknownPtr(_result, false);
}

#pragma implementation_key(4597)
inline VGCore::IVGTextRangePtr VGCore::IVGTextCharacters::GetItem ( long Index, long Count ) {
    struct IVGTextRange * _result = 0;
    HRESULT _hr = get_Item(Index, Count, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGTextRangePtr(_result, false);
}

#pragma implementation_key(4598)
inline long VGCore::IVGTextCharacters::GetCount ( ) {
    long _result = 0;
    HRESULT _hr = get_Count(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4599)
inline VGCore::IVGTextRangePtr VGCore::IVGTextCharacters::GetAll ( ) {
    struct IVGTextRange * _result = 0;
    HRESULT _hr = get_All(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGTextRangePtr(_result, false);
}

#pragma implementation_key(4600)
inline VGCore::IVGTextRangePtr VGCore::IVGTextCharacters::GetFirst ( ) {
    struct IVGTextRange * _result = 0;
    HRESULT _hr = get_First(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGTextRangePtr(_result, false);
}

#pragma implementation_key(4601)
inline VGCore::IVGTextRangePtr VGCore::IVGTextCharacters::GetLast ( ) {
    struct IVGTextRange * _result = 0;
    HRESULT _hr = get_Last(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGTextRangePtr(_result, false);
}

//
// interface IVGTextWords wrapper method implementations
//

#pragma implementation_key(4602)
inline IUnknownPtr VGCore::IVGTextWords::Get_NewEnum ( ) {
    IUnknown * _result = 0;
    HRESULT _hr = get__NewEnum(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IUnknownPtr(_result, false);
}

#pragma implementation_key(4603)
inline VGCore::IVGTextRangePtr VGCore::IVGTextWords::GetItem ( long Index, long Count ) {
    struct IVGTextRange * _result = 0;
    HRESULT _hr = get_Item(Index, Count, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGTextRangePtr(_result, false);
}

#pragma implementation_key(4604)
inline long VGCore::IVGTextWords::GetCount ( ) {
    long _result = 0;
    HRESULT _hr = get_Count(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4605)
inline VGCore::IVGTextRangePtr VGCore::IVGTextWords::GetAll ( ) {
    struct IVGTextRange * _result = 0;
    HRESULT _hr = get_All(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGTextRangePtr(_result, false);
}

#pragma implementation_key(4606)
inline VGCore::IVGTextRangePtr VGCore::IVGTextWords::GetFirst ( ) {
    struct IVGTextRange * _result = 0;
    HRESULT _hr = get_First(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGTextRangePtr(_result, false);
}

#pragma implementation_key(4607)
inline VGCore::IVGTextRangePtr VGCore::IVGTextWords::GetLast ( ) {
    struct IVGTextRange * _result = 0;
    HRESULT _hr = get_Last(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGTextRangePtr(_result, false);
}

//
// interface IVGTextLines wrapper method implementations
//

#pragma implementation_key(4608)
inline IUnknownPtr VGCore::IVGTextLines::Get_NewEnum ( ) {
    IUnknown * _result = 0;
    HRESULT _hr = get__NewEnum(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IUnknownPtr(_result, false);
}

#pragma implementation_key(4609)
inline VGCore::IVGTextRangePtr VGCore::IVGTextLines::GetItem ( long Index, long Count ) {
    struct IVGTextRange * _result = 0;
    HRESULT _hr = get_Item(Index, Count, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGTextRangePtr(_result, false);
}

#pragma implementation_key(4610)
inline long VGCore::IVGTextLines::GetCount ( ) {
    long _result = 0;
    HRESULT _hr = get_Count(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4611)
inline VGCore::IVGTextRangePtr VGCore::IVGTextLines::GetAll ( ) {
    struct IVGTextRange * _result = 0;
    HRESULT _hr = get_All(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGTextRangePtr(_result, false);
}

#pragma implementation_key(4612)
inline VGCore::IVGTextRangePtr VGCore::IVGTextLines::GetFirst ( ) {
    struct IVGTextRange * _result = 0;
    HRESULT _hr = get_First(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGTextRangePtr(_result, false);
}

#pragma implementation_key(4613)
inline VGCore::IVGTextRangePtr VGCore::IVGTextLines::GetLast ( ) {
    struct IVGTextRange * _result = 0;
    HRESULT _hr = get_Last(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGTextRangePtr(_result, false);
}

//
// interface IVGTextParagraphs wrapper method implementations
//

#pragma implementation_key(4614)
inline IUnknownPtr VGCore::IVGTextParagraphs::Get_NewEnum ( ) {
    IUnknown * _result = 0;
    HRESULT _hr = get__NewEnum(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IUnknownPtr(_result, false);
}

#pragma implementation_key(4615)
inline VGCore::IVGTextRangePtr VGCore::IVGTextParagraphs::GetItem ( long Index, long Count ) {
    struct IVGTextRange * _result = 0;
    HRESULT _hr = get_Item(Index, Count, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGTextRangePtr(_result, false);
}

#pragma implementation_key(4616)
inline long VGCore::IVGTextParagraphs::GetCount ( ) {
    long _result = 0;
    HRESULT _hr = get_Count(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4617)
inline VGCore::IVGTextRangePtr VGCore::IVGTextParagraphs::GetAll ( ) {
    struct IVGTextRange * _result = 0;
    HRESULT _hr = get_All(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGTextRangePtr(_result, false);
}

#pragma implementation_key(4618)
inline VGCore::IVGTextRangePtr VGCore::IVGTextParagraphs::GetFirst ( ) {
    struct IVGTextRange * _result = 0;
    HRESULT _hr = get_First(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGTextRangePtr(_result, false);
}

#pragma implementation_key(4619)
inline VGCore::IVGTextRangePtr VGCore::IVGTextParagraphs::GetLast ( ) {
    struct IVGTextRange * _result = 0;
    HRESULT _hr = get_Last(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGTextRangePtr(_result, false);
}

//
// interface IVGTextColumns wrapper method implementations
//

#pragma implementation_key(4620)
inline IUnknownPtr VGCore::IVGTextColumns::Get_NewEnum ( ) {
    IUnknown * _result = 0;
    HRESULT _hr = get__NewEnum(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IUnknownPtr(_result, false);
}

#pragma implementation_key(4621)
inline VGCore::IVGTextRangePtr VGCore::IVGTextColumns::GetItem ( long Index, long Count ) {
    struct IVGTextRange * _result = 0;
    HRESULT _hr = get_Item(Index, Count, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGTextRangePtr(_result, false);
}

#pragma implementation_key(4622)
inline long VGCore::IVGTextColumns::GetCount ( ) {
    long _result = 0;
    HRESULT _hr = get_Count(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4623)
inline VGCore::IVGTextRangePtr VGCore::IVGTextColumns::GetAll ( ) {
    struct IVGTextRange * _result = 0;
    HRESULT _hr = get_All(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGTextRangePtr(_result, false);
}

#pragma implementation_key(4624)
inline VGCore::IVGTextRangePtr VGCore::IVGTextColumns::GetFirst ( ) {
    struct IVGTextRange * _result = 0;
    HRESULT _hr = get_First(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGTextRangePtr(_result, false);
}

#pragma implementation_key(4625)
inline VGCore::IVGTextRangePtr VGCore::IVGTextColumns::GetLast ( ) {
    struct IVGTextRange * _result = 0;
    HRESULT _hr = get_Last(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGTextRangePtr(_result, false);
}

//
// interface IVGTextFrame wrapper method implementations
//

#pragma implementation_key(4626)
inline VGCore::IVGTextRangePtr VGCore::IVGTextFrame::GetRange ( ) {
    struct IVGTextRange * _result = 0;
    HRESULT _hr = get_Range(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGTextRangePtr(_result, false);
}

#pragma implementation_key(4627)
inline VGCore::IVGTextFramePtr VGCore::IVGTextFrame::GetPrevious ( ) {
    struct IVGTextFrame * _result = 0;
    HRESULT _hr = get_Previous(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGTextFramePtr(_result, false);
}

#pragma implementation_key(4628)
inline VGCore::IVGTextFramePtr VGCore::IVGTextFrame::GetNext ( ) {
    struct IVGTextFrame * _result = 0;
    HRESULT _hr = get_Next(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGTextFramePtr(_result, false);
}

#pragma implementation_key(4629)
inline long VGCore::IVGTextFrame::GetIndex ( ) {
    long _result = 0;
    HRESULT _hr = get_Index(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4630)
inline VARIANT_BOOL VGCore::IVGTextFrame::GetEmpty ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_Empty(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4631)
inline VARIANT_BOOL VGCore::IVGTextFrame::GetIsFirst ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsFirst(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4632)
inline VARIANT_BOOL VGCore::IVGTextFrame::GetIsLast ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsLast(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4633)
inline enum VGCore::cdrVerticalAlignment VGCore::IVGTextFrame::GetVerticalAlignment ( ) {
    enum cdrVerticalAlignment _result;
    HRESULT _hr = get_VerticalAlignment(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4634)
inline void VGCore::IVGTextFrame::PutVerticalAlignment ( enum cdrVerticalAlignment pVal ) {
    HRESULT _hr = put_VerticalAlignment(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(4635)
inline VARIANT_BOOL VGCore::IVGTextFrame::GetMulticolumn ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_Multicolumn(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4636)
inline long VGCore::IVGTextFrame::GetColumnCount ( ) {
    long _result = 0;
    HRESULT _hr = get_ColumnCount(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4637)
inline double VGCore::IVGTextFrame::GetColumnWidth ( long Index ) {
    double _result = 0;
    HRESULT _hr = get_ColumnWidth(Index, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4638)
inline double VGCore::IVGTextFrame::GetColumnGutter ( long Index ) {
    double _result = 0;
    HRESULT _hr = get_ColumnGutter(Index, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4639)
inline HRESULT VGCore::IVGTextFrame::SetColumns ( long NumColumns, VARIANT_BOOL EqualColumns, SAFEARRAY * * WidthsAndGutters ) {
    HRESULT _hr = raw_SetColumns(NumColumns, EqualColumns, WidthsAndGutters);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(4640)
inline HRESULT VGCore::IVGTextFrame::LinkTo ( struct IVGShape * Shape ) {
    HRESULT _hr = raw_LinkTo(Shape);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(4641)
inline HRESULT VGCore::IVGTextFrame::UnLink ( ) {
    HRESULT _hr = raw_UnLink();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(4642)
inline VGCore::IVGShapePtr VGCore::IVGTextFrame::GetContainer ( ) {
    struct IVGShape * _result = 0;
    HRESULT _hr = get_Container(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGShapePtr(_result, false);
}

#pragma implementation_key(4643)
inline VARIANT_BOOL VGCore::IVGTextFrame::GetIsInsideContainer ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsInsideContainer(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4644)
inline VARIANT_BOOL VGCore::IVGTextFrame::GetIsFittedToPath ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsFittedToPath(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4645)
inline VGCore::IVGShapePtr VGCore::IVGTextFrame::GetPath ( ) {
    struct IVGShape * _result = 0;
    HRESULT _hr = get_Path(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGShapePtr(_result, false);
}

#pragma implementation_key(4646)
inline VGCore::IVGShapePtr VGCore::IVGTextFrame::GetFrameShape ( ) {
    struct IVGShape * _result = 0;
    HRESULT _hr = get_FrameShape(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGShapePtr(_result, false);
}

#pragma implementation_key(4647)
inline VGCore::IVGFillPtr VGCore::IVGTextFrame::GetFill ( ) {
    struct IVGFill * _result = 0;
    HRESULT _hr = get_Fill(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGFillPtr(_result, false);
}

#pragma implementation_key(4648)
inline void VGCore::IVGTextFrame::PutFill ( struct IVGFill * ppVal ) {
    HRESULT _hr = put_Fill(ppVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(4649)
inline VGCore::IVGOutlinePtr VGCore::IVGTextFrame::GetOutline ( ) {
    struct IVGOutline * _result = 0;
    HRESULT _hr = get_Outline(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGOutlinePtr(_result, false);
}

#pragma implementation_key(4650)
inline void VGCore::IVGTextFrame::PutOutline ( struct IVGOutline * ppVal ) {
    HRESULT _hr = put_Outline(ppVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IVGTextFrames wrapper method implementations
//

#pragma implementation_key(4651)
inline IUnknownPtr VGCore::IVGTextFrames::Get_NewEnum ( ) {
    IUnknown * _result = 0;
    HRESULT _hr = get__NewEnum(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IUnknownPtr(_result, false);
}

#pragma implementation_key(4652)
inline VGCore::IVGTextFramePtr VGCore::IVGTextFrames::GetItem ( long Index ) {
    struct IVGTextFrame * _result = 0;
    HRESULT _hr = get_Item(Index, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGTextFramePtr(_result, false);
}

#pragma implementation_key(4653)
inline long VGCore::IVGTextFrames::GetCount ( ) {
    long _result = 0;
    HRESULT _hr = get_Count(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4654)
inline VGCore::IVGTextRangePtr VGCore::IVGTextFrames::GetRange ( long Index, long Count ) {
    struct IVGTextRange * _result = 0;
    HRESULT _hr = get_Range(Index, Count, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGTextRangePtr(_result, false);
}

#pragma implementation_key(4655)
inline VGCore::IVGTextRangePtr VGCore::IVGTextFrames::GetAll ( ) {
    struct IVGTextRange * _result = 0;
    HRESULT _hr = get_All(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGTextRangePtr(_result, false);
}

#pragma implementation_key(4656)
inline VGCore::IVGTextFramePtr VGCore::IVGTextFrames::GetFirst ( ) {
    struct IVGTextFrame * _result = 0;
    HRESULT _hr = get_First(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGTextFramePtr(_result, false);
}

#pragma implementation_key(4657)
inline VGCore::IVGTextFramePtr VGCore::IVGTextFrames::GetLast ( ) {
    struct IVGTextFrame * _result = 0;
    HRESULT _hr = get_Last(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGTextFramePtr(_result, false);
}

//
// interface IVGTextRanges wrapper method implementations
//

#pragma implementation_key(4658)
inline IUnknownPtr VGCore::IVGTextRanges::Get_NewEnum ( ) {
    IUnknown * _result = 0;
    HRESULT _hr = get__NewEnum(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IUnknownPtr(_result, false);
}

#pragma implementation_key(4659)
inline VGCore::IVGTextRangePtr VGCore::IVGTextRanges::GetItem ( long Index ) {
    struct IVGTextRange * _result = 0;
    HRESULT _hr = get_Item(Index, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGTextRangePtr(_result, false);
}

#pragma implementation_key(4660)
inline long VGCore::IVGTextRanges::GetCount ( ) {
    long _result = 0;
    HRESULT _hr = get_Count(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4661)
inline VGCore::IVGTextRangePtr VGCore::IVGTextRanges::GetFirst ( ) {
    struct IVGTextRange * _result = 0;
    HRESULT _hr = get_First(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGTextRangePtr(_result, false);
}

#pragma implementation_key(4662)
inline VGCore::IVGTextRangePtr VGCore::IVGTextRanges::GetLast ( ) {
    struct IVGTextRange * _result = 0;
    HRESULT _hr = get_Last(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGTextRangePtr(_result, false);
}

#pragma implementation_key(4663)
inline VGCore::IVGTextRangesPtr VGCore::IVGTextRanges::Reverse ( ) {
    struct IVGTextRanges * _result = 0;
    HRESULT _hr = raw_Reverse(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGTextRangesPtr(_result, false);
}

//
// interface IVGStyle wrapper method implementations
//

#pragma implementation_key(4664)
inline _bstr_t VGCore::IVGStyle::GetCategoryName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_CategoryName(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(4665)
inline SAFEARRAY * VGCore::IVGStyle::GetAllPropertyNames ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_GetAllPropertyNames(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4666)
inline SAFEARRAY * VGCore::IVGStyle::GetOverridePropertyNames ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = raw_GetOverridePropertyNames(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4667)
inline VARIANT_BOOL VGCore::IVGStyle::IsPropertyInherited ( _bstr_t Name ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_IsPropertyInherited(Name, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4668)
inline _variant_t VGCore::IVGStyle::GetProperty ( _bstr_t Name ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = raw_GetProperty(Name, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

#pragma implementation_key(4669)
inline HRESULT VGCore::IVGStyle::SetProperty ( _bstr_t Name, const _variant_t & Value ) {
    HRESULT _hr = raw_SetProperty(Name, Value);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(4670)
inline VARIANT_BOOL VGCore::IVGStyle::ClearProperty ( _bstr_t Name ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_ClearProperty(Name, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4671)
inline VGCore::IVGStyleOutlinePtr VGCore::IVGStyle::GetOutline ( ) {
    struct IVGStyleOutline * _result = 0;
    HRESULT _hr = get_Outline(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGStyleOutlinePtr(_result, false);
}

#pragma implementation_key(4672)
inline VGCore::IVGStyleFillPtr VGCore::IVGStyle::GetFill ( ) {
    struct IVGStyleFill * _result = 0;
    HRESULT _hr = get_Fill(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGStyleFillPtr(_result, false);
}

#pragma implementation_key(4673)
inline VGCore::IVGStyleCharacterPtr VGCore::IVGStyle::GetCharacter ( ) {
    struct IVGStyleCharacter * _result = 0;
    HRESULT _hr = get_Character(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGStyleCharacterPtr(_result, false);
}

#pragma implementation_key(4674)
inline VGCore::IVGStyleParagraphPtr VGCore::IVGStyle::GetParagraph ( ) {
    struct IVGStyleParagraph * _result = 0;
    HRESULT _hr = get_Paragraph(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGStyleParagraphPtr(_result, false);
}

#pragma implementation_key(4675)
inline VGCore::IVGStyleFramePtr VGCore::IVGStyle::GetFrame ( ) {
    struct IVGStyleFrame * _result = 0;
    HRESULT _hr = get_Frame(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGStyleFramePtr(_result, false);
}

#pragma implementation_key(4676)
inline _bstr_t VGCore::IVGStyle::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(4677)
inline _bstr_t VGCore::IVGStyle::GetDisplayName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_DisplayName(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(4678)
inline VARIANT_BOOL VGCore::IVGStyle::GetIsStyleSet ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsStyleSet(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4679)
inline VARIANT_BOOL VGCore::IVGStyle::GetIsObjectDefaults ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsObjectDefaults(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4680)
inline _bstr_t VGCore::IVGStyle::GetDisplayCategoryName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_DisplayCategoryName(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(4681)
inline VGCore::IVGStylePtr VGCore::IVGStyle::GetBasedOn ( ) {
    struct IVGStyle * _result = 0;
    HRESULT _hr = get_BasedOn(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGStylePtr(_result, false);
}

#pragma implementation_key(4682)
inline VGCore::IVGStylesPtr VGCore::IVGStyle::GetDerivedStyles ( ) {
    struct IVGStyles * _result = 0;
    HRESULT _hr = get_DerivedStyles(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGStylesPtr(_result, false);
}

#pragma implementation_key(4683)
inline _bstr_t VGCore::IVGStyle::ToString ( ) {
    BSTR _result = 0;
    HRESULT _hr = raw_ToString(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(4684)
inline VARIANT_BOOL VGCore::IVGStyle::StringAssign ( _bstr_t StyleString ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_StringAssign(StyleString, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4685)
inline _bstr_t VGCore::IVGStyle::GetPropertyAsString ( _bstr_t Name ) {
    BSTR _result = 0;
    HRESULT _hr = raw_GetPropertyAsString(Name, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(4686)
inline VARIANT_BOOL VGCore::IVGStyle::SetPropertyAsString ( _bstr_t Name, _bstr_t Value ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_SetPropertyAsString(Name, Value, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4687)
inline VARIANT_BOOL VGCore::IVGStyle::Rename ( _bstr_t NewName ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_Rename(NewName, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4688)
inline VARIANT_BOOL VGCore::IVGStyle::SetBasedOn ( _bstr_t NewParent ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_SetBasedOn(NewParent, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4689)
inline VARIANT_BOOL VGCore::IVGStyle::Delete ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_Delete(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4690)
inline HRESULT VGCore::IVGStyle::Assign ( struct IVGStyle * pVal ) {
    HRESULT _hr = raw_Assign(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(4691)
inline VGCore::IVGStylePtr VGCore::IVGStyle::GetCopy ( ) {
    struct IVGStyle * _result = 0;
    HRESULT _hr = raw_GetCopy(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGStylePtr(_result, false);
}

#pragma implementation_key(4692)
inline VGCore::IVGStyleTransparencyPtr VGCore::IVGStyle::GetTransparency ( ) {
    struct IVGStyleTransparency * _result = 0;
    HRESULT _hr = get_Transparency(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGStyleTransparencyPtr(_result, false);
}

//
// interface IVGStyleOutline wrapper method implementations
//

#pragma implementation_key(4693)
inline VGCore::IVGStylePtr VGCore::IVGStyleOutline::GetStyle ( ) {
    struct IVGStyle * _result = 0;
    HRESULT _hr = get_Style(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGStylePtr(_result, false);
}

#pragma implementation_key(4694)
inline enum VGCore::cdrOutlineType VGCore::IVGStyleOutline::GetType ( ) {
    enum cdrOutlineType _result;
    HRESULT _hr = get_Type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4695)
inline void VGCore::IVGStyleOutline::PutType ( enum cdrOutlineType pVal ) {
    HRESULT _hr = put_Type(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(4696)
inline VARIANT_BOOL VGCore::IVGStyleOutline::GetOverprint ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_Overprint(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4697)
inline void VGCore::IVGStyleOutline::PutOverprint ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_Overprint(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(4698)
inline VARIANT_BOOL VGCore::IVGStyleOutline::GetBehindFill ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_BehindFill(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4699)
inline void VGCore::IVGStyleOutline::PutBehindFill ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_BehindFill(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(4700)
inline VARIANT_BOOL VGCore::IVGStyleOutline::GetScaleWithShape ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_ScaleWithShape(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4701)
inline void VGCore::IVGStyleOutline::PutScaleWithShape ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_ScaleWithShape(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(4702)
inline double VGCore::IVGStyleOutline::GetWidth ( ) {
    double _result = 0;
    HRESULT _hr = get_Width(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4703)
inline void VGCore::IVGStyleOutline::PutWidth ( double pVal ) {
    HRESULT _hr = put_Width(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(4704)
inline VGCore::IVGColorPtr VGCore::IVGStyleOutline::GetColor ( ) {
    struct IVGColor * _result = 0;
    HRESULT _hr = get_Color(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGColorPtr(_result, false);
}

#pragma implementation_key(4705)
inline void VGCore::IVGStyleOutline::PutColor ( struct IVGColor * ppVal ) {
    HRESULT _hr = put_Color(ppVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(4706)
inline VARIANT_BOOL VGCore::IVGStyleOutline::GetOverlapArrow ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_OverlapArrow(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4707)
inline void VGCore::IVGStyleOutline::PutOverlapArrow ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_OverlapArrow(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(4708)
inline VARIANT_BOOL VGCore::IVGStyleOutline::GetShareArrow ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_ShareArrow(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4709)
inline void VGCore::IVGStyleOutline::PutShareArrow ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_ShareArrow(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(4710)
inline double VGCore::IVGStyleOutline::GetMiterLimit ( ) {
    double _result = 0;
    HRESULT _hr = get_MiterLimit(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4711)
inline void VGCore::IVGStyleOutline::PutMiterLimit ( double pVal ) {
    HRESULT _hr = put_MiterLimit(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(4712)
inline long VGCore::IVGStyleOutline::GetNibStretch ( ) {
    long _result = 0;
    HRESULT _hr = get_NibStretch(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4713)
inline void VGCore::IVGStyleOutline::PutNibStretch ( long pVal ) {
    HRESULT _hr = put_NibStretch(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(4714)
inline double VGCore::IVGStyleOutline::GetNibAngle ( ) {
    double _result = 0;
    HRESULT _hr = get_NibAngle(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4715)
inline void VGCore::IVGStyleOutline::PutNibAngle ( double pVal ) {
    HRESULT _hr = put_NibAngle(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(4716)
inline double VGCore::IVGStyleOutline::GetWidelineWidth ( ) {
    double _result = 0;
    HRESULT _hr = get_WidelineWidth(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4717)
inline void VGCore::IVGStyleOutline::PutWidelineWidth ( double pVal ) {
    HRESULT _hr = put_WidelineWidth(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(4718)
inline enum VGCore::cdrOutlineLineCaps VGCore::IVGStyleOutline::GetLineCaps ( ) {
    enum cdrOutlineLineCaps _result;
    HRESULT _hr = get_LineCaps(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4719)
inline void VGCore::IVGStyleOutline::PutLineCaps ( enum cdrOutlineLineCaps pVal ) {
    HRESULT _hr = put_LineCaps(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(4720)
inline enum VGCore::cdrOutlineLineJoin VGCore::IVGStyleOutline::GetLineJoin ( ) {
    enum cdrOutlineLineJoin _result;
    HRESULT _hr = get_LineJoin(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4721)
inline void VGCore::IVGStyleOutline::PutLineJoin ( enum cdrOutlineLineJoin pVal ) {
    HRESULT _hr = put_LineJoin(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(4722)
inline enum VGCore::cdrOutlineJustification VGCore::IVGStyleOutline::GetJustification ( ) {
    enum cdrOutlineJustification _result;
    HRESULT _hr = get_Justification(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4723)
inline void VGCore::IVGStyleOutline::PutJustification ( enum cdrOutlineJustification pVal ) {
    HRESULT _hr = put_Justification(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(4724)
inline enum VGCore::cdrOutlineDashAdjust VGCore::IVGStyleOutline::GetAdjustDashes ( ) {
    enum cdrOutlineDashAdjust _result;
    HRESULT _hr = get_AdjustDashes(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4725)
inline void VGCore::IVGStyleOutline::PutAdjustDashes ( enum cdrOutlineDashAdjust pVal ) {
    HRESULT _hr = put_AdjustDashes(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IVGStyleFill wrapper method implementations
//

#pragma implementation_key(4726)
inline VGCore::IVGStylePtr VGCore::IVGStyleFill::GetStyle ( ) {
    struct IVGStyle * _result = 0;
    HRESULT _hr = get_Style(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGStylePtr(_result, false);
}

#pragma implementation_key(4727)
inline enum VGCore::cdrFillStyleType VGCore::IVGStyleFill::GetType ( ) {
    enum cdrFillStyleType _result;
    HRESULT _hr = get_Type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4728)
inline void VGCore::IVGStyleFill::PutType ( enum cdrFillStyleType pVal ) {
    HRESULT _hr = put_Type(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(4729)
inline VARIANT_BOOL VGCore::IVGStyleFill::GetOverprint ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_Overprint(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4730)
inline void VGCore::IVGStyleFill::PutOverprint ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_Overprint(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(4731)
inline VARIANT_BOOL VGCore::IVGStyleFill::GetWindingFill ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_WindingFill(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4732)
inline void VGCore::IVGStyleFill::PutWindingFill ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_WindingFill(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(4733)
inline enum VGCore::cdrFountainFillType VGCore::IVGStyleFill::GetFountainFillType ( ) {
    enum cdrFountainFillType _result;
    HRESULT _hr = get_FountainFillType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4734)
inline void VGCore::IVGStyleFill::PutFountainFillType ( enum cdrFountainFillType pVal ) {
    HRESULT _hr = put_FountainFillType(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(4735)
inline long VGCore::IVGStyleFill::GetEdgePad ( ) {
    long _result = 0;
    HRESULT _hr = get_EdgePad(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4736)
inline void VGCore::IVGStyleFill::PutEdgePad ( long pVal ) {
    HRESULT _hr = put_EdgePad(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(4737)
inline long VGCore::IVGStyleFill::GetFountainCenterOffsetX ( ) {
    long _result = 0;
    HRESULT _hr = get_FountainCenterOffsetX(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4738)
inline void VGCore::IVGStyleFill::PutFountainCenterOffsetX ( long pVal ) {
    HRESULT _hr = put_FountainCenterOffsetX(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(4739)
inline long VGCore::IVGStyleFill::GetFountainCenterOffsetY ( ) {
    long _result = 0;
    HRESULT _hr = get_FountainCenterOffsetY(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4740)
inline void VGCore::IVGStyleFill::PutFountainCenterOffsetY ( long pVal ) {
    HRESULT _hr = put_FountainCenterOffsetY(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(4741)
inline long VGCore::IVGStyleFill::GetFountainSteps ( ) {
    long _result = 0;
    HRESULT _hr = get_FountainSteps(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4742)
inline void VGCore::IVGStyleFill::PutFountainSteps ( long pVal ) {
    HRESULT _hr = put_FountainSteps(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(4743)
inline enum VGCore::cdrFountainFillBlendType VGCore::IVGStyleFill::GetFountainBlendType ( ) {
    enum cdrFountainFillBlendType _result;
    HRESULT _hr = get_FountainBlendType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4744)
inline void VGCore::IVGStyleFill::PutFountainBlendType ( enum cdrFountainFillBlendType pVal ) {
    HRESULT _hr = put_FountainBlendType(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(4745)
inline long VGCore::IVGStyleFill::GetMidPoint ( ) {
    long _result = 0;
    HRESULT _hr = get_MidPoint(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4746)
inline void VGCore::IVGStyleFill::PutMidPoint ( long pVal ) {
    HRESULT _hr = put_MidPoint(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(4747)
inline VARIANT_BOOL VGCore::IVGStyleFill::GetFlipColors ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_FlipColors(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4748)
inline void VGCore::IVGStyleFill::PutFlipColors ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_FlipColors(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(4749)
inline _bstr_t VGCore::IVGStyleFill::GetPostScriptName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_PostScriptName(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(4750)
inline void VGCore::IVGStyleFill::PutPostScriptName ( _bstr_t pVal ) {
    HRESULT _hr = put_PostScriptName(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(4751)
inline double VGCore::IVGStyleFill::GetTileWidth ( ) {
    double _result = 0;
    HRESULT _hr = get_TileWidth(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4752)
inline void VGCore::IVGStyleFill::PutTileWidth ( double pVal ) {
    HRESULT _hr = put_TileWidth(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(4753)
inline double VGCore::IVGStyleFill::GetTileHeight ( ) {
    double _result = 0;
    HRESULT _hr = get_TileHeight(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4754)
inline void VGCore::IVGStyleFill::PutTileHeight ( double pVal ) {
    HRESULT _hr = put_TileHeight(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(4755)
inline double VGCore::IVGStyleFill::GetTileOriginX ( ) {
    double _result = 0;
    HRESULT _hr = get_TileOriginX(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4756)
inline void VGCore::IVGStyleFill::PutTileOriginX ( double pVal ) {
    HRESULT _hr = put_TileOriginX(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(4757)
inline double VGCore::IVGStyleFill::GetTileOriginY ( ) {
    double _result = 0;
    HRESULT _hr = get_TileOriginY(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4758)
inline void VGCore::IVGStyleFill::PutTileOriginY ( double pVal ) {
    HRESULT _hr = put_TileOriginY(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(4759)
inline enum VGCore::cdrTileOffsetType VGCore::IVGStyleFill::GetTileOffsetType ( ) {
    enum cdrTileOffsetType _result;
    HRESULT _hr = get_TileOffsetType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4760)
inline void VGCore::IVGStyleFill::PutTileOffsetType ( enum cdrTileOffsetType pVal ) {
    HRESULT _hr = put_TileOffsetType(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(4761)
inline long VGCore::IVGStyleFill::GetTileOffset ( ) {
    long _result = 0;
    HRESULT _hr = get_TileOffset(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4762)
inline void VGCore::IVGStyleFill::PutTileOffset ( long pVal ) {
    HRESULT _hr = put_TileOffset(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(4763)
inline double VGCore::IVGStyleFill::GetRotationAngle ( ) {
    double _result = 0;
    HRESULT _hr = get_RotationAngle(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4764)
inline void VGCore::IVGStyleFill::PutRotationAngle ( double pVal ) {
    HRESULT _hr = put_RotationAngle(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(4765)
inline double VGCore::IVGStyleFill::GetSkewAngle ( ) {
    double _result = 0;
    HRESULT _hr = get_SkewAngle(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4766)
inline void VGCore::IVGStyleFill::PutSkewAngle ( double pVal ) {
    HRESULT _hr = put_SkewAngle(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(4767)
inline VARIANT_BOOL VGCore::IVGStyleFill::GetMirrorFill ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_MirrorFill(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4768)
inline void VGCore::IVGStyleFill::PutMirrorFill ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_MirrorFill(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(4769)
inline VARIANT_BOOL VGCore::IVGStyleFill::GetTransformWithShape ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_TransformWithShape(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4770)
inline void VGCore::IVGStyleFill::PutTransformWithShape ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_TransformWithShape(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(4771)
inline VGCore::IVGColorPtr VGCore::IVGStyleFill::GetPrimaryColor ( ) {
    struct IVGColor * _result = 0;
    HRESULT _hr = get_PrimaryColor(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGColorPtr(_result, false);
}

#pragma implementation_key(4772)
inline VGCore::IVGColorPtr VGCore::IVGStyleFill::GetSecondaryColor ( ) {
    struct IVGColor * _result = 0;
    HRESULT _hr = get_SecondaryColor(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGColorPtr(_result, false);
}

#pragma implementation_key(4773)
inline VARIANT_BOOL VGCore::IVGStyleFill::GetMirrorFillX ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_MirrorFillX(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4774)
inline void VGCore::IVGStyleFill::PutMirrorFillX ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_MirrorFillX(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(4775)
inline VARIANT_BOOL VGCore::IVGStyleFill::GetMirrorFillY ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_MirrorFillY(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4776)
inline void VGCore::IVGStyleFill::PutMirrorFillY ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_MirrorFillY(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(4777)
inline double VGCore::IVGStyleFill::GetFountainCenterXOffset ( ) {
    double _result = 0;
    HRESULT _hr = get_FountainCenterXOffset(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4778)
inline void VGCore::IVGStyleFill::PutFountainCenterXOffset ( double pVal ) {
    HRESULT _hr = put_FountainCenterXOffset(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(4779)
inline double VGCore::IVGStyleFill::GetFountainCenterYOffset ( ) {
    double _result = 0;
    HRESULT _hr = get_FountainCenterYOffset(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4780)
inline void VGCore::IVGStyleFill::PutFountainCenterYOffset ( double pVal ) {
    HRESULT _hr = put_FountainCenterYOffset(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(4781)
inline double VGCore::IVGStyleFill::GetFountainBlendAcceleration ( ) {
    double _result = 0;
    HRESULT _hr = get_FountainBlendAcceleration(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4782)
inline void VGCore::IVGStyleFill::PutFountainBlendAcceleration ( double pVal ) {
    HRESULT _hr = put_FountainBlendAcceleration(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(4783)
inline double VGCore::IVGStyleFill::GetFountainScaleX ( ) {
    double _result = 0;
    HRESULT _hr = get_FountainScaleX(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4784)
inline void VGCore::IVGStyleFill::PutFountainScaleX ( double pVal ) {
    HRESULT _hr = put_FountainScaleX(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(4785)
inline double VGCore::IVGStyleFill::GetFountainScaleY ( ) {
    double _result = 0;
    HRESULT _hr = get_FountainScaleY(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4786)
inline void VGCore::IVGStyleFill::PutFountainScaleY ( double pVal ) {
    HRESULT _hr = put_FountainScaleY(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(4787)
inline VARIANT_BOOL VGCore::IVGStyleFill::GetFountainAnisotropic ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_FountainAnisotropic(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4788)
inline void VGCore::IVGStyleFill::PutFountainAnisotropic ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_FountainAnisotropic(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(4789)
inline enum VGCore::cdrFountainFillSpreadMethod VGCore::IVGStyleFill::GetFountainSpreadMethod ( ) {
    enum cdrFountainFillSpreadMethod _result;
    HRESULT _hr = get_FountainSpreadMethod(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4790)
inline void VGCore::IVGStyleFill::PutFountainSpreadMethod ( enum cdrFountainFillSpreadMethod pVal ) {
    HRESULT _hr = put_FountainSpreadMethod(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(4791)
inline unsigned char VGCore::IVGStyleFill::GetPrimaryOpacity ( ) {
    unsigned char _result = 0;
    HRESULT _hr = get_PrimaryOpacity(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4792)
inline void VGCore::IVGStyleFill::PutPrimaryOpacity ( unsigned char pVal ) {
    HRESULT _hr = put_PrimaryOpacity(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(4793)
inline unsigned char VGCore::IVGStyleFill::GetSecondaryOpacity ( ) {
    unsigned char _result = 0;
    HRESULT _hr = get_SecondaryOpacity(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4794)
inline void VGCore::IVGStyleFill::PutSecondaryOpacity ( unsigned char pVal ) {
    HRESULT _hr = put_SecondaryOpacity(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(4795)
inline enum VGCore::cdrMergeMode VGCore::IVGStyleFill::GetMergeMode ( ) {
    enum cdrMergeMode _result;
    HRESULT _hr = get_MergeMode(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4796)
inline void VGCore::IVGStyleFill::PutMergeMode ( enum cdrMergeMode pVal ) {
    HRESULT _hr = put_MergeMode(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(4797)
inline VARIANT_BOOL VGCore::IVGStyleFill::SaveFill ( _bstr_t FileName, struct IVGFillMetadata * Metadata ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_SaveFill(FileName, Metadata, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4798)
inline VARIANT_BOOL VGCore::IVGStyleFill::LoadFill ( _bstr_t FileName, struct IVGFillMetadata * * Metadata ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_LoadFill(FileName, Metadata, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface IVGStyleCharacter wrapper method implementations
//

#pragma implementation_key(4799)
inline VGCore::IVGStylePtr VGCore::IVGStyleCharacter::GetStyle ( ) {
    struct IVGStyle * _result = 0;
    HRESULT _hr = get_Style(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGStylePtr(_result, false);
}

//
// interface IVGStyleParagraph wrapper method implementations
//

#pragma implementation_key(4800)
inline VGCore::IVGStylePtr VGCore::IVGStyleParagraph::GetStyle ( ) {
    struct IVGStyle * _result = 0;
    HRESULT _hr = get_Style(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGStylePtr(_result, false);
}

//
// interface IVGStyleFrame wrapper method implementations
//

#pragma implementation_key(4801)
inline VGCore::IVGStylePtr VGCore::IVGStyleFrame::GetStyle ( ) {
    struct IVGStyle * _result = 0;
    HRESULT _hr = get_Style(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGStylePtr(_result, false);
}

//
// interface IVGStyles wrapper method implementations
//

#pragma implementation_key(4802)
inline long VGCore::IVGStyles::GetCount ( ) {
    long _result = 0;
    HRESULT _hr = get_Count(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4803)
inline VGCore::IVGStylePtr VGCore::IVGStyles::GetItem ( long Index ) {
    struct IVGStyle * _result = 0;
    HRESULT _hr = get_Item(Index, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGStylePtr(_result, false);
}

#pragma implementation_key(4804)
inline IUnknownPtr VGCore::IVGStyles::Get_NewEnum ( ) {
    IUnknown * _result = 0;
    HRESULT _hr = get__NewEnum(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IUnknownPtr(_result, false);
}

#pragma implementation_key(4805)
inline VGCore::IVGStylePtr VGCore::IVGStyles::Find ( _bstr_t Name ) {
    struct IVGStyle * _result = 0;
    HRESULT _hr = raw_Find(Name, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGStylePtr(_result, false);
}

#pragma implementation_key(4806)
inline VGCore::IVGStylePtr VGCore::IVGStyles::GetFirst ( ) {
    struct IVGStyle * _result = 0;
    HRESULT _hr = get_First(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGStylePtr(_result, false);
}

#pragma implementation_key(4807)
inline VGCore::IVGStylePtr VGCore::IVGStyles::GetLast ( ) {
    struct IVGStyle * _result = 0;
    HRESULT _hr = get_Last(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGStylePtr(_result, false);
}

//
// interface IVGStyleTransparency wrapper method implementations
//

#pragma implementation_key(4808)
inline VGCore::IVGStylePtr VGCore::IVGStyleTransparency::GetStyle ( ) {
    struct IVGStyle * _result = 0;
    HRESULT _hr = get_Style(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGStylePtr(_result, false);
}

#pragma implementation_key(4809)
inline VGCore::IVGStyleFillPtr VGCore::IVGStyleTransparency::GetFill ( ) {
    struct IVGStyleFill * _result = 0;
    HRESULT _hr = get_Fill(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGStyleFillPtr(_result, false);
}

#pragma implementation_key(4810)
inline enum VGCore::cdrMergeMode VGCore::IVGStyleTransparency::GetMode ( ) {
    enum cdrMergeMode _result;
    HRESULT _hr = get_Mode(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4811)
inline void VGCore::IVGStyleTransparency::PutMode ( enum cdrMergeMode pVal ) {
    HRESULT _hr = put_Mode(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(4812)
inline double VGCore::IVGStyleTransparency::GetUniformTransparency ( ) {
    double _result = 0;
    HRESULT _hr = get_UniformTransparency(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4813)
inline void VGCore::IVGStyleTransparency::PutUniformTransparency ( double pVal ) {
    HRESULT _hr = put_UniformTransparency(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(4814)
inline double VGCore::IVGStyleTransparency::GetWhiteTransparency ( ) {
    double _result = 0;
    HRESULT _hr = get_WhiteTransparency(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4815)
inline void VGCore::IVGStyleTransparency::PutWhiteTransparency ( double pVal ) {
    HRESULT _hr = put_WhiteTransparency(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(4816)
inline double VGCore::IVGStyleTransparency::GetBlackTransparency ( ) {
    double _result = 0;
    HRESULT _hr = get_BlackTransparency(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4817)
inline void VGCore::IVGStyleTransparency::PutBlackTransparency ( double pVal ) {
    HRESULT _hr = put_BlackTransparency(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(4818)
inline enum VGCore::cdrTransparencyAppliedTo VGCore::IVGStyleTransparency::GetAppliesTo ( ) {
    enum cdrTransparencyAppliedTo _result;
    HRESULT _hr = get_AppliesTo(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4819)
inline void VGCore::IVGStyleTransparency::PutAppliesTo ( enum cdrTransparencyAppliedTo pVal ) {
    HRESULT _hr = put_AppliesTo(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IVGToolShape wrapper method implementations
//

#pragma implementation_key(4820)
inline HRESULT VGCore::IVGToolShape::OnGenerateShape ( struct IVGLayer * Parent, struct IVGProperties * ObjectProperties, struct IVGStyle * pStyleAttributes, struct IVGTransformMatrix * pTransformation, VARIANT_BOOL IsPreviewOnly ) {
    HRESULT _hr = raw_OnGenerateShape(Parent, ObjectProperties, pStyleAttributes, pTransformation, IsPreviewOnly);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface IVGStyleSheet wrapper method implementations
//

#pragma implementation_key(4821)
inline VGCore::IVGStylesPtr VGCore::IVGStyleSheet::GetStyles ( ) {
    struct IVGStyles * _result = 0;
    HRESULT _hr = get_Styles(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGStylesPtr(_result, false);
}

#pragma implementation_key(4822)
inline VGCore::IVGStylesPtr VGCore::IVGStyleSheet::GetStyleSets ( ) {
    struct IVGStyles * _result = 0;
    HRESULT _hr = get_StyleSets(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGStylesPtr(_result, false);
}

#pragma implementation_key(4823)
inline VGCore::IVGStylesPtr VGCore::IVGStyleSheet::GetObjectDefaults ( ) {
    struct IVGStyles * _result = 0;
    HRESULT _hr = get_ObjectDefaults(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGStylesPtr(_result, false);
}

#pragma implementation_key(4824)
inline VGCore::IVGStylesPtr VGCore::IVGStyleSheet::GetAllStyles ( ) {
    struct IVGStyles * _result = 0;
    HRESULT _hr = get_AllStyles(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGStylesPtr(_result, false);
}

#pragma implementation_key(4825)
inline VGCore::IVGStylesPtr VGCore::IVGStyleSheet::GetAllStyleSets ( ) {
    struct IVGStyles * _result = 0;
    HRESULT _hr = get_AllStyleSets(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGStylesPtr(_result, false);
}

#pragma implementation_key(4826)
inline VGCore::IVGStylePtr VGCore::IVGStyleSheet::FindStyle ( _bstr_t Name ) {
    struct IVGStyle * _result = 0;
    HRESULT _hr = raw_FindStyle(Name, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGStylePtr(_result, false);
}

#pragma implementation_key(4827)
inline VGCore::IVGStylesPtr VGCore::IVGStyleSheet::CreateStyleFromShape ( struct IVGShape * Shape, _bstr_t Category, _bstr_t Name, VARIANT_BOOL ReplaceExisting ) {
    struct IVGStyles * _result = 0;
    HRESULT _hr = raw_CreateStyleFromShape(Shape, Category, Name, ReplaceExisting, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGStylesPtr(_result, false);
}

#pragma implementation_key(4828)
inline VGCore::IVGStylesPtr VGCore::IVGStyleSheet::CreateStyleFromShapeRange ( struct IVGShapeRange * ShapeRange, _bstr_t Category, _bstr_t Name, VARIANT_BOOL ReplaceExisting ) {
    struct IVGStyles * _result = 0;
    HRESULT _hr = raw_CreateStyleFromShapeRange(ShapeRange, Category, Name, ReplaceExisting, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGStylesPtr(_result, false);
}

#pragma implementation_key(4829)
inline VGCore::IVGStylesPtr VGCore::IVGStyleSheet::CreateStyleFromTextRange ( struct IVGTextRange * TextRange, _bstr_t Category, _bstr_t Name, VARIANT_BOOL ReplaceExisting ) {
    struct IVGStyles * _result = 0;
    HRESULT _hr = raw_CreateStyleFromTextRange(TextRange, Category, Name, ReplaceExisting, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGStylesPtr(_result, false);
}

#pragma implementation_key(4830)
inline VGCore::IVGStylesPtr VGCore::IVGStyleSheet::CreateStyleSetFromShape ( struct IVGShape * Shape, _bstr_t Name, VARIANT_BOOL ReplaceExisting ) {
    struct IVGStyles * _result = 0;
    HRESULT _hr = raw_CreateStyleSetFromShape(Shape, Name, ReplaceExisting, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGStylesPtr(_result, false);
}

#pragma implementation_key(4831)
inline VGCore::IVGStylesPtr VGCore::IVGStyleSheet::CreateStyleSetFromShapeRange ( struct IVGShapeRange * ShapeRange, _bstr_t Name, VARIANT_BOOL ReplaceExisting ) {
    struct IVGStyles * _result = 0;
    HRESULT _hr = raw_CreateStyleSetFromShapeRange(ShapeRange, Name, ReplaceExisting, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGStylesPtr(_result, false);
}

#pragma implementation_key(4832)
inline VGCore::IVGStylesPtr VGCore::IVGStyleSheet::CreateStyleSetFromTextRange ( struct IVGTextRange * TextRange, _bstr_t Name, VARIANT_BOOL ReplaceExisting ) {
    struct IVGStyles * _result = 0;
    HRESULT _hr = raw_CreateStyleSetFromTextRange(TextRange, Name, ReplaceExisting, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGStylesPtr(_result, false);
}

#pragma implementation_key(4833)
inline VGCore::IVGStylePtr VGCore::IVGStyleSheet::CreateStyle ( _bstr_t Category, _bstr_t BasedOn, _bstr_t Name, VARIANT_BOOL ReplaceExisting ) {
    struct IVGStyle * _result = 0;
    HRESULT _hr = raw_CreateStyle(Category, BasedOn, Name, ReplaceExisting, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGStylePtr(_result, false);
}

#pragma implementation_key(4834)
inline VGCore::IVGStylePtr VGCore::IVGStyleSheet::CreateStyleSet ( _bstr_t BasedOn, _bstr_t Name, VARIANT_BOOL ReplaceExisting ) {
    struct IVGStyle * _result = 0;
    HRESULT _hr = raw_CreateStyleSet(BasedOn, Name, ReplaceExisting, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGStylePtr(_result, false);
}

#pragma implementation_key(4835)
inline VARIANT_BOOL VGCore::IVGStyleSheet::Export ( _bstr_t FileName, VARIANT_BOOL Styles, VARIANT_BOOL StyleSets, VARIANT_BOOL ObjectDefaults, VARIANT_BOOL ColorStyles ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_Export(FileName, Styles, StyleSets, ObjectDefaults, ColorStyles, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4836)
inline VARIANT_BOOL VGCore::IVGStyleSheet::Import ( _bstr_t FileName, VARIANT_BOOL MergeStyles, VARIANT_BOOL Styles, VARIANT_BOOL StyleSets, VARIANT_BOOL ObjectDefaults, VARIANT_BOOL ColorStyles ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_Import(FileName, MergeStyles, Styles, StyleSets, ObjectDefaults, ColorStyles, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4837)
inline VGCore::IVGColorsPtr VGCore::IVGStyleSheet::GetAllColorStyles ( ) {
    struct IVGColors * _result = 0;
    HRESULT _hr = get_AllColorStyles(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGColorsPtr(_result, false);
}

#pragma implementation_key(4838)
inline VGCore::IVGColorPtr VGCore::IVGStyleSheet::CreateColorStyle ( _bstr_t Name, struct IVGColor * Color, long HarmonyIndex, long IndexInHarmony, VARIANT_BOOL ReplaceExisting ) {
    struct IVGColor * _result = 0;
    HRESULT _hr = raw_CreateColorStyle(Name, Color, HarmonyIndex, IndexInHarmony, ReplaceExisting, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGColorPtr(_result, false);
}

#pragma implementation_key(4839)
inline HRESULT VGCore::IVGStyleSheet::DeleteAllColorStyles ( ) {
    HRESULT _hr = raw_DeleteAllColorStyles();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(4840)
inline HRESULT VGCore::IVGStyleSheet::DeleteColorStyle ( _bstr_t Name ) {
    HRESULT _hr = raw_DeleteColorStyle(Name);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(4841)
inline HRESULT VGCore::IVGStyleSheet::RenameColorStyle ( _bstr_t OldName, _bstr_t NewName ) {
    HRESULT _hr = raw_RenameColorStyle(OldName, NewName);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface IVGDataItems wrapper method implementations
//

#pragma implementation_key(4842)
inline VGCore::IVGApplicationPtr VGCore::IVGDataItems::GetApplication ( ) {
    struct IVGApplication * _result = 0;
    HRESULT _hr = get_Application(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGApplicationPtr(_result, false);
}

#pragma implementation_key(4843)
inline VGCore::IVGShapePtr VGCore::IVGDataItems::GetParent ( ) {
    struct IVGShape * _result = 0;
    HRESULT _hr = get_Parent(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGShapePtr(_result, false);
}

#pragma implementation_key(4844)
inline long VGCore::IVGDataItems::GetCount ( ) {
    long _result = 0;
    HRESULT _hr = get_Count(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4845)
inline VGCore::IVGDataItemPtr VGCore::IVGDataItems::GetItem ( const _variant_t & IndexOrName ) {
    struct IVGDataItem * _result = 0;
    HRESULT _hr = get_Item(IndexOrName, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGDataItemPtr(_result, false);
}

#pragma implementation_key(4846)
inline IUnknownPtr VGCore::IVGDataItems::Get_NewEnum ( ) {
    IUnknown * _result = 0;
    HRESULT _hr = get__NewEnum(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IUnknownPtr(_result, false);
}

#pragma implementation_key(4847)
inline VGCore::IVGDataItemPtr VGCore::IVGDataItems::Add ( struct IVGDataField * DataField, const _variant_t & Value ) {
    struct IVGDataItem * _result = 0;
    HRESULT _hr = raw_Add(DataField, Value, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGDataItemPtr(_result, false);
}

#pragma implementation_key(4848)
inline HRESULT VGCore::IVGDataItems::CopyFrom ( struct IVGShape * Shape ) {
    HRESULT _hr = raw_CopyFrom(Shape);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(4849)
inline HRESULT VGCore::IVGDataItems::Clear ( ) {
    HRESULT _hr = raw_Clear();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface IVGDataItem wrapper method implementations
//

#pragma implementation_key(4850)
inline VGCore::IVGApplicationPtr VGCore::IVGDataItem::GetApplication ( ) {
    struct IVGApplication * _result = 0;
    HRESULT _hr = get_Application(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGApplicationPtr(_result, false);
}

#pragma implementation_key(4851)
inline VGCore::IVGDataItemsPtr VGCore::IVGDataItem::GetParent ( ) {
    struct IVGDataItems * _result = 0;
    HRESULT _hr = get_Parent(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGDataItemsPtr(_result, false);
}

#pragma implementation_key(4852)
inline _variant_t VGCore::IVGDataItem::GetValue ( ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = get_Value(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

#pragma implementation_key(4853)
inline void VGCore::IVGDataItem::PutValue ( const _variant_t & pVal ) {
    HRESULT _hr = put_Value(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(4854)
inline VGCore::IVGDataFieldPtr VGCore::IVGDataItem::GetDataField ( ) {
    struct IVGDataField * _result = 0;
    HRESULT _hr = get_DataField(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGDataFieldPtr(_result, false);
}

#pragma implementation_key(4855)
inline HRESULT VGCore::IVGDataItem::Clear ( ) {
    HRESULT _hr = raw_Clear();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(4856)
inline _bstr_t VGCore::IVGDataItem::GetFormattedValue ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_FormattedValue(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

//
// interface IVGDataField wrapper method implementations
//

#pragma implementation_key(4857)
inline VGCore::IVGApplicationPtr VGCore::IVGDataField::GetApplication ( ) {
    struct IVGApplication * _result = 0;
    HRESULT _hr = get_Application(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGApplicationPtr(_result, false);
}

#pragma implementation_key(4858)
inline VGCore::IVGDataFieldsPtr VGCore::IVGDataField::GetParent ( ) {
    struct IVGDataFields * _result = 0;
    HRESULT _hr = get_Parent(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGDataFieldsPtr(_result, false);
}

#pragma implementation_key(4859)
inline _bstr_t VGCore::IVGDataField::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(4860)
inline void VGCore::IVGDataField::PutName ( _bstr_t pVal ) {
    HRESULT _hr = put_Name(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(4861)
inline enum VGCore::cdrDataFormatType VGCore::IVGDataField::GetFormatType ( ) {
    enum cdrDataFormatType _result;
    HRESULT _hr = get_FormatType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4862)
inline _bstr_t VGCore::IVGDataField::GetFormat ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Format(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(4863)
inline void VGCore::IVGDataField::PutFormat ( _bstr_t pVal ) {
    HRESULT _hr = put_Format(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(4864)
inline long VGCore::IVGDataField::GetFieldWidth ( ) {
    long _result = 0;
    HRESULT _hr = get_FieldWidth(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4865)
inline void VGCore::IVGDataField::PutFieldWidth ( long pVal ) {
    HRESULT _hr = put_FieldWidth(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(4866)
inline VARIANT_BOOL VGCore::IVGDataField::GetAppDefault ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_AppDefault(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4867)
inline void VGCore::IVGDataField::PutAppDefault ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_AppDefault(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(4868)
inline VARIANT_BOOL VGCore::IVGDataField::GetDocDefault ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_DocDefault(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4869)
inline void VGCore::IVGDataField::PutDocDefault ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_DocDefault(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(4870)
inline VARIANT_BOOL VGCore::IVGDataField::GetSummarizeGroup ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_SummarizeGroup(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4871)
inline void VGCore::IVGDataField::PutSummarizeGroup ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_SummarizeGroup(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(4872)
inline HRESULT VGCore::IVGDataField::Delete ( ) {
    HRESULT _hr = raw_Delete();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(4873)
inline HRESULT VGCore::IVGDataField::Reorder ( long NewIndex ) {
    HRESULT _hr = raw_Reorder(NewIndex);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(4874)
inline long VGCore::IVGDataField::GetIndex ( ) {
    long _result = 0;
    HRESULT _hr = get_Index(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4875)
inline _bstr_t VGCore::IVGDataField::GetTarget ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Target(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(4876)
inline void VGCore::IVGDataField::PutTarget ( _bstr_t pVal ) {
    HRESULT _hr = put_Target(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(4877)
inline _bstr_t VGCore::IVGDataField::GetDefaultValue ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_DefaultValue(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(4878)
inline void VGCore::IVGDataField::PutDefaultValue ( _bstr_t pVal ) {
    HRESULT _hr = put_DefaultValue(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(4879)
inline _bstr_t VGCore::IVGDataField::GetConstraint ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Constraint(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(4880)
inline void VGCore::IVGDataField::PutConstraint ( _bstr_t pVal ) {
    HRESULT _hr = put_Constraint(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(4881)
inline enum VGCore::cdrDataType VGCore::IVGDataField::GetDataType ( ) {
    enum cdrDataType _result;
    HRESULT _hr = get_DataType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4882)
inline void VGCore::IVGDataField::PutDataType ( enum cdrDataType pVal ) {
    HRESULT _hr = put_DataType(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(4883)
inline _bstr_t VGCore::IVGDataField::GetParentName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_ParentName(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(4884)
inline void VGCore::IVGDataField::PutParentName ( _bstr_t pVal ) {
    HRESULT _hr = put_ParentName(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(4885)
inline _bstr_t VGCore::IVGDataField::GetElementName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_ElementName(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(4886)
inline void VGCore::IVGDataField::PutElementName ( _bstr_t pVal ) {
    HRESULT _hr = put_ElementName(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IVGDataFields wrapper method implementations
//

#pragma implementation_key(4887)
inline VGCore::IVGApplicationPtr VGCore::IVGDataFields::GetApplication ( ) {
    struct IVGApplication * _result = 0;
    HRESULT _hr = get_Application(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGApplicationPtr(_result, false);
}

#pragma implementation_key(4888)
inline VGCore::IVGDocumentPtr VGCore::IVGDataFields::GetParent ( ) {
    struct IVGDocument * _result = 0;
    HRESULT _hr = get_Parent(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGDocumentPtr(_result, false);
}

#pragma implementation_key(4889)
inline long VGCore::IVGDataFields::GetCount ( ) {
    long _result = 0;
    HRESULT _hr = get_Count(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4890)
inline VGCore::IVGDataFieldPtr VGCore::IVGDataFields::GetItem ( const _variant_t & IndexOrName ) {
    struct IVGDataField * _result = 0;
    HRESULT _hr = get_Item(IndexOrName, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGDataFieldPtr(_result, false);
}

#pragma implementation_key(4891)
inline IUnknownPtr VGCore::IVGDataFields::Get_NewEnum ( ) {
    IUnknown * _result = 0;
    HRESULT _hr = get__NewEnum(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IUnknownPtr(_result, false);
}

#pragma implementation_key(4892)
inline VGCore::IVGDataFieldPtr VGCore::IVGDataFields::Add ( _bstr_t Name, _bstr_t Format, VARIANT_BOOL AppDefault, VARIANT_BOOL DocDefault, VARIANT_BOOL SummarizeGroup ) {
    struct IVGDataField * _result = 0;
    HRESULT _hr = raw_Add(Name, Format, AppDefault, DocDefault, SummarizeGroup, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGDataFieldPtr(_result, false);
}

#pragma implementation_key(4893)
inline VGCore::IVGDataFieldPtr VGCore::IVGDataFields::AddEx ( _bstr_t Name, enum cdrDataType DataType, _bstr_t DefaultValue, _bstr_t Constraint, _bstr_t Target, _bstr_t Format, VARIANT_BOOL AppDefault, VARIANT_BOOL DocDefault, VARIANT_BOOL SummarizeGroup, long FieldWidth ) {
    struct IVGDataField * _result = 0;
    HRESULT _hr = raw_AddEx(Name, DataType, DefaultValue, Constraint, Target, Format, AppDefault, DocDefault, SummarizeGroup, FieldWidth, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGDataFieldPtr(_result, false);
}

#pragma implementation_key(4894)
inline VARIANT_BOOL VGCore::IVGDataFields::IsPresent ( _bstr_t FieldName ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_IsPresent(FieldName, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4895)
inline VGCore::IVGDataFieldPtr VGCore::IVGDataFields::AddEx2 ( _bstr_t ParentName, _bstr_t ElementName, _bstr_t Name, enum cdrDataType DataType, _bstr_t DefaultValue, _bstr_t Constraint, _bstr_t Target, _bstr_t Format, VARIANT_BOOL AppDefault, VARIANT_BOOL DocDefault, VARIANT_BOOL SummarizeGroup, long FieldWidth ) {
    struct IVGDataField * _result = 0;
    HRESULT _hr = raw_AddEx2(ParentName, ElementName, Name, DataType, DefaultValue, Constraint, Target, Format, AppDefault, DocDefault, SummarizeGroup, FieldWidth, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGDataFieldPtr(_result, false);
}

//
// interface IVGSymbol wrapper method implementations
//

#pragma implementation_key(4896)
inline VGCore::IVGSymbolDefinitionPtr VGCore::IVGSymbol::GetDefinition ( ) {
    struct IVGSymbolDefinition * _result = 0;
    HRESULT _hr = get_Definition(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGSymbolDefinitionPtr(_result, false);
}

#pragma implementation_key(4897)
inline VGCore::IVGShapeRangePtr VGCore::IVGSymbol::RevertToShapes ( ) {
    struct IVGShapeRange * _result = 0;
    HRESULT _hr = raw_RevertToShapes(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGShapeRangePtr(_result, false);
}

//
// interface IVGSymbolDefinition wrapper method implementations
//

#pragma implementation_key(4898)
inline _bstr_t VGCore::IVGSymbolDefinition::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(4899)
inline void VGCore::IVGSymbolDefinition::PutName ( _bstr_t pVal ) {
    HRESULT _hr = put_Name(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(4900)
inline _bstr_t VGCore::IVGSymbolDefinition::GetDescription ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Description(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(4901)
inline void VGCore::IVGSymbolDefinition::PutDescription ( _bstr_t pVal ) {
    HRESULT _hr = put_Description(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(4902)
inline VARIANT_BOOL VGCore::IVGSymbolDefinition::GetLinked ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_Linked(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4903)
inline _bstr_t VGCore::IVGSymbolDefinition::GetLinkLibraryPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_LinkLibraryPath(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(4904)
inline VARIANT_BOOL VGCore::IVGSymbolDefinition::GetNested ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_Nested(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4905)
inline VARIANT_BOOL VGCore::IVGSymbolDefinition::GetHasLinks ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_HasLinks(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4906)
inline VARIANT_BOOL VGCore::IVGSymbolDefinition::GetIsLinkBroken ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsLinkBroken(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4907)
inline VARIANT_BOOL VGCore::IVGSymbolDefinition::GetIsLinkUpdated ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsLinkUpdated(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4908)
inline VARIANT_BOOL VGCore::IVGSymbolDefinition::GetHasBrokenLinks ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_HasBrokenLinks(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4909)
inline VARIANT_BOOL VGCore::IVGSymbolDefinition::GetHasUpdatedLinks ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_HasUpdatedLinks(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4910)
inline VGCore::IVGSymbolDefinitionsPtr VGCore::IVGSymbolDefinition::GetNestedSymbols ( ) {
    struct IVGSymbolDefinitions * _result = 0;
    HRESULT _hr = get_NestedSymbols(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGSymbolDefinitionsPtr(_result, false);
}

#pragma implementation_key(4911)
inline VARIANT_BOOL VGCore::IVGSymbolDefinition::GetEditable ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_Editable(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4912)
inline long VGCore::IVGSymbolDefinition::GetInstanceCount ( ) {
    long _result = 0;
    HRESULT _hr = get_InstanceCount(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4913)
inline VGCore::IVGShapeRangePtr VGCore::IVGSymbolDefinition::GetInstances ( ) {
    struct IVGShapeRange * _result = 0;
    HRESULT _hr = get_Instances(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGShapeRangePtr(_result, false);
}

#pragma implementation_key(4914)
inline HRESULT VGCore::IVGSymbolDefinition::EnterEditMode ( ) {
    HRESULT _hr = raw_EnterEditMode();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(4915)
inline HRESULT VGCore::IVGSymbolDefinition::LeaveEditMode ( ) {
    HRESULT _hr = raw_LeaveEditMode();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(4916)
inline HRESULT VGCore::IVGSymbolDefinition::Delete ( ) {
    HRESULT _hr = raw_Delete();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(4917)
inline HRESULT VGCore::IVGSymbolDefinition::Copy ( ) {
    HRESULT _hr = raw_Copy();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(4918)
inline VGCore::IVGSymbolDefinitionPtr VGCore::IVGSymbolDefinition::Duplicate ( _bstr_t Name ) {
    struct IVGSymbolDefinition * _result = 0;
    HRESULT _hr = raw_Duplicate(Name, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGSymbolDefinitionPtr(_result, false);
}

#pragma implementation_key(4919)
inline HRESULT VGCore::IVGSymbolDefinition::BreakLink ( ) {
    HRESULT _hr = raw_BreakLink();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(4920)
inline HRESULT VGCore::IVGSymbolDefinition::UpdateLinks ( ) {
    HRESULT _hr = raw_UpdateLinks();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(4921)
inline HRESULT VGCore::IVGSymbolDefinition::FixLink ( _bstr_t LibraryPath ) {
    HRESULT _hr = raw_FixLink(LibraryPath);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(4922)
inline enum VGCore::cdrSymbolType VGCore::IVGSymbolDefinition::GetType ( ) {
    enum cdrSymbolType _result;
    HRESULT _hr = get_Type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface IVGSymbolDefinitions wrapper method implementations
//

#pragma implementation_key(4923)
inline VGCore::IVGSymbolDefinitionPtr VGCore::IVGSymbolDefinitions::GetItem ( const _variant_t & IndexOrName ) {
    struct IVGSymbolDefinition * _result = 0;
    HRESULT _hr = get_Item(IndexOrName, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGSymbolDefinitionPtr(_result, false);
}

#pragma implementation_key(4924)
inline long VGCore::IVGSymbolDefinitions::GetCount ( ) {
    long _result = 0;
    HRESULT _hr = get_Count(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4925)
inline IUnknownPtr VGCore::IVGSymbolDefinitions::Get_NewEnum ( ) {
    IUnknown * _result = 0;
    HRESULT _hr = get__NewEnum(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IUnknownPtr(_result, false);
}

//
// interface IVGSymbolLibrary wrapper method implementations
//

#pragma implementation_key(4926)
inline VGCore::IVGSymbolDefinitionsPtr VGCore::IVGSymbolLibrary::GetSymbols ( ) {
    struct IVGSymbolDefinitions * _result = 0;
    HRESULT _hr = get_Symbols(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGSymbolDefinitionsPtr(_result, false);
}

#pragma implementation_key(4927)
inline _bstr_t VGCore::IVGSymbolLibrary::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(4928)
inline _bstr_t VGCore::IVGSymbolLibrary::GetFilePath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_FilePath(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(4929)
inline VARIANT_BOOL VGCore::IVGSymbolLibrary::GetReadOnly ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_ReadOnly(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4930)
inline HRESULT VGCore::IVGSymbolLibrary::Delete ( ) {
    HRESULT _hr = raw_Delete();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(4931)
inline HRESULT VGCore::IVGSymbolLibrary::PurgeUnusedSymbols ( ) {
    HRESULT _hr = raw_PurgeUnusedSymbols();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(4932)
inline VGCore::IVGSymbolDefinitionPtr VGCore::IVGSymbolLibrary::Paste ( _bstr_t Name ) {
    struct IVGSymbolDefinition * _result = 0;
    HRESULT _hr = raw_Paste(Name, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGSymbolDefinitionPtr(_result, false);
}

//
// interface IVGSymbolLibraries wrapper method implementations
//

#pragma implementation_key(4933)
inline VGCore::IVGSymbolLibraryPtr VGCore::IVGSymbolLibraries::GetItem ( const _variant_t & IndexOrName ) {
    struct IVGSymbolLibrary * _result = 0;
    HRESULT _hr = get_Item(IndexOrName, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGSymbolLibraryPtr(_result, false);
}

#pragma implementation_key(4934)
inline long VGCore::IVGSymbolLibraries::GetCount ( ) {
    long _result = 0;
    HRESULT _hr = get_Count(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4935)
inline VGCore::IVGSymbolLibraryPtr VGCore::IVGSymbolLibraries::Add ( _bstr_t FileName, VARIANT_BOOL CopyLocally ) {
    struct IVGSymbolLibrary * _result = 0;
    HRESULT _hr = raw_Add(FileName, CopyLocally, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGSymbolLibraryPtr(_result, false);
}

#pragma implementation_key(4936)
inline long VGCore::IVGSymbolLibraries::AddFromFolder ( _bstr_t Folder, VARIANT_BOOL Recursive, VARIANT_BOOL CopyLocally ) {
    long _result = 0;
    HRESULT _hr = raw_AddFromFolder(Folder, Recursive, CopyLocally, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4937)
inline IUnknownPtr VGCore::IVGSymbolLibraries::Get_NewEnum ( ) {
    IUnknown * _result = 0;
    HRESULT _hr = get__NewEnum(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IUnknownPtr(_result, false);
}

//
// interface IVGTreeNode wrapper method implementations
//

#pragma implementation_key(4938)
inline enum VGCore::cdrTreeNodeType VGCore::IVGTreeNode::GetType ( ) {
    enum cdrTreeNodeType _result;
    HRESULT _hr = get_Type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4939)
inline enum VGCore::cdrShapeType VGCore::IVGTreeNode::GetShapeType ( ) {
    enum cdrShapeType _result;
    HRESULT _hr = get_ShapeType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4940)
inline VGCore::IVGShapePtr VGCore::IVGTreeNode::GetShape ( ) {
    struct IVGShape * _result = 0;
    HRESULT _hr = get_Shape(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGShapePtr(_result, false);
}

#pragma implementation_key(4941)
inline VGCore::IVGShapePtr VGCore::IVGTreeNode::GetVirtualShape ( ) {
    struct IVGShape * _result = 0;
    HRESULT _hr = get_VirtualShape(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGShapePtr(_result, false);
}

#pragma implementation_key(4942)
inline VGCore::IVGPagePtr VGCore::IVGTreeNode::GetPage ( ) {
    struct IVGPage * _result = 0;
    HRESULT _hr = get_Page(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGPagePtr(_result, false);
}

#pragma implementation_key(4943)
inline VGCore::IVGLayerPtr VGCore::IVGTreeNode::GetLayer ( ) {
    struct IVGLayer * _result = 0;
    HRESULT _hr = get_Layer(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGLayerPtr(_result, false);
}

#pragma implementation_key(4944)
inline VGCore::IVGDocumentPtr VGCore::IVGTreeNode::GetDocument ( ) {
    struct IVGDocument * _result = 0;
    HRESULT _hr = get_Document(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGDocumentPtr(_result, false);
}

#pragma implementation_key(4945)
inline VGCore::IVGTreeNodePtr VGCore::IVGTreeNode::GetNext ( ) {
    struct IVGTreeNode * _result = 0;
    HRESULT _hr = get_Next(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGTreeNodePtr(_result, false);
}

#pragma implementation_key(4946)
inline VGCore::IVGTreeNodePtr VGCore::IVGTreeNode::GetPrevious ( ) {
    struct IVGTreeNode * _result = 0;
    HRESULT _hr = get_Previous(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGTreeNodePtr(_result, false);
}

#pragma implementation_key(4947)
inline VGCore::IVGTreeNodePtr VGCore::IVGTreeNode::GetParent ( ) {
    struct IVGTreeNode * _result = 0;
    HRESULT _hr = get_Parent(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGTreeNodePtr(_result, false);
}

#pragma implementation_key(4948)
inline VGCore::IVGTreeNodePtr VGCore::IVGTreeNode::GetFirstChild ( ) {
    struct IVGTreeNode * _result = 0;
    HRESULT _hr = get_FirstChild(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGTreeNodePtr(_result, false);
}

#pragma implementation_key(4949)
inline VGCore::IVGTreeNodePtr VGCore::IVGTreeNode::GetLastChild ( ) {
    struct IVGTreeNode * _result = 0;
    HRESULT _hr = get_LastChild(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGTreeNodePtr(_result, false);
}

#pragma implementation_key(4950)
inline VGCore::IVGTreeNodesPtr VGCore::IVGTreeNode::GetChildren ( ) {
    struct IVGTreeNodes * _result = 0;
    HRESULT _hr = get_Children(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGTreeNodesPtr(_result, false);
}

#pragma implementation_key(4951)
inline VARIANT_BOOL VGCore::IVGTreeNode::GetIsGroupChild ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsGroupChild(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4952)
inline VARIANT_BOOL VGCore::IVGTreeNode::GetSelected ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_Selected(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4953)
inline VGCore::IVGTreeNodePtr VGCore::IVGTreeNode::GetNextSelected ( ) {
    struct IVGTreeNode * _result = 0;
    HRESULT _hr = get_NextSelected(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGTreeNodePtr(_result, false);
}

#pragma implementation_key(4954)
inline VARIANT_BOOL VGCore::IVGTreeNode::UnLink ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_UnLink(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4955)
inline VARIANT_BOOL VGCore::IVGTreeNode::LinkBefore ( struct IVGTreeNode * TreeNode ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_LinkBefore(TreeNode, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4956)
inline VARIANT_BOOL VGCore::IVGTreeNode::LinkAfter ( struct IVGTreeNode * TreeNode ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_LinkAfter(TreeNode, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4957)
inline VARIANT_BOOL VGCore::IVGTreeNode::LinkAsChildOf ( struct IVGTreeNode * TreeNode ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_LinkAsChildOf(TreeNode, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4958)
inline VARIANT_BOOL VGCore::IVGTreeNode::MoveToFirst ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_MoveToFirst(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4959)
inline VARIANT_BOOL VGCore::IVGTreeNode::MoveToLast ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_MoveToLast(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4960)
inline VARIANT_BOOL VGCore::IVGTreeNode::MoveBefore ( struct IVGTreeNode * TreeNode ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_MoveBefore(TreeNode, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4961)
inline VARIANT_BOOL VGCore::IVGTreeNode::MoveAfter ( struct IVGTreeNode * TreeNode ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_MoveAfter(TreeNode, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4962)
inline VARIANT_BOOL VGCore::IVGTreeNode::IsDescendentOf ( struct IVGTreeNode * TreeNode ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_IsDescendentOf(TreeNode, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4963)
inline HRESULT VGCore::IVGTreeNode::Delete ( ) {
    HRESULT _hr = raw_Delete();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(4964)
inline VGCore::IVGTreeNodePtr VGCore::IVGTreeNode::GetCopy ( ) {
    struct IVGTreeNode * _result = 0;
    HRESULT _hr = raw_GetCopy(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGTreeNodePtr(_result, false);
}

#pragma implementation_key(4965)
inline HRESULT VGCore::IVGTreeNode::SwapData ( struct IVGTreeNode * TreeNode ) {
    HRESULT _hr = raw_SwapData(TreeNode);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(4966)
inline HRESULT VGCore::IVGTreeNode::SwapGroupData ( struct IVGTreeNode * GroupNode ) {
    HRESULT _hr = raw_SwapGroupData(GroupNode);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(4967)
inline long VGCore::IVGTreeNode::GetHandle ( ) {
    long _result = 0;
    HRESULT _hr = get_Handle(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4968)
inline _bstr_t VGCore::IVGTreeNode::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(4969)
inline void VGCore::IVGTreeNode::PutName ( _bstr_t pVal ) {
    HRESULT _hr = put_Name(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IVGTreeNodes wrapper method implementations
//

#pragma implementation_key(4970)
inline VGCore::IVGTreeNodePtr VGCore::IVGTreeNodes::GetItem ( long Index ) {
    struct IVGTreeNode * _result = 0;
    HRESULT _hr = get_Item(Index, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGTreeNodePtr(_result, false);
}

#pragma implementation_key(4971)
inline long VGCore::IVGTreeNodes::GetCount ( ) {
    long _result = 0;
    HRESULT _hr = get_Count(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4972)
inline IUnknownPtr VGCore::IVGTreeNodes::Get_NewEnum ( ) {
    IUnknown * _result = 0;
    HRESULT _hr = get__NewEnum(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IUnknownPtr(_result, false);
}

//
// interface IVGSpread wrapper method implementations
//

#pragma implementation_key(4973)
inline long VGCore::IVGSpread::GetIndex ( ) {
    long _result = 0;
    HRESULT _hr = get_Index(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4974)
inline double VGCore::IVGSpread::GetSizeWidth ( ) {
    double _result = 0;
    HRESULT _hr = get_SizeWidth(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4975)
inline double VGCore::IVGSpread::GetSizeHeight ( ) {
    double _result = 0;
    HRESULT _hr = get_SizeHeight(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4976)
inline double VGCore::IVGSpread::GetLeftX ( ) {
    double _result = 0;
    HRESULT _hr = get_LeftX(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4977)
inline double VGCore::IVGSpread::GetRightX ( ) {
    double _result = 0;
    HRESULT _hr = get_RightX(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4978)
inline double VGCore::IVGSpread::GetTopY ( ) {
    double _result = 0;
    HRESULT _hr = get_TopY(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4979)
inline double VGCore::IVGSpread::GetBottomY ( ) {
    double _result = 0;
    HRESULT _hr = get_BottomY(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4980)
inline double VGCore::IVGSpread::GetCenterX ( ) {
    double _result = 0;
    HRESULT _hr = get_CenterX(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4981)
inline double VGCore::IVGSpread::GetCenterY ( ) {
    double _result = 0;
    HRESULT _hr = get_CenterY(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4982)
inline VGCore::IVGRectPtr VGCore::IVGSpread::GetBoundingBox ( ) {
    struct IVGRect * _result = 0;
    HRESULT _hr = get_BoundingBox(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGRectPtr(_result, false);
}

#pragma implementation_key(4983)
inline HRESULT VGCore::IVGSpread::GetBoundingBox ( double * x, double * y, double * Width, double * Height ) {
    HRESULT _hr = raw_GetBoundingBox(x, y, Width, Height);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(4984)
inline VGCore::IVGPagesPtr VGCore::IVGSpread::GetPages ( ) {
    struct IVGPages * _result = 0;
    HRESULT _hr = get_Pages(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGPagesPtr(_result, false);
}

#pragma implementation_key(4985)
inline VGCore::IVGSpreadPtr VGCore::IVGSpread::GetNext ( ) {
    struct IVGSpread * _result = 0;
    HRESULT _hr = get_Next(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGSpreadPtr(_result, false);
}

#pragma implementation_key(4986)
inline VGCore::IVGSpreadPtr VGCore::IVGSpread::GetPrevious ( ) {
    struct IVGSpread * _result = 0;
    HRESULT _hr = get_Previous(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGSpreadPtr(_result, false);
}

#pragma implementation_key(4987)
inline VGCore::IVGLayersPtr VGCore::IVGSpread::GetLayers ( ) {
    struct IVGLayers * _result = 0;
    HRESULT _hr = get_Layers(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGLayersPtr(_result, false);
}

#pragma implementation_key(4988)
inline VGCore::IVGLayersPtr VGCore::IVGSpread::GetAllLayers ( ) {
    struct IVGLayers * _result = 0;
    HRESULT _hr = get_AllLayers(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGLayersPtr(_result, false);
}

#pragma implementation_key(4989)
inline VGCore::IVGLayerPtr VGCore::IVGSpread::GetActiveLayer ( ) {
    struct IVGLayer * _result = 0;
    HRESULT _hr = get_ActiveLayer(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGLayerPtr(_result, false);
}

#pragma implementation_key(4990)
inline VGCore::IVGShapesPtr VGCore::IVGSpread::GetShapes ( ) {
    struct IVGShapes * _result = 0;
    HRESULT _hr = get_Shapes(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGShapesPtr(_result, false);
}

#pragma implementation_key(4991)
inline VGCore::IVGShapesPtr VGCore::IVGSpread::GetSelectableShapes ( ) {
    struct IVGShapes * _result = 0;
    HRESULT _hr = get_SelectableShapes(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGShapesPtr(_result, false);
}

#pragma implementation_key(4992)
inline VGCore::IVGLayerPtr VGCore::IVGSpread::CreateLayer ( _bstr_t LayerName ) {
    struct IVGLayer * _result = 0;
    HRESULT _hr = raw_CreateLayer(LayerName, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGLayerPtr(_result, false);
}

#pragma implementation_key(4993)
inline VGCore::IVGShapeRangePtr VGCore::IVGSpread::GetGuides ( enum cdrGuideType Type ) {
    struct IVGShapeRange * _result = 0;
    HRESULT _hr = get_Guides(Type, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGShapeRangePtr(_result, false);
}

#pragma implementation_key(4994)
inline VGCore::IVGTreeNodePtr VGCore::IVGSpread::GetTreeNode ( ) {
    struct IVGTreeNode * _result = 0;
    HRESULT _hr = get_TreeNode(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGTreeNodePtr(_result, false);
}

#pragma implementation_key(4995)
inline VGCore::IVGLayerPtr VGCore::IVGSpread::GetGuidesLayer ( ) {
    struct IVGLayer * _result = 0;
    HRESULT _hr = get_GuidesLayer(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGLayerPtr(_result, false);
}

#pragma implementation_key(4996)
inline VGCore::IVGLayerPtr VGCore::IVGSpread::GetDesktopLayer ( ) {
    struct IVGLayer * _result = 0;
    HRESULT _hr = get_DesktopLayer(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGLayerPtr(_result, false);
}

#pragma implementation_key(4997)
inline VGCore::IVGLayerPtr VGCore::IVGSpread::GetGridLayer ( ) {
    struct IVGLayer * _result = 0;
    HRESULT _hr = get_GridLayer(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGLayerPtr(_result, false);
}

//
// interface IVGTreeManager wrapper method implementations
//

#pragma implementation_key(4998)
inline VGCore::IVGLayerPtr VGCore::IVGTreeManager::GetVirtualLayer ( ) {
    struct IVGLayer * _result = 0;
    HRESULT _hr = get_VirtualLayer(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGLayerPtr(_result, false);
}

#pragma implementation_key(4999)
inline long VGCore::IVGTreeManager::GetSelectedNodeCount ( ) {
    long _result = 0;
    HRESULT _hr = get_SelectedNodeCount(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(5000)
inline VGCore::IVGTreeNodePtr VGCore::IVGTreeManager::GetFirstSelectedNode ( ) {
    struct IVGTreeNode * _result = 0;
    HRESULT _hr = get_FirstSelectedNode(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGTreeNodePtr(_result, false);
}

#pragma implementation_key(5001)
inline VGCore::IVGTreeNodePtr VGCore::IVGTreeManager::CreateGroupNode ( ) {
    struct IVGTreeNode * _result = 0;
    HRESULT _hr = raw_CreateGroupNode(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGTreeNodePtr(_result, false);
}

#pragma implementation_key(5002)
inline VGCore::IVGTreeNodePtr VGCore::IVGTreeManager::CleanGroupNode ( struct IVGTreeNode * GroupNode ) {
    struct IVGTreeNode * _result = 0;
    HRESULT _hr = raw_CleanGroupNode(GroupNode, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGTreeNodePtr(_result, false);
}

//
// interface IVGSpreads wrapper method implementations
//

#pragma implementation_key(5003)
inline VGCore::IVGSpreadPtr VGCore::IVGSpreads::GetItem ( long Index ) {
    struct IVGSpread * _result = 0;
    HRESULT _hr = get_Item(Index, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGSpreadPtr(_result, false);
}

#pragma implementation_key(5004)
inline long VGCore::IVGSpreads::GetCount ( ) {
    long _result = 0;
    HRESULT _hr = get_Count(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(5005)
inline IUnknownPtr VGCore::IVGSpreads::Get_NewEnum ( ) {
    IUnknown * _result = 0;
    HRESULT _hr = get__NewEnum(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IUnknownPtr(_result, false);
}

#pragma implementation_key(5006)
inline VGCore::IVGSpreadPtr VGCore::IVGSpreads::GetFirst ( ) {
    struct IVGSpread * _result = 0;
    HRESULT _hr = get_First(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGSpreadPtr(_result, false);
}

#pragma implementation_key(5007)
inline VGCore::IVGSpreadPtr VGCore::IVGSpreads::GetLast ( ) {
    struct IVGSpread * _result = 0;
    HRESULT _hr = get_Last(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGSpreadPtr(_result, false);
}

//
// interface IVGPageMarkup wrapper method implementations
//

#pragma implementation_key(5008)
inline _bstr_t VGCore::IVGPageMarkup::GetPageGuid ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_PageGuid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(5009)
inline VGCore::IVGCommentThreadsPtr VGCore::IVGPageMarkup::GetThreads ( ) {
    struct IVGCommentThreads * _result = 0;
    HRESULT _hr = get_Threads(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGCommentThreadsPtr(_result, false);
}

#pragma implementation_key(5010)
inline VGCore::IVGPagePtr VGCore::IVGPageMarkup::GetPage ( ) {
    struct IVGPage * _result = 0;
    HRESULT _hr = get_Page(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGPagePtr(_result, false);
}

#pragma implementation_key(5011)
inline VGCore::IVGCommentPtr VGCore::IVGPageMarkup::CreateHotspot ( _bstr_t Text, double x, double y, struct IVGCommentAuthor * Author ) {
    struct IVGComment * _result = 0;
    HRESULT _hr = raw_CreateHotspot(Text, x, y, Author, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGCommentPtr(_result, false);
}

#pragma implementation_key(5012)
inline VGCore::IVGCommentPtr VGCore::IVGPageMarkup::CreateRectangle ( _bstr_t Text, double x, double y, double Width, double Height, long OutlineWidth, struct IVGColor * FillColor, struct IVGColor * OutlineColor, struct IVGCommentAuthor * Author ) {
    struct IVGComment * _result = 0;
    HRESULT _hr = raw_CreateRectangle(Text, x, y, Width, Height, OutlineWidth, FillColor, OutlineColor, Author, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGCommentPtr(_result, false);
}

#pragma implementation_key(5013)
inline VGCore::IVGCommentPtr VGCore::IVGPageMarkup::CreateEllipse ( _bstr_t Text, double x, double y, double RadiusX, double RadiusY, long OutlineWidth, struct IVGColor * FillColor, struct IVGColor * OutlineColor, struct IVGCommentAuthor * Author ) {
    struct IVGComment * _result = 0;
    HRESULT _hr = raw_CreateEllipse(Text, x, y, RadiusX, RadiusY, OutlineWidth, FillColor, OutlineColor, Author, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGCommentPtr(_result, false);
}

#pragma implementation_key(5014)
inline VGCore::IVGCommentPtr VGCore::IVGPageMarkup::CreateArrow ( _bstr_t Text, double x, double y, double VectorX, double VectorY, long OutlineWidth, struct IVGColor * OutlineColor, struct IVGCommentAuthor * Author ) {
    struct IVGComment * _result = 0;
    HRESULT _hr = raw_CreateArrow(Text, x, y, VectorX, VectorY, OutlineWidth, OutlineColor, Author, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGCommentPtr(_result, false);
}

#pragma implementation_key(5015)
inline VGCore::IVGCommentPtr VGCore::IVGPageMarkup::CreateFreehand ( _bstr_t Text, struct IVGCurve * Curve, long OutlineWidth, struct IVGColor * OutlineColor, struct IVGCommentAuthor * Author ) {
    struct IVGComment * _result = 0;
    HRESULT _hr = raw_CreateFreehand(Text, Curve, OutlineWidth, OutlineColor, Author, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGCommentPtr(_result, false);
}

#pragma implementation_key(5016)
inline VGCore::IVGCommentPtr VGCore::IVGPageMarkup::CreateHighlight ( _bstr_t Text, struct IVGCurve * Curve, long OutlineWidth, struct IVGColor * OutlineColor, struct IVGCommentAuthor * Author ) {
    struct IVGComment * _result = 0;
    HRESULT _hr = raw_CreateHighlight(Text, Curve, OutlineWidth, OutlineColor, Author, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGCommentPtr(_result, false);
}

#pragma implementation_key(5017)
inline VGCore::IVGCommentPtr VGCore::IVGPageMarkup::CreateCollaborativeText ( _bstr_t Text, struct IVGShape * Shape, struct IVGColor * OutlineColor, struct IVGCommentAuthor * Author ) {
    struct IVGComment * _result = 0;
    HRESULT _hr = raw_CreateCollaborativeText(Text, Shape, OutlineColor, Author, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGCommentPtr(_result, false);
}

//
// interface IVGCommentThreads wrapper method implementations
//

#pragma implementation_key(5018)
inline VGCore::IVGCommentThreadPtr VGCore::IVGCommentThreads::GetItem ( const _variant_t & IndexOrGuid ) {
    struct IVGCommentThread * _result = 0;
    HRESULT _hr = get_Item(IndexOrGuid, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGCommentThreadPtr(_result, false);
}

#pragma implementation_key(5019)
inline IUnknownPtr VGCore::IVGCommentThreads::Get_NewEnum ( ) {
    IUnknown * _result = 0;
    HRESULT _hr = get__NewEnum(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IUnknownPtr(_result, false);
}

#pragma implementation_key(5020)
inline long VGCore::IVGCommentThreads::GetCount ( ) {
    long _result = 0;
    HRESULT _hr = get_Count(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(5021)
inline VGCore::IVGCommentThreadPtr VGCore::IVGCommentThreads::GetFirst ( ) {
    struct IVGCommentThread * _result = 0;
    HRESULT _hr = get_First(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGCommentThreadPtr(_result, false);
}

#pragma implementation_key(5022)
inline VGCore::IVGCommentThreadPtr VGCore::IVGCommentThreads::GetLast ( ) {
    struct IVGCommentThread * _result = 0;
    HRESULT _hr = get_Last(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGCommentThreadPtr(_result, false);
}

//
// interface IVGCommentThread wrapper method implementations
//

#pragma implementation_key(5023)
inline VGCore::IVGCommentTargetPtr VGCore::IVGCommentThread::GetTarget ( ) {
    struct IVGCommentTarget * _result = 0;
    HRESULT _hr = get_Target(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGCommentTargetPtr(_result, false);
}

#pragma implementation_key(5024)
inline VGCore::IVGCommentsPtr VGCore::IVGCommentThread::GetComments ( ) {
    struct IVGComments * _result = 0;
    HRESULT _hr = get_Comments(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGCommentsPtr(_result, false);
}

#pragma implementation_key(5025)
inline enum VGCore::cdrCommentStatus VGCore::IVGCommentThread::GetStatus ( ) {
    enum cdrCommentStatus _result;
    HRESULT _hr = get_Status(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(5026)
inline VGCore::IVGCommentPtr VGCore::IVGCommentThread::Reply ( _bstr_t Text, struct IVGCommentAuthor * Author ) {
    struct IVGComment * _result = 0;
    HRESULT _hr = raw_Reply(Text, Author, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGCommentPtr(_result, false);
}

#pragma implementation_key(5027)
inline HRESULT VGCore::IVGCommentThread::Resolve ( struct IVGCommentAuthor * Author ) {
    HRESULT _hr = raw_Resolve(Author);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(5028)
inline HRESULT VGCore::IVGCommentThread::Reopen ( struct IVGCommentAuthor * Author ) {
    HRESULT _hr = raw_Reopen(Author);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(5029)
inline HRESULT VGCore::IVGCommentThread::Delete ( ) {
    HRESULT _hr = raw_Delete();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(5030)
inline VGCore::IVGPageMarkupPtr VGCore::IVGCommentThread::GetPageMarkup ( ) {
    struct IVGPageMarkup * _result = 0;
    HRESULT _hr = get_PageMarkup(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGPageMarkupPtr(_result, false);
}

#pragma implementation_key(5031)
inline VGCore::IVGCommentAnnotationPtr VGCore::IVGCommentThread::GetAnnotation ( ) {
    struct IVGCommentAnnotation * _result = 0;
    HRESULT _hr = get_Annotation(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGCommentAnnotationPtr(_result, false);
}

//
// interface IVGComment wrapper method implementations
//

#pragma implementation_key(5032)
inline VGCore::IVGCommentAuthorPtr VGCore::IVGComment::GetAuthor ( ) {
    struct IVGCommentAuthor * _result = 0;
    HRESULT _hr = get_Author(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGCommentAuthorPtr(_result, false);
}

#pragma implementation_key(5033)
inline void VGCore::IVGComment::PutRefAuthor ( struct IVGCommentAuthor * * pRet ) {
    HRESULT _hr = putref_Author(pRet);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(5034)
inline _bstr_t VGCore::IVGComment::GetText ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Text(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(5035)
inline void VGCore::IVGComment::PutText ( _bstr_t pRet ) {
    HRESULT _hr = put_Text(pRet);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(5036)
inline DATE VGCore::IVGComment::GetCreationTime ( ) {
    DATE _result = 0;
    HRESULT _hr = get_CreationTime(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(5037)
inline void VGCore::IVGComment::PutCreationTime ( DATE pRet ) {
    HRESULT _hr = put_CreationTime(pRet);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(5038)
inline DATE VGCore::IVGComment::GetModificationTime ( ) {
    DATE _result = 0;
    HRESULT _hr = get_ModificationTime(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(5039)
inline void VGCore::IVGComment::PutModificationTime ( DATE pRet ) {
    HRESULT _hr = put_ModificationTime(pRet);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(5040)
inline _bstr_t VGCore::IVGComment::GetGuid ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Guid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(5041)
inline VGCore::IVGCommentThreadPtr VGCore::IVGComment::GetThread ( ) {
    struct IVGCommentThread * _result = 0;
    HRESULT _hr = get_Thread(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGCommentThreadPtr(_result, false);
}

#pragma implementation_key(5042)
inline _bstr_t VGCore::IVGComment::GetOnlineID ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_OnlineID(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(5043)
inline void VGCore::IVGComment::PutOnlineID ( _bstr_t pRet ) {
    HRESULT _hr = put_OnlineID(pRet);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(5044)
inline HRESULT VGCore::IVGComment::Delete ( ) {
    HRESULT _hr = raw_Delete();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface IVGComments wrapper method implementations
//

#pragma implementation_key(5045)
inline VGCore::IVGCommentPtr VGCore::IVGComments::GetItem ( const _variant_t & IndexOrGuid ) {
    struct IVGComment * _result = 0;
    HRESULT _hr = get_Item(IndexOrGuid, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGCommentPtr(_result, false);
}

#pragma implementation_key(5046)
inline IUnknownPtr VGCore::IVGComments::Get_NewEnum ( ) {
    IUnknown * _result = 0;
    HRESULT _hr = get__NewEnum(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IUnknownPtr(_result, false);
}

#pragma implementation_key(5047)
inline long VGCore::IVGComments::GetCount ( ) {
    long _result = 0;
    HRESULT _hr = get_Count(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(5048)
inline VGCore::IVGCommentPtr VGCore::IVGComments::GetFirst ( ) {
    struct IVGComment * _result = 0;
    HRESULT _hr = get_First(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGCommentPtr(_result, false);
}

#pragma implementation_key(5049)
inline VGCore::IVGCommentPtr VGCore::IVGComments::GetLast ( ) {
    struct IVGComment * _result = 0;
    HRESULT _hr = get_Last(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGCommentPtr(_result, false);
}

//
// interface IVGDocumentMarkup wrapper method implementations
//

#pragma implementation_key(5050)
inline VGCore::IVGCommentPtr VGCore::IVGDocumentMarkup::FindComment ( _bstr_t Guid ) {
    struct IVGComment * _result = 0;
    HRESULT _hr = raw_FindComment(Guid, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGCommentPtr(_result, false);
}

#pragma implementation_key(5051)
inline VGCore::IVGCommentThreadPtr VGCore::IVGDocumentMarkup::FindThread ( _bstr_t Guid ) {
    struct IVGCommentThread * _result = 0;
    HRESULT _hr = raw_FindThread(Guid, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGCommentThreadPtr(_result, false);
}

#pragma implementation_key(5052)
inline VGCore::IVGPagePtr VGCore::IVGDocumentMarkup::FindPage ( _bstr_t Guid ) {
    struct IVGPage * _result = 0;
    HRESULT _hr = raw_FindPage(Guid, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGPagePtr(_result, false);
}

//
// interface IVGWindow wrapper method implementations
//

#pragma implementation_key(5053)
inline IDispatchPtr VGCore::IVGWindow::GetApplication ( ) {
    IDispatch * _result = 0;
    HRESULT _hr = get_Application(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IDispatchPtr(_result, false);
}

#pragma implementation_key(5054)
inline VGCore::IVGWindowsPtr VGCore::IVGWindow::GetParent ( ) {
    struct IVGWindows * _result = 0;
    HRESULT _hr = get_Parent(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGWindowsPtr(_result, false);
}

#pragma implementation_key(5055)
inline HRESULT VGCore::IVGWindow::Activate ( ) {
    HRESULT _hr = raw_Activate();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(5056)
inline HRESULT VGCore::IVGWindow::Close ( ) {
    HRESULT _hr = raw_Close();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(5057)
inline VARIANT_BOOL VGCore::IVGWindow::GetFullScreen ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_FullScreen(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(5058)
inline void VGCore::IVGWindow::PutFullScreen ( VARIANT_BOOL FullScreen ) {
    HRESULT _hr = put_FullScreen(FullScreen);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(5059)
inline IDispatchPtr VGCore::IVGWindow::GetPage ( ) {
    IDispatch * _result = 0;
    HRESULT _hr = get_Page(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IDispatchPtr(_result, false);
}

#pragma implementation_key(5060)
inline VARIANT_BOOL VGCore::IVGWindow::GetActive ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_Active(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(5061)
inline _bstr_t VGCore::IVGWindow::GetCaption ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Caption(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(5062)
inline long VGCore::IVGWindow::GetHeight ( ) {
    long _result = 0;
    HRESULT _hr = get_Height(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(5063)
inline void VGCore::IVGWindow::PutHeight ( long pVal ) {
    HRESULT _hr = put_Height(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(5064)
inline long VGCore::IVGWindow::GetWidth ( ) {
    long _result = 0;
    HRESULT _hr = get_Width(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(5065)
inline void VGCore::IVGWindow::PutWidth ( long pVal ) {
    HRESULT _hr = put_Width(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(5066)
inline long VGCore::IVGWindow::GetLeft ( ) {
    long _result = 0;
    HRESULT _hr = get_Left(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(5067)
inline void VGCore::IVGWindow::PutLeft ( long pVal ) {
    HRESULT _hr = put_Left(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(5068)
inline long VGCore::IVGWindow::GetTop ( ) {
    long _result = 0;
    HRESULT _hr = get_Top(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(5069)
inline void VGCore::IVGWindow::PutTop ( long pVal ) {
    HRESULT _hr = put_Top(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(5070)
inline enum VGCore::cdrWindowState VGCore::IVGWindow::GetWindowState ( ) {
    enum cdrWindowState _result;
    HRESULT _hr = get_WindowState(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(5071)
inline void VGCore::IVGWindow::PutWindowState ( enum cdrWindowState pVal ) {
    HRESULT _hr = put_WindowState(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(5072)
inline VGCore::IVGWindowPtr VGCore::IVGWindow::GetPrevious ( ) {
    struct IVGWindow * _result = 0;
    HRESULT _hr = get_Previous(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGWindowPtr(_result, false);
}

#pragma implementation_key(5073)
inline VGCore::IVGWindowPtr VGCore::IVGWindow::GetNext ( ) {
    struct IVGWindow * _result = 0;
    HRESULT _hr = get_Next(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGWindowPtr(_result, false);
}

#pragma implementation_key(5074)
inline long VGCore::IVGWindow::GetIndex ( ) {
    long _result = 0;
    HRESULT _hr = get_Index(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(5075)
inline VGCore::IVGWindowPtr VGCore::IVGWindow::NewWindow ( ) {
    struct IVGWindow * _result = 0;
    HRESULT _hr = raw_NewWindow(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGWindowPtr(_result, false);
}

#pragma implementation_key(5076)
inline HRESULT VGCore::IVGWindow::Refresh ( ) {
    HRESULT _hr = raw_Refresh();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(5077)
inline VGCore::IVGDocumentPtr VGCore::IVGWindow::GetDocument ( ) {
    struct IVGDocument * _result = 0;
    HRESULT _hr = get_Document(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGDocumentPtr(_result, false);
}

#pragma implementation_key(5078)
inline VGCore::IVGActiveViewPtr VGCore::IVGWindow::GetActiveView ( ) {
    struct IVGActiveView * _result = 0;
    HRESULT _hr = get_ActiveView(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGActiveViewPtr(_result, false);
}

#pragma implementation_key(5079)
inline HRESULT VGCore::IVGWindow::ScreenToDocument ( long XScreen, long YScreen, double * XDoc, double * YDoc ) {
    HRESULT _hr = raw_ScreenToDocument(XScreen, YScreen, XDoc, YDoc);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(5080)
inline HRESULT VGCore::IVGWindow::DocumentToScreen ( double XDoc, double YDoc, long * XScreen, long * YScreen ) {
    HRESULT _hr = raw_DocumentToScreen(XDoc, YDoc, XScreen, YScreen);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(5081)
inline long VGCore::IVGWindow::GetHandle ( ) {
    long _result = 0;
    HRESULT _hr = get_Handle(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(5082)
inline VGCore::ICUIViewWindowPtr VGCore::IVGWindow::GetViewWindow ( ) {
    struct ICUIViewWindow * _result = 0;
    HRESULT _hr = get_ViewWindow(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return ICUIViewWindowPtr(_result, false);
}

#pragma implementation_key(5083)
inline double VGCore::IVGWindow::ScreenDistanceToDocumentDistance ( double ScreenDistance ) {
    double _result = 0;
    HRESULT _hr = raw_ScreenDistanceToDocumentDistance(ScreenDistance, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(5084)
inline double VGCore::IVGWindow::DocumentDistanceToScreenDistance ( double DocumentDistance ) {
    double _result = 0;
    HRESULT _hr = raw_DocumentDistanceToScreenDistance(DocumentDistance, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface IVGWindows wrapper method implementations
//

#pragma implementation_key(5085)
inline IDispatchPtr VGCore::IVGWindows::GetApplication ( ) {
    IDispatch * _result = 0;
    HRESULT _hr = get_Application(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IDispatchPtr(_result, false);
}

#pragma implementation_key(5086)
inline IDispatchPtr VGCore::IVGWindows::GetParent ( ) {
    IDispatch * _result = 0;
    HRESULT _hr = get_Parent(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IDispatchPtr(_result, false);
}

#pragma implementation_key(5087)
inline VGCore::IVGWindowPtr VGCore::IVGWindows::GetItem ( long Index ) {
    struct IVGWindow * _result = 0;
    HRESULT _hr = get_Item(Index, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGWindowPtr(_result, false);
}

#pragma implementation_key(5088)
inline IUnknownPtr VGCore::IVGWindows::Get_NewEnum ( ) {
    IUnknown * _result = 0;
    HRESULT _hr = get__NewEnum(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IUnknownPtr(_result, false);
}

#pragma implementation_key(5089)
inline long VGCore::IVGWindows::GetCount ( ) {
    long _result = 0;
    HRESULT _hr = get_Count(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(5090)
inline HRESULT VGCore::IVGWindows::CloseAll ( ) {
    HRESULT _hr = raw_CloseAll();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(5091)
inline HRESULT VGCore::IVGWindows::Arrange ( enum cdrWindowArrangeStyle Style ) {
    HRESULT _hr = raw_Arrange(Style);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(5092)
inline HRESULT VGCore::IVGWindows::Refresh ( ) {
    HRESULT _hr = raw_Refresh();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(5093)
inline VGCore::IVGWindowPtr VGCore::IVGWindows::FindWindow ( _bstr_t Caption ) {
    struct IVGWindow * _result = 0;
    HRESULT _hr = raw_FindWindow(Caption, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGWindowPtr(_result, false);
}

//
// interface IVGActiveView wrapper method implementations
//

#pragma implementation_key(5094)
inline VGCore::IVGApplicationPtr VGCore::IVGActiveView::GetApplication ( ) {
    struct IVGApplication * _result = 0;
    HRESULT _hr = get_Application(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGApplicationPtr(_result, false);
}

#pragma implementation_key(5095)
inline VGCore::IVGWindowPtr VGCore::IVGActiveView::GetParent ( ) {
    struct IVGWindow * _result = 0;
    HRESULT _hr = get_Parent(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGWindowPtr(_result, false);
}

#pragma implementation_key(5096)
inline enum VGCore::cdrViewType VGCore::IVGActiveView::GetType ( ) {
    enum cdrViewType _result;
    HRESULT _hr = get_Type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(5097)
inline void VGCore::IVGActiveView::PutType ( enum cdrViewType pType ) {
    HRESULT _hr = put_Type(pType);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(5098)
inline double VGCore::IVGActiveView::GetOriginX ( ) {
    double _result = 0;
    HRESULT _hr = get_OriginX(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(5099)
inline void VGCore::IVGActiveView::PutOriginX ( double pVal ) {
    HRESULT _hr = put_OriginX(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(5100)
inline double VGCore::IVGActiveView::GetOriginY ( ) {
    double _result = 0;
    HRESULT _hr = get_OriginY(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(5101)
inline void VGCore::IVGActiveView::PutOriginY ( double pVal ) {
    HRESULT _hr = put_OriginY(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(5102)
inline double VGCore::IVGActiveView::GetZoom ( ) {
    double _result = 0;
    HRESULT _hr = get_Zoom(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(5103)
inline void VGCore::IVGActiveView::PutZoom ( double pVal ) {
    HRESULT _hr = put_Zoom(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(5104)
inline HRESULT VGCore::IVGActiveView::ToFitPage ( ) {
    HRESULT _hr = raw_ToFitPage();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(5105)
inline HRESULT VGCore::IVGActiveView::ToFitPageWidth ( ) {
    HRESULT _hr = raw_ToFitPageWidth();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(5106)
inline HRESULT VGCore::IVGActiveView::ToFitPageHeight ( ) {
    HRESULT _hr = raw_ToFitPageHeight();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(5107)
inline HRESULT VGCore::IVGActiveView::ToFitShape ( struct IVGShape * Shape ) {
    HRESULT _hr = raw_ToFitShape(Shape);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(5108)
inline HRESULT VGCore::IVGActiveView::ToFitSelection ( ) {
    HRESULT _hr = raw_ToFitSelection();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(5109)
inline HRESULT VGCore::IVGActiveView::ToFitArea ( double Left, double Top, double Right, double Bottom ) {
    HRESULT _hr = raw_ToFitArea(Left, Top, Right, Bottom);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(5110)
inline HRESULT VGCore::IVGActiveView::ToFitAllObjects ( ) {
    HRESULT _hr = raw_ToFitAllObjects();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(5111)
inline HRESULT VGCore::IVGActiveView::ToFitShapeRange ( struct IVGShapeRange * ShapeRange ) {
    HRESULT _hr = raw_ToFitShapeRange(ShapeRange);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(5112)
inline HRESULT VGCore::IVGActiveView::SetViewPoint ( double x, double y, double Zoom ) {
    HRESULT _hr = raw_SetViewPoint(x, y, Zoom);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(5113)
inline HRESULT VGCore::IVGActiveView::SetActualSize ( ) {
    HRESULT _hr = raw_SetActualSize();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(5114)
inline HRESULT VGCore::IVGActiveView::ZoomIn ( ) {
    HRESULT _hr = raw_ZoomIn();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(5115)
inline HRESULT VGCore::IVGActiveView::ZoomInAtPoint ( double x, double y ) {
    HRESULT _hr = raw_ZoomInAtPoint(x, y);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(5116)
inline HRESULT VGCore::IVGActiveView::ZoomOut ( ) {
    HRESULT _hr = raw_ZoomOut();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(5117)
inline HRESULT VGCore::IVGActiveView::GetViewArea ( double * x, double * y, double * Width, double * Height ) {
    HRESULT _hr = raw_GetViewArea(x, y, Width, Height);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(5118)
inline HRESULT VGCore::IVGActiveView::SetViewArea ( double x, double y, double Width, double Height ) {
    HRESULT _hr = raw_SetViewArea(x, y, Width, Height);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(5119)
inline VARIANT_BOOL VGCore::IVGActiveView::GetSimulateOverprints ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_SimulateOverprints(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(5120)
inline void VGCore::IVGActiveView::PutSimulateOverprints ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_SimulateOverprints(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(5121)
inline VGCore::IVGProofColorSettingsPtr VGCore::IVGActiveView::GetProofColorSettings ( ) {
    struct IVGProofColorSettings * _result = 0;
    HRESULT _hr = get_ProofColorSettings(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGProofColorSettingsPtr(_result, false);
}

#pragma implementation_key(5122)
inline void VGCore::IVGActiveView::PutProofColorSettings ( struct IVGProofColorSettings * ppVal ) {
    HRESULT _hr = put_ProofColorSettings(ppVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(5123)
inline VARIANT_BOOL VGCore::IVGActiveView::GetShowProofColors ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_ShowProofColors(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(5124)
inline void VGCore::IVGActiveView::PutShowProofColors ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_ShowProofColors(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IVGWorkspace wrapper method implementations
//

#pragma implementation_key(5125)
inline IDispatchPtr VGCore::IVGWorkspace::GetApplication ( ) {
    IDispatch * _result = 0;
    HRESULT _hr = get_Application(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IDispatchPtr(_result, false);
}

#pragma implementation_key(5126)
inline VGCore::IVGWorkspacesPtr VGCore::IVGWorkspace::GetParent ( ) {
    struct IVGWorkspaces * _result = 0;
    HRESULT _hr = get_Parent(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGWorkspacesPtr(_result, false);
}

#pragma implementation_key(5127)
inline _bstr_t VGCore::IVGWorkspace::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(5128)
inline _bstr_t VGCore::IVGWorkspace::GetDescription ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Description(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(5129)
inline VARIANT_BOOL VGCore::IVGWorkspace::GetDefault ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_Default(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(5130)
inline HRESULT VGCore::IVGWorkspace::Activate ( ) {
    HRESULT _hr = raw_Activate();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(5131)
inline VARIANT_BOOL VGCore::IVGWorkspace::GetActive ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_Active(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface IVGWorkspaces wrapper method implementations
//

#pragma implementation_key(5132)
inline IDispatchPtr VGCore::IVGWorkspaces::GetApplication ( ) {
    IDispatch * _result = 0;
    HRESULT _hr = get_Application(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IDispatchPtr(_result, false);
}

#pragma implementation_key(5133)
inline IDispatchPtr VGCore::IVGWorkspaces::GetParent ( ) {
    IDispatch * _result = 0;
    HRESULT _hr = get_Parent(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IDispatchPtr(_result, false);
}

#pragma implementation_key(5134)
inline VGCore::IVGWorkspacePtr VGCore::IVGWorkspaces::GetItem ( const _variant_t & IndexOrName ) {
    struct IVGWorkspace * _result = 0;
    HRESULT _hr = get_Item(IndexOrName, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGWorkspacePtr(_result, false);
}

#pragma implementation_key(5135)
inline IUnknownPtr VGCore::IVGWorkspaces::Get_NewEnum ( ) {
    IUnknown * _result = 0;
    HRESULT _hr = get__NewEnum(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IUnknownPtr(_result, false);
}

#pragma implementation_key(5136)
inline long VGCore::IVGWorkspaces::GetCount ( ) {
    long _result = 0;
    HRESULT _hr = get_Count(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface IVGRecentFiles wrapper method implementations
//

#pragma implementation_key(5137)
inline VGCore::IVGRecentFilePtr VGCore::IVGRecentFiles::Add ( _bstr_t Name, _bstr_t Path ) {
    struct IVGRecentFile * _result = 0;
    HRESULT _hr = raw_Add(Name, Path, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGRecentFilePtr(_result, false);
}

#pragma implementation_key(5138)
inline IDispatchPtr VGCore::IVGRecentFiles::GetApplication ( ) {
    IDispatch * _result = 0;
    HRESULT _hr = get_Application(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IDispatchPtr(_result, false);
}

#pragma implementation_key(5139)
inline IDispatchPtr VGCore::IVGRecentFiles::GetParent ( ) {
    IDispatch * _result = 0;
    HRESULT _hr = get_Parent(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IDispatchPtr(_result, false);
}

#pragma implementation_key(5140)
inline VGCore::IVGRecentFilePtr VGCore::IVGRecentFiles::GetItem ( long Index ) {
    struct IVGRecentFile * _result = 0;
    HRESULT _hr = get_Item(Index, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGRecentFilePtr(_result, false);
}

#pragma implementation_key(5141)
inline IUnknownPtr VGCore::IVGRecentFiles::Get_NewEnum ( ) {
    IUnknown * _result = 0;
    HRESULT _hr = get__NewEnum(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IUnknownPtr(_result, false);
}

#pragma implementation_key(5142)
inline long VGCore::IVGRecentFiles::GetCount ( ) {
    long _result = 0;
    HRESULT _hr = get_Count(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(5143)
inline long VGCore::IVGRecentFiles::GetMaximum ( ) {
    long _result = 0;
    HRESULT _hr = get_Maximum(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface IVGRecentFile wrapper method implementations
//

#pragma implementation_key(5144)
inline HRESULT VGCore::IVGRecentFile::Delete ( ) {
    HRESULT _hr = raw_Delete();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(5145)
inline IDispatchPtr VGCore::IVGRecentFile::Open ( ) {
    IDispatch * _result = 0;
    HRESULT _hr = raw_Open(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IDispatchPtr(_result, false);
}

#pragma implementation_key(5146)
inline IDispatchPtr VGCore::IVGRecentFile::GetApplication ( ) {
    IDispatch * _result = 0;
    HRESULT _hr = get_Application(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IDispatchPtr(_result, false);
}

#pragma implementation_key(5147)
inline VGCore::IVGRecentFilesPtr VGCore::IVGRecentFile::GetParent ( ) {
    struct IVGRecentFiles * _result = 0;
    HRESULT _hr = get_Parent(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGRecentFilesPtr(_result, false);
}

#pragma implementation_key(5148)
inline long VGCore::IVGRecentFile::GetIndex ( ) {
    long _result = 0;
    HRESULT _hr = get_Index(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(5149)
inline _bstr_t VGCore::IVGRecentFile::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(5150)
inline void VGCore::IVGRecentFile::PutName ( _bstr_t pVal ) {
    HRESULT _hr = put_Name(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(5151)
inline _bstr_t VGCore::IVGRecentFile::GetPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Path(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(5152)
inline void VGCore::IVGRecentFile::PutPath ( _bstr_t pVal ) {
    HRESULT _hr = put_Path(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(5153)
inline _bstr_t VGCore::IVGRecentFile::GetFullName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_FullName(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(5154)
inline void VGCore::IVGRecentFile::PutFullName ( _bstr_t pVal ) {
    HRESULT _hr = put_FullName(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IVGPageSizes wrapper method implementations
//

#pragma implementation_key(5155)
inline VGCore::IVGApplicationPtr VGCore::IVGPageSizes::GetParent ( ) {
    struct IVGApplication * _result = 0;
    HRESULT _hr = get_Parent(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGApplicationPtr(_result, false);
}

#pragma implementation_key(5156)
inline long VGCore::IVGPageSizes::GetCount ( ) {
    long _result = 0;
    HRESULT _hr = get_Count(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(5157)
inline VGCore::IVGPageSizePtr VGCore::IVGPageSizes::GetItem ( const _variant_t & IndexOrName ) {
    struct IVGPageSize * _result = 0;
    HRESULT _hr = get_Item(IndexOrName, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGPageSizePtr(_result, false);
}

#pragma implementation_key(5158)
inline IUnknownPtr VGCore::IVGPageSizes::Get_NewEnum ( ) {
    IUnknown * _result = 0;
    HRESULT _hr = get__NewEnum(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IUnknownPtr(_result, false);
}

#pragma implementation_key(5159)
inline VGCore::IVGPageSizePtr VGCore::IVGPageSizes::Add ( _bstr_t Name, double Width, double Height ) {
    struct IVGPageSize * _result = 0;
    HRESULT _hr = raw_Add(Name, Width, Height, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGPageSizePtr(_result, false);
}

//
// interface IVGPageSize wrapper method implementations
//

#pragma implementation_key(5160)
inline VGCore::IVGPageSizesPtr VGCore::IVGPageSize::GetParent ( ) {
    struct IVGPageSizes * _result = 0;
    HRESULT _hr = get_Parent(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGPageSizesPtr(_result, false);
}

#pragma implementation_key(5161)
inline VARIANT_BOOL VGCore::IVGPageSize::GetBuiltIn ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_BuiltIn(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(5162)
inline _bstr_t VGCore::IVGPageSize::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(5163)
inline double VGCore::IVGPageSize::GetWidth ( ) {
    double _result = 0;
    HRESULT _hr = get_Width(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(5164)
inline void VGCore::IVGPageSize::PutWidth ( double pVal ) {
    HRESULT _hr = put_Width(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(5165)
inline double VGCore::IVGPageSize::GetHeight ( ) {
    double _result = 0;
    HRESULT _hr = get_Height(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(5166)
inline void VGCore::IVGPageSize::PutHeight ( double pVal ) {
    HRESULT _hr = put_Height(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(5167)
inline long VGCore::IVGPageSize::GetIndex ( ) {
    long _result = 0;
    HRESULT _hr = get_Index(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(5168)
inline HRESULT VGCore::IVGPageSize::Delete ( ) {
    HRESULT _hr = raw_Delete();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(5169)
inline VARIANT_BOOL VGCore::IVGPageSize::GetFixedOrientation ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_FixedOrientation(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(5170)
inline enum VGCore::cdrUnit VGCore::IVGPageSize::GetDefaultUnit ( ) {
    enum cdrUnit _result;
    HRESULT _hr = get_DefaultUnit(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface IVGViews wrapper method implementations
//

#pragma implementation_key(5171)
inline VGCore::IVGApplicationPtr VGCore::IVGViews::GetApplication ( ) {
    struct IVGApplication * _result = 0;
    HRESULT _hr = get_Application(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGApplicationPtr(_result, false);
}

#pragma implementation_key(5172)
inline VGCore::IVGDocumentPtr VGCore::IVGViews::GetParent ( ) {
    struct IVGDocument * _result = 0;
    HRESULT _hr = get_Parent(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGDocumentPtr(_result, false);
}

#pragma implementation_key(5173)
inline VGCore::IVGViewPtr VGCore::IVGViews::GetItem ( const _variant_t & IndexOrName ) {
    struct IVGView * _result = 0;
    HRESULT _hr = get_Item(IndexOrName, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGViewPtr(_result, false);
}

#pragma implementation_key(5174)
inline IUnknownPtr VGCore::IVGViews::Get_NewEnum ( ) {
    IUnknown * _result = 0;
    HRESULT _hr = get__NewEnum(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IUnknownPtr(_result, false);
}

#pragma implementation_key(5175)
inline long VGCore::IVGViews::GetCount ( ) {
    long _result = 0;
    HRESULT _hr = get_Count(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(5176)
inline VGCore::IVGViewPtr VGCore::IVGViews::AddActiveView ( _bstr_t Name ) {
    struct IVGView * _result = 0;
    HRESULT _hr = raw_AddActiveView(Name, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGViewPtr(_result, false);
}

//
// interface IVGView wrapper method implementations
//

#pragma implementation_key(5177)
inline VGCore::IVGApplicationPtr VGCore::IVGView::GetApplication ( ) {
    struct IVGApplication * _result = 0;
    HRESULT _hr = get_Application(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGApplicationPtr(_result, false);
}

#pragma implementation_key(5178)
inline VGCore::IVGViewsPtr VGCore::IVGView::GetParent ( ) {
    struct IVGViews * _result = 0;
    HRESULT _hr = get_Parent(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGViewsPtr(_result, false);
}

#pragma implementation_key(5179)
inline _bstr_t VGCore::IVGView::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(5180)
inline void VGCore::IVGView::PutName ( _bstr_t Name ) {
    HRESULT _hr = put_Name(Name);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(5181)
inline double VGCore::IVGView::GetOriginX ( ) {
    double _result = 0;
    HRESULT _hr = get_OriginX(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(5182)
inline void VGCore::IVGView::PutOriginX ( double pVal ) {
    HRESULT _hr = put_OriginX(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(5183)
inline double VGCore::IVGView::GetOriginY ( ) {
    double _result = 0;
    HRESULT _hr = get_OriginY(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(5184)
inline void VGCore::IVGView::PutOriginY ( double pVal ) {
    HRESULT _hr = put_OriginY(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(5185)
inline VARIANT_BOOL VGCore::IVGView::GetUsePage ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_UsePage(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(5186)
inline void VGCore::IVGView::PutUsePage ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_UsePage(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(5187)
inline VGCore::IVGPagePtr VGCore::IVGView::GetPage ( ) {
    struct IVGPage * _result = 0;
    HRESULT _hr = get_Page(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVGPagePtr(_result, false);
}

#pragma implementation_key(5188)
inline void VGCore::IVGView::PutPage ( struct IVGPage * Page ) {
    HRESULT _hr = put_Page(Page);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(5189)
inline VARIANT_BOOL VGCore::IVGView::GetUseZoom ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_UseZoom(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(5190)
inline void VGCore::IVGView::PutUseZoom ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_UseZoom(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(5191)
inline double VGCore::IVGView::GetZoom ( ) {
    double _result = 0;
    HRESULT _hr = get_Zoom(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(5192)
inline void VGCore::IVGView::PutZoom ( double pVal ) {
    HRESULT _hr = put_Zoom(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(5193)
inline HRESULT VGCore::IVGView::Activate ( ) {
    HRESULT _hr = raw_Activate();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(5194)
inline HRESULT VGCore::IVGView::Delete ( ) {
    HRESULT _hr = raw_Delete();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}
